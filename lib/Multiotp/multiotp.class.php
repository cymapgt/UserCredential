<?php
/**
 * @file  multiotp.class.php
 * @brief Main file of the multiOTP PHP class.
 *
 * @mainpage
 *
 * multiOTP PHP class - strong two-factor authentication PHP class
 * multiOTP is OATH certified for TOTP/HOTP
 *
 * http://www.multiOTP.net/
 *
 * Visit http://forum.multiotp.net/ for additional support.
 *
 * The multiOTP package is the lightest package available that provides so many
 * strong authentication functionalities and goodies, and best of all, for anyone
 * that is interested about security issues, it's a fully open source solution!
 *
 * This package is the result of a *bunch* of work. If you are happy using this
 * package, [Donation] are always welcome to support this project.
 * Please check http://www.multiOTP.net/ and you will find the magic button ;-)
 * https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=PRS3VDNYL58HJ
 *
 * If you need some specific features in the open source edition of multiOTP,
 * please contact us in order to discuss about a sponsorship in order to
 * prioritize your needs.
 *
 * The multiOTP class is a strong authentication class in pure PHP
 * that supports the following algorithms:
 *  - OATH/HOTP RFC 4226 (http://tools.ietf.org/html/rfc4226)
 *  - OATH/TOTP RFC 6238 (http://tools.ietf.org/html/rfc6238)
 *  - Google Authenticator (OATH/HOTP or OATH/TOTP, base32 seed, QRcode provisioning)
 *    (http://code.google.com/p/google-authenticator/)
 *  - Yubico OTP (http://yubico.com/yubikey)
 *  - mOTP (http://motp.sourceforge.net/)
 *  - emergency scratch passwords
 *  - SMS tokens
 *
 * This class can be used as is in your own PHP project, but it can also be
 * used easily as an external authentication provider with at least the
 * following RADIUS servers (using the multiotp command line script):
 *  - FreeRADIUS, a free RADIUS server implementation for Linux and
 *    and *nix environments (http://freeradius.org/)
 *  - WinRADIUS, the FreeRADIUS implementation ported for Windows
 *    (http://winradius.eu/)
 *  - FreeRADIUS for Windows, an other FreeRADIUS implementation ported
 *    for Windows (http://sourceforge.net/projects/freeradius/)
 *  - TekRADIUS LT, a free RADIUS server for Windows with SQLite backend
 *    (http:/www.tekradius.com/)
 *  - TekRADIUS, a free RADIUS server for Windows with MS-SQL backend
 *    (http:/www.tekradius.com/)
 *
 * This class is also used as the central component in various commercial
 * products and services developed by SysCo systemes de communication sa:
 *  - multiOTP Pro, available as a virtual appliance or a device in order
 *    to provide a complete strong authentication solution with a simple
 *    to use web based interface (http://www.multiotp.com/)
 *  - secuPASS.net, a simple service to centralize provisioning and SMS
 *    authentication for (free) Wifi hotspot (http://www.secupass.net/)
 *
 * The Readme file contains additional information.
 *
 * PHP 5.3.0 or higher is supported.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.3.2.6
 * @date      2015-07-18
 * @since     2010-06-08
 * @copyright (c) 2010-2015 SysCo systemes de communication sa
 * @copyright GNU Lesser General Public License
 *
 *//*
 *
 * LICENCE
 *
 *   Copyright (c) 2010-2015 SysCo systemes de communication sa
 *   SysCo (tm) is a trademark of SysCo systemes de communication sa
 *   (http://www.sysco.ch/)
 *   All rights reserved.
 * 
 *   This file is part of the multiOTP project.
 *
 *   multiOTP PHP class is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Lesser General Public License as
 *   published by the Free Software Foundation, either version 3 of the License,
 *   or (at your option) any later version.
 * 
 *   multiOTP PHP class is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 * 
 *   You should have received a copy of the GNU Lesser General Public
 *   License along with multiOTP PHP class.
 *   If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * Usage
 *
 *   require_once('multiotp.class.php');
 *   $multiotp = new Multiotp('MyPersonalEncryptionKey');
 *   // The use of $multiotp->SetEncryptionKey('MyPersonalEncryptionKey')
 *   // after creating the class without argument is DEPRECATED
 *   $multiotp->SetUser('user');
 *   $result = $multiotp->CheckToken('token');
 *
 *
 * Examples
 *
 *  Create a new user
 *    require_once('multiotp.class.php');
 *    $multiotp = new Multiotp('MyPersonalEncryptionKey');
 *    // The use of $multiotp->SetEncryptionKey('MyPersonalEncryptionKey')
 *    // after creating the class without argument is DEPRECATED
 *    $multiotp->EnableVerboseLog(); // Could be helpful at the beginning
 *    $multiotp->SetUser('username');
 *    $multiotp->SetUserPrefixPin(0); // We don’t want the prefix PIN feature for this example
 *    $multiotp->SetUserAlgorithm('TOTP');
 *    $multiotp->SetUserTokenSeed('D6F9DF7C0110C85D6F9D');
 *    $multiotp->SetUserPin('1111'); // Useless for TOTP in this case without prefix PIN feature
 *    $multiotp->SetUserTokenNumberOfDigits(6);
 *    $multiotp->SetUserTokenTimeInterval(30);
 *    $multiotp->WriteUserData();
 *  
 *  
 *  Verify a token
 *    require_once('multiotp.class.php');
 *    $multiotp = new Multiotp('MyPersonalEncryptionKey');
 *    // The use of $multiotp->SetEncryptionKey('MyPersonalEncryptionKey')
 *    // after creating the class without argument is DEPRECATED
 *    $multiotp->EnableVerboseLog(); // Could be helpful at the beginning
 *    $multiotp->SetUser('username');
 *    if (0 == $multiotp->CheckToken('token')) {
 *        // Authentication accepted
 *    } else {
 *        // Authentication rejected
 *    }
 *  
 *  
 *  Resync a user (normally only useful for HOTP, but useful too if TOTP/mOTP device or server is not well synchronized)
 *    require_once('multiotp.class.php');
 *    $multiotp = new Multiotp('MyPersonalEncryptionKey');
 *    // The use of $multiotp->SetEncryptionKey('MyPersonalEncryptionKey')
 *    // after creating the class without argument is DEPRECATED
 *    $multiotp->EnableVerboseLog(); // Could be helpful at the beginning
 *    $multiotp->SetUser('username');
 *    if (0 == $multiotp->CheckToken('token1','token2')) // it must two consecutive tokens {
 *        // Synchronization successful
 *    } else {
 *        // Synchronization failed
 *    }
 *
 *
 *  Verify a token and be sure to encrypt some more data in the flat file
 *    require_once('multiotp.class.php');
 *    $multiotp = new Multiotp('MyPersonalEncryptionKey');
 *    // The use of $multiotp->SetEncryptionKey('MyPersonalEncryptionKey')
 *    // after creating the class without argument is DEPRECATED
 *    $multiotp->EnableVerboseLog(); // Could be helpful at the beginning
 *    $multiotp->SetAttributesToEncrypt('*user_pin*token_seed*token_serial*seed_password*');
 *    $multiotp->SetUser('username');
 *    if (0 == $multiotp->CheckToken('token')) {
 *        // Authentication accepted
 *    } else {
 *        // Authentication rejected
 *    }
 *  
 *
 *   For examples on how to integrate it with radius servers, please have a look
 *   to the readme.txt file or read the header of the multiotp.cli.header.php file.
 *
 *
 * External files created
 *
 *   Users database files in the subfolder called users (or anywhere else if defined)
 *   Tokens database files in the subfolder called tokens (or anywhere else if defined)
 *   Log file in the subfolder called log (or anywhere else if defined)
 *   Configuration file in the subfolder called config (or anywhere else if defined)
 *
 *
 * External files needed
 *
 *   Users database files in the subfolder called users
 *   Tokens database files in the subfolder called tokens
 *
 *
 * External packages used
 *
 *   NuSOAP - PHP Web Services Toolkit 1.123 (LGPLv2.1)
 *   NuSphere Corporation
 *   http://sourceforge.net/projects/nusoap/
 *
 *   phpseclib 0.3.8 (MIT License)
 *   MMVI Jim Wigginton
 *   http://phpseclib.sourceforge.net/
 *
 *   PHP LDAP CLASS FOR MANIPULATING ACTIVE DIRECTORY 2.1 (LGPLv2.1)
 *   Scott Barnett
 *   http://adldap.sourceforge.net/
 *
 *   PHP radius class 1.2.2 (LGPLv3)
 *   André Liechti
 *   http://developer.sysco.ch/php/
 *
 *   PHP Syslog class 1.1.2 (FREE "AS IS")
 *   André Liechti
 *   http://developer.sysco.ch/php/
 *
 *   QRcode image PHP scripts 0.50j (FREE "AS IS")
 *   Y. Swetake
 *   http://www.swetake.com/qr/index-e.html
 *
 *   status_bar.php (2010) (FREE "AS IS")
 *   dealnews.com, Inc.
 *   http://brian.moonspot.net/status_bar.php.txt
 *
 *   TCPDF 6.0.061 (LGPLv3)
 *   Nicola Asuni
 *   http://www.tcpdf.org/
 *
 *   XML Parser Class 1.3.0 (LGPLv3)
 *   Adam A. Flynn
 *   http://www.criticaldevelopment.net/xml/
 *
 *   XPertMailer package 4.0.5 (LGPLv2.1)
 *   Tanase Laurentiu Iulian
 *   http://xpertmailer.sourceforge.net/
 *
 *
 * Special issues
 *
 *   If you need specific developements concerning strong authentication,
 *   do not hesistate to contact us per email at info@multiotp.net.
 *
 *
 * Other related ressources
 *
 *   Mobile-OTP: Strong Two-Factor Authentication with Mobile Phones:
 *     http://motp.sourceforge.net/
 *
 *   The Initiative for Open Authentication:
 *     http://www.openauthentication.org/
 *
 *   TekRADIUS, a free RADIUS server for windows, available in two versions (MS-SQL and SQLite):
 *     http://www.tekradius.com/
 *
 *   FreeRADIUS, a free Radius server implementation for Linux and *nix environments:
 *     http://www.freeradius.org/
 *
 *   WinRADIUS, the FreeRADIUS implementation ported for Windows
 *     (http://winradius.eu/)
 *
 *   FreeRADIUS for Windows, an other freeRADIUS server implementation ported
 *     for Windows (http://sourceforge.net/projects/freeradius/)
 *
 *   Additional Portable Symmetric Key Container (PSKC) Algorithm Profiles
 *     RFC 6030 (http://tools.ietf.org/html/rfc6030)
 *
 *   Google Authenticator (based on OATH/TOTP)
 *     http://code.google.com/p/google-authenticator/
 *
 *
 * Users feedbacks and comments
 *
 * 2015-07-14 Pierre-Nicolas Paradis, SherWeb (FR)
 *   Pierre-Nicolas informed us that it was still not possible to change
 *    the admin password using the web GUI. This has been corrected.
 *
 * 2015-06-23 Jun Li (CN)
 *   As proposed by Jun Li, launching the command line version without
 *    enough parameters returns now a 30 error code (instead of 19).
 *    Side effect is that -help is now required to display help page.
 *
 * 2015-06-02 Jean-François Perillo, Kudelski Security (CH)
 *   As proposed by Jean-François, token length error information has been
 *    added in the regular log and the autoresync is now enabled by default.
 *
 * 2015-06-02 Sébastien Charlier, Thesis SA (CH)
 * 2015-03-09 Martin
 *   Martin and Sébastien informed us that passwords containing the minus sign are not accepted.
 *
 * 2015-02-16 Sylvain Maret, Kudelski Security (CH)
 *   Sylvain informed us that Gemalto PSKC file don't provide the time interval for TOTP tokens.
 *   RFC default value (30 seconds) is now set by default if no time interval is given.
 *
 * 2015-01-27 Thomas Klute, ingenit GmbH & Co. KG (DE)
 *   Thanks Thomas for you feedback concerning a potential exploit with dots and slashes in a username.
 *   Even if no information can be extracted using this method, it's always good to patch this kind of weakness.
 *
 * 2015-01-08 Markus Arnoldi, LEWA Attendorn GmbH (DE)
 *   Useful comments about prefix PIN handling, documentation has been enhanced.
 *   Two new command line options are now available (fastcreatenopin and fastecreatewithpin)
 *
 * 2014-12-22 Sajid Hameed, Network Places Ltd (UK)
 *   Questions about users lockout, documentation has been enhanced.
 *   Three command line options information has been added in the documentation.
 *
 * 2014-12-15 Steve Jacot-Guillarmod, Swissdotnet SA (CH)
 *   Thanks Steve for your valuable feedback about LDAP sync and groups
 *   handling with a specific Synology OpenLDAP server implementation.
 *
 * 2014-11-04 Yubico Inc. (USA) / Yubico AB (S) / Yubico Ltd. (UK)
 *   BIG THANKS to the Yubico team which provides us several YubiKeys for the
 *   workshop organized during the Application Security Forum in Yverdon-les-Bains (Switzerland).
 *   Starting with version 4.3.0.0, YubiKeys (both Yubico OTP and HOTP) are now also supported and easy to import.
 *   (simply import the YubiKey traditional format log file)
 *
 * 2014-10-13 Adam Twardowski, Choopa LLC (USA)
 *   Thanks Adam for your valuable feedback concerning a bug with the NT_KEY generation if prefix PIN is enabled.
 *   Adam discovered the bug and fixed it when he configured pptpd with
 *   FreeRADIUS in order to set up a PPTP VPN with strong authentication.
 *
 * 2014-04-04 Stefan Kügler, SerNet GmbH (DE)
 * 2014-04-01 Daniel Särnström, Donator AB (SE)
 *   Daniel & Stefan asks some info in order to import tokens without a know format.
 *   Good question, multiOTP supports now importation of tokens from CSV file.
 *
 * 2014-04-02 Prashant Kumar, Alscient (UK)
 *   Prash is playing with FreeRADIUS and VPN (PPTP with MPPE). This requires radius to send MPPE keys.
 *   Interesting feedback, multiOTP provides now NT_KEY, like the ntlm_auth external helper.
 *
 * 2014-03-31 Alex Tasikas (GR)
 *   Thanks Alex for your valuable feedback concerning some bugs in LDAP support.
 *
 * 2014-03-25 Prashant Kumar, Alscient (UK)
 *   As proposed by Prash, we have added the possibility to modify the list of attributes to encrypt.
 *
 * 2014-03-17 Arthur de Jong, West Consulting (NL)
 *   Arthur gave some feedbacks concerning distributing the source code in the
 *    "preferred form of the work for making modifications".
 *
 * 2014-03-14 Soeren Malchow, MCON (DE)
 *   Thanks for your feedback concerning a bug in the SQL request for the log table.
 *
 * 2014-01-27 Henk van der Helm (NL)
 *   MANY thanks for your appreciated $$$ donation.
 *
 * 2014-01-19 Erik Nylund (FI)
 *   Thanks four your feedback concerning specific parameters order in QRCode for Microsoft Authenticator
 *
 * 2014-01-14 Sylvain Maret, Kudelski Security (CH)
 *   Thanks for your feedback concerning possible zero division in the ComputeOathTruncate method.
 *    Method has been altered in order to be more compatible with almost any PHP version.
 *   Thanks also for the suggestion to resync without the prefix PIN. Both are supported now.
 *
 * 2014-01-08/09  Cheng Shao-Pin (CN)
 *   Thanks for your feedback concerning possible missing JSON extension in old PHP distribution
 *    and possible image functions incompatibilities with some PHP versions during QRcode generation.
 *   Thanks also for your appreciated $ donation.
 *
 * 2014-01-08  Cheng Shao-Pin (CN) and Daniel Särnström, Donator AB (SE)
 *   Thanks for your feedback concerning md5.js missing in the distribution.
 *
 * 2013-12-20 Rico Zeiss, Hermann Wegener GmbH & Co. KG (DE)
 *   MANY thanks for your appreciated $$$ sponsorship to support us to add MS-CHAP and MS-CHAPv2 in a next release.
 *
 * 2013-12-18 Xavier Céspedes (ES)
 *   Thanks to Xavier who noticed a problem with the hex2bin() function duringthe scratch password generation.
 *   In the meantime, the GetUserScratchPasswordsList() function has been improved and fixed and is in the 4.1 release.
 *
 * 2013-09-20 Sean Butler-Lee (IE)
 *   Thanks a lot for announcing a bug with the GetUserScratchPasswordsArray() method.
 *
 * 2013-08-22,26 Frank Bongrand (FR)
 *   Thanks a lot for valuable feedbacks concerning some minor bugs in 4.0.4 and 4.0.6
 *
 * 2013-08-21 Henk van der Helm (NL)
 *   Thanks a lot for a valuable feedback concerning some minor bugs in 4.0.4
 *
 * 2013-08-15 Donator AB (SE)
 *   MANY thanks for your appreciated $$$ sponsorship to support us to add self-registration in a next release.
 *
 * 2013-08-13 Daniel Särnström, Donator AB (SE)
 *   Daniel proposed to add self-registration and pskc v12 with encrypted data support (OATH compliant).
 * 
 * 2013-07-25 Dominik Pretzsch from Last Squirrel IT (DE)
 *   After some discussions with Dominik, integration of the client/server support in the basic library
 *
 * 2013-07-23 Stefan Kügler (DE) (again ;-)
 *   Stefan proposed to add the possibility to show the log, which is especially convenient for MySQL log.
 *   He proposed also to be able to call an external program to send SMS.
 *
 * 2013-07-11 Stefan Kügler (DE)
 *   Stefan proposed to add a lock and unlock option for the user.
 *
 * 2013-06-19 SerNet GmbH (DE)
 *   MANY thanks for your appreciated $$$ sponsorship after we implemented some features proposed by Stefan Kügler.
 *
 * 2013-06-13 Henk van der Helm (NL) (again ;-)
 *   Henk proposed to be able to have a specific description for the software token.
 *   (we use the already existing user description attribute)
 *
 * 2013-06-01 Stefan Irion (CH)
 *   Thanks for your appreciated $$ donation.
 *
 * 2013-05-14 Henk van der Helm (NL)
 *   Henk asked to support also the provider IntelliSMS. Thanks for the $$ sponsorship!
 *
 * 2013-05-03 Stefan Kügler (DE)
 *   Stefan proposed to lower the default max_time_window to 600 seconds.
 *
 * 2013-03-04 Alan DeKok (CA)
 *   Alan proposed in the freeradius mailing-list to put a prefix to be able to handle the
 *   debug info by the freeradius server.
 *
 * 2012-11-28  Gareth Thomas
 *   Thanks for your appreciated $$ donation.
 *
 * 2012-03-16 Nicolas Goralski (LU)
 *   Nicolas proposed an enhancement in order to support PAM. Thanks also for the $$ sponsorship!
 *     (with the -checkpam option in the command line edition)
 *
 * 2011-05-19 Fabiano Domeniconi (CH)
 *   Fabiano found old info in the samples, CheckToken() is not boolean anymore! Samples fixed.
 *
 * 2011-04-24 Steven Roddis (AU)
 *   Steven asked for more examples. Thanks to Steven for the $ donation ;-)
 *
 * 2010-09-15 Jasper Pol (NL)
 *   Jasper has added an initial MySQL backend support
 *
 * 2010-09-13 Brenno Hiemstra (NL)
 *   Brenno reported bad extra spaces after the #!/usr/bin/php in the Linux version of multiotp.php
 *
 * 2010-08-20 C. Christophi, BirdNet (CH)
 *   Documentation enhancement proposal for the TekRADIUS part, thanks !
 *
 * 2010-07-19 SysCo/al (CH)
 *   Well, as requested by some users, the new "class" design is done, enjoy !
 *
 *
 * Todos
 *
 *   Add more comments in the main class file
 *
 *
 * Change Log
 *
 *   2015-07-18 4.3.2.6 SysCo/al New ResetTempUserArray method (as we want to move away from global array in the near future)
 *                               For _user_data, default values are now extracted from the definition array
 *                               QRcode generation for mOTP (motp://[SITENAME]:[USERNAME]?secret=[SECRET-KEY])
 *   2015-07-15 4.3.2.5 SysCo/al Calling multiotp CLI without parameter returns now error code 30 (instead of 19)
 *   2015-06-24 4.3.2.4 SysCo/al multi_account automatic support
 *                               Scratch password generation (UTF)
 *   2015-06-10 4.3.2.3 SysCo/al Enhancements for the Dev(Talks): demo
 *   2015-06-09 4.3.2.2 SysCo/al Empty users are refused
 *                               TOTP time interval of imported tokens is set by default to 30s
 *                               More accuracy in the logged information
 *                               Refactoring backend methods, sharing code
 *                               Refactoring some ugly parts (!)
 *                               Documentation update concerning lockout functions and prefix PIN prefix
 *                               Special token entry 'Sms' is now also accepted, like 'SMS' or 'sms', to send an SMS token
 *                               The minus (-) in the prefix password is now supported (it was filtered to fix some rare user issues)
 *                               The autoresync option is now enabled by default
 *                               Resync during authentication (autoresync) is now better handled in the class directly
 *                               The server_cache_level is now set to 1 by default (instead of 0)
 *                               If the token length is not correct, it's now written in the log
 *                               Some LDAP messages are now only logged in debug mode
 *   2014-12-15 4.3.1.1 SysCo/al Better generic LDAP support
 *                                 - description sync done in the following order: description, gecos, displayName
 *                                 - memberOf is not always implemented, alternative method to sync users based on group names.
 *                                 - disabled account synchronization using shadowExpire or sambaAcctFlags
 *                               Better Active Directory support
 *                                 - accountExpires is now supported for synchronization
 *                                 - ms-DS-User-Account-Control-Computed (to handle locked out accounts, available since Windows 2003)
 *   2014-12-09 4.3.1.0 SysCo/al MULTIOTP_PATH environment variable support
 *                               CLI proxy added to speed up the command line
 *                               Scratch password need also the prefix PIN if it's activated
 *                               OTP with integrated serial numbers better supported (in PAP)
 *                               Generic LDAP support (instead of Microsoft AD support only)
 *                               Raspberry Pi edition has now a special proxy to speed up the command line
 *   2014-11-04 4.3.0.0 SysCo/al It's now possible to use the AD/LDAP password instead of the PIN code
 *                               Yubico OTP support, including keys import using the log file in Traditional format
 *                               qrcode() stub enhanced to check if the required folders are available
 *                               SyncLdapUsers completely redesigned
 *                                 - no more complete array in memory
 *                                 - MultiotpAdLdap class also enhanced accordingly
 *                                   - cached group_cn requests
 *                                   - cached recursive_groups requests
 *                                   - new "by element" functions
 *                               Demo mode support
 *                               Bug fix concerning the NT_KEY generation with enabled prefix PIN (thanks Adam)
 *                               ResyncToken() method added (instead of using CheckToken() method for synchronization)
 *   2014-06-12 4.2.4.3 SysCo/al Bug fix concerning aspsms provider
 *   2014-04-13 4.2.4.2 SysCo/al XML parsing consolidation, one library for the whole project
 *                               Fixed bug concerning tokens CSV import
 *   2014-04-06 4.2.4.1 SysCo/al Fixed bug concerning LDAP handling
 *                               NT_KEY support added (for FreeRADIUS further handling)
 *                               Tokens CSV import (serial_number;manufacturer;algorithm;seed;digits;interval_or_event)
 *                               When a user is deleted, the token(s) attributed to this user is/are unassigned
 *                               New option -user-info added
 *   2014-03-30 4.2.4   SysCo/al Fixed bug concerning MySQL handling and mysqli support added
 *                               Enhanced SetAttributesToEncrypt function
 *                               New implementation fo some external classes
 *                               Generated QRcode are better
 *                               LOT of new QA tests, more than 60 different tests (including PHP class and command line versions)
 *                               Enhanced documentation
 *   2014-03-13 4.2.3   SysCo/al Fixed bug for clear text password going back to TekRADIUS (PIN was always prefixed for mOTP)
 *                               Fixed bug when client/server mode is activated, but not working well
 *   2014-03-03 4.2.2   SysCo/al Better AD/LDAP integration
 *                               Web GUI is now complete for a simple usage, including hardware tokens import
 *                               Better template for provisioning information
 *                               Some values can now go back to TekRADIUS
 *                               If activated, prefix PIN is now also requested for SMS authentication
 *                               More information in the logs
 *                               Better list of the external packages used
 *   2014-02-14 4.2.1   SysCo/al AD/LDAP is now fully supported in order to create users based on AD/LDAP content
 *                                (with groups filtering)
 *   2014-02-07 4.2.0   SysCo/al MS-CHAP and MS-CHAPv2 are now supported
 *                                (md4 implementation added for PHP backward compatibility)
 *                               Enhanced LDAP configuration structure
 *                               Fixed bug during token attribution to users
 *                                (a "no name" token appeared sometimes)
 *   2014-01-20 4.1.1   SysCo/al md5.js was missing in the public distribution
 *                               Alternate json_encode function is defined if the JSON extension is not loaded
 *                               Fixed possible image functions incompatibilities with some PHP versions
 *                                during QRcode generation
 *                               As suggested by Sylvain, token resync doesn't need prefix PIN anymore
 *                                (but still accepted)
 *                               More verbosity in the logs in debug mode
 *                               Specific parameters order in QRCode for Microsoft Authenticator support
 *                                (thanks to Erik Nylund)
 *   2013-12-23 4.1.0   SysCo/al The open source edition of multiOTP is OATH certified ;-)
 *                                (that means full compatibility with any OATH tokens and encrypted PSKC import support)
 *                               Raspberry Pi nanocomputer is now fully supported
 *                               Basic web interface
 *                               Self-registration of hardware tokens is now possible
 *                                PAP mode: if self-registration is enabled, a user can register a non-attributed token by typing
 *                                [serial number][OTP] instead of [OTP]. If user has a prefix PIN, type [serial number][PIN][OTP])
 *                                PAP/CHAP mode: if self-registration is enabled, a user can register a non-attributed token by typing
 *                                [username:serialnumber] as the username and the [OTP] in the password field.
 *                                If user has a prefix PIN, [PIN][OTP] must be typed in the password field
 *                               Automatic resync/unlock option during authentication (PAP only). When the autoresync option
 *                                is enabled, any user can resync his token by typing [OTP1] [OTP2] in the password field. 
 *                                If user has a prefix PIN, he must type [PIN][OTP1] [PIN][OTP2].
 *                               Tokens with less than 3 characters are not accepted anymore in CheckToken()
 *                               Default Linux file mode is now set by default (0666 for created and changed files)
 *                               Error 28 is returned if the file is not writable, even after a successful login
 *                               Added GetUsersCount() function
 *                               Added GenerateSmsToken() function
 *                               Added Groups management functions
 *                               Added Tokens assignation functions
 *                               Added SetUserActivated(1|0) and GetUserActivated() function
 *                               Added SetUserSynchronized(1|0) and GetUserSynchronized() function
 *                               scratch_passwords is now a text field in the database
 *                               The third parameter of the Decrypt method is now mandatory
 *                               Some modifications in order to correctly handle the class methods
 *   2013-09-22 4.0.9   SysCo/al Fixed a bug in GetUserScratchPasswordsArray. If a user had no scratch password
 *                                and the implementation accepted blank password, it was accepted
 *                               Fixed a bug where scratch passwords generation used odd numbers of characters for hex2bin()
 *   2013-08-30 4.0.7   SysCo/al GetScriptFolder() was still buggy sometimes, thanks Frank for the feedback
 *                               File mode of the created QRcode file is also changed based on GetLinuxFileMode()
 *                               'sms' as the password to request an SMS token can now be sent in lower or uppercase
 *                               Added a description attribute for the tokens
 *   2013-08-25 4.0.6   SysCo/al base32_encode() is now RFC compliant with uppercases
 *                               GetUserTokenQrCode() and GetTokenQrCode() where buggy
 *                               GetScriptFolder() use now __FILE__ if the full path is included
 *                               When doing a check in the CLI header, @... is automatically removed from the
 *                                username if the user doesn't exist, and the check is done on the clean name
 *                               Added a lot of tests to enhance release quality
 *   2013-08-21 4.0.5   SysCo/al Fixed the check of the cache lifetime
 *                               Added a temporary server blacklist during the same instances
 *                               Default server timeout is now set to 1 second
 *   2013-08-20 4.0.4   SysCo/al Added an optional group attribute for the user
 *                                (which will be send with the Radius Filter-Id option)
 *                               Added scratch passwords generation (if the token is lost)
 *                               Automatic database schema upgrade using method UpgradeSchemaIfNeeded()
 *                               Added client/server support with local cache
 *                               Added CHAP authentication support (PAP is of course still supported)
 *                               The encryption key is now a parameter of the class constructor
 *                               The method SetEncryptionKey('MyPersonalEncryptionKey') is DEPRECATED
 *                               The method DefineMySqlConnection is DEPRECATED
 *                               Full MySQL support, including tables creation (see example and SetSqlXXXX methods)
 *                               Added email, sms and seed_password to users attributes
 *                               Added sms support (aspsms, clickatell, intellisms, exec)
 *                               Added prefix support for debug mode (in order to send Reply-Message := to Radius)
 *                               Added a lot of new methods to handle easier the users and the tokens
 *                               General speedup by using available native functions for hash_hmac and others
 *                               Default max_time_window has been lowered to 600 seconds (thanks Stefan for suggestion)
 *                               Integrated Google Authenticator support with integrated base 32 seed handling
 *                               Integrated QRcode generator library (from Y. Swetake)
 *                               General options in an external configuration file
 *                               Comments have been reformatted and enhanced for automatic documentation
 *                               Development process enhanced, source code reorganized, external contributions are
 *                                added automatically at the end of the library after an internal build release
 *   2011-10-25 3.9.2   SysCo/al Some quick fixes after intensive check
 *                               Improved get_script_dir() in CLI for Linux/Windows compatibility
 *   2011-09-15 3.9.1   SysCo/al Some quick fixes concerning multiple users
 *   2011-09-13 3.9.0   SysCo/al Added support for account with multiple users
 *   2011-07-06 3.2.0   SysCo/al Encryption hash handling with additional error message 33
 *                                (if the key has changed)
 *                               Added more examples
 *                               Added generic user with multiple account
 *                                (Real account name is combined: "user" and "account password")
 *                               Added log options, now default doesn't log token value anymore
 *                               Debugging MySQL backend support for the token handling
 *                               Fixed automatic detection of \ or / for script path detection
 *   2010-12-19 3.1.1   SysCo/al Better MySQL backend support, including in CLI version
 *   2010-09-15 3.1.0   SysCo/al Removed bad extra spaces in the multiotp.php file for Linux
 *                               MySQL backend support
 *   2010-09-02 3.0.0   SysCo/al Added tokens handling support
 *                                including importing XML tokens definition file
 *                                (http://tools.ietf.org/html/draft-hoyer-keyprov-pskc-algorithm-profiles-00)
 *                               Enhanced flat database file format (multiotp is still compatible with old versions)
 *                               Internal method SetDataReadFlag renamed to SetUserDataReadFlag
 *                               Internal method GetDataReadFlag renamed to GetUserDataReadFlag
 *   2010-08-21 2.0.4   SysCo/al Enhancement in order to use an alternate php "compiler" for Windows command line
 *                               Documentation enhancement
 *   2010-08-18 2.0.3   SysCo/al Minor notice fix
 *   2010-07-21 2.0.2   SysCo/al Fix to create correctly the folders "users" and "log" if needed
 *   2010-07-19 2.0.1   SysCo/al Foreach was not working well in PHP4, replaced at some places
 *   2010-07-19 2.0.0   SysCo/al New design using a class, mOTP support, cleaning of the code
 *   2010-06-15 1.1.5   SysCo/al Added OATH/TOTP support
 *   2010-06-15 1.1.4   SysCo/al Project renamed to multiotp to avoid overlapping
 *   2010-06-08 1.1.3   SysCo/al Typo in script folder detection
 *   2010-06-08 1.1.2   SysCo/al Typo in variable name
 *   2010-06-08 1.1.1   SysCo/al Status bar during resynchronization
 *   2010-06-08 1.1.0   SysCo/al Fix in the example, distribution not compressed
 *   2010-06-07 1.0.0   SysCo/al Initial implementation
 *********************************************************************/

class Multiotp
/**
 * @class     Multiotp
 * @brief     Main class definition of the multiOTP project.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.3.2.6
 * @date      2015-07-18
 * @since     2010-07-18
 */
{
    var $_version;                  // Current version of the library
    var $_date;                     // Current date of the library
    var $_copyright;                // Copyright message of the library, don't change it !
    var $_website;                  // Website dedicated to this LGPL library, please don't change it !

    var $_base_dir;                 // Specific base directory
    var $_valid_algorithms;         // String containing valid algorithms to be used, separated by *, like *mOTP*HOTP*TOTP*YubicoOTP*
    var $_attributes_to_encrypt;    // Attributes to encrypt in the flat files
    var $_encryption_key;           // Symetric encryption key for the users files and the tokens files
    var $_source_tag;               // Source tag of the request (for a shared installation for example)
    var $_source_ip;                // Source IP of the request (for a RADIUS request for example, Packet-Src-IP-Address)
    var $_source_mac;               // Source MAC of the request (for a RADIUS request for example, Called-Station-Id)
    var $_calling_ip;               // Source IP of the request (for a RADIUS request for example, Framed-IP-Address)
    var $_calling_mac;              // Source MAC of the request (for a RADIUS request for example, Calling-Station-Id)
    var $_chap_challenge;           // CHAP-Challenge (instead of traditional PAP password)
    var $_chap_id;                  // CHAP-Id (instead of traditional PAP password)
    var $_chap_password;            // CHAP-Password (instead of traditional PAP password)
    var $_ms_chap_challenge;        // MS-CHAP challenge
    var $_ms_chap_response;         // MS-CHAP response
    var $_ms_chap2_response;        // MS-CHAP2 response
    var $_ms_nt_key;                // NTLM NT key
    var $_errors_text;              // An array containing errors text description
    var $_config_data;              // An array with all the general config related info
    var $_config_folder;            // Folder where the general config file is written
    var $_device;                   // Current device
    var $_device_data;              // An array with all the device related info
    var $_group;                    // Current group
    var $_group_data;               // An array with all the group related info
    var $_user;                     // Current user, case insensitive
    var $_user_data;                // An array with all the user related info
    var $_user_data_read_flag;      // Indicate if the user data has been read from the database file
    var $_users_folder;             // Folder where users definition files are stored
    var $_qrcode_folder;            // Folder where qrcode files are stored
    var $_templates_folder;         // Folder where template files are stored
    var $_devices_folder;           // Folder where devices definition files are stored
    var $_groups_folder;            // Folder where groups definition files are stored
    var $_token;                    // Current token, case insensitive
    var $_token_data;               // An array with all the token related info
    var $_token_data_read_flag;     // Indicate if the token data has been read from the database file
    var $_tokens_folder;            // Folder where tokens definition files are stored
    var $_log_folder;               // Folder where log file is written
    var $_log_file_name;            // Name of the log file
    var $_log_flag;                 // Enable or disable the log
    var $_log_header_written;       // Internal flag to know if the header was already written or not in the log file
    var $_log_verbose_flag;         // Enable or disable the verbose mode for the log
    var $_log_display_flag;         // Log will also be displayed on the console
    var $_last_imported_tokens;     // An array containing the names (which are mostly the serials) of the last imported tokens
    var $_reply_array_for_radius;   // Specific reply message(s) for the radius (to be displayed in all cases by the command line tool)
    var $_initialize_backend;       // Initialize backend flag
    var $_debug_via_html;           // Set the debug output to HTML standard
    var $_linux_file_mode;          // File mode of the created linux files in octal (for example '0644')
    var $_server_challenge;         // Server challenge for client-server mutual authentication
    var $_xml_dump_in_log;          // For internal debugging only
    var $_servers_temp_bad_list;    // Temporary list of servers that are not currently responding well
    var $_test_server_secret;       // Temporary server secret for tests
    var $_last_clear_otp_value;     // Last clear OTP value (including the prefix if typed)
    var $_last_ldap_error;          // Last LDAP/AD error (boolean)
    var $_parser_pointers;          // An array of pointers used for iterative parsing
    var $_cache_folder;             // Folder where the cache file is written
    var $_ldap_server_reachable;    // Flag to know if the LDAP server is reachable
    var $_sql_tables;               // Array of alias names for SQL tables    


    function Multiotp(
        $encryption_key = "",
        $initialize_backend = false,
        $base_dir = "",
        $config_dir = ""
    )
    /**
     * @brief   Class constructor.
     *
     * @param   string  $encryption_key      A specific encryption key to encrypt stored data instead of the default one.
     * @param   boolean $initialize_backend  If we initialize the backend, we don't want to write in the database before the end of the initialization.
     * @param   boolean $base_dir            Define the base directory, which is always better than automatic detection.
     * @param   boolean $config_dir          Define the config directory, which is always better than automatic detection.
     * @retval  void
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.3.2.6
     * @date    2015-07-18
     * @since   2010-07-18
     */
    {
        // destructor definition (for PHP 4 compatibility)
        if (!version_compare(phpversion(), '5', '>='))
        {
            register_shutdown_function(array(&$this, '__destruct'));
        }

        // Ignore the LDAP certificate validity (for Windows only)
        putenv('LDAPTLS_REQCERT=never');


        $this->_class = base64_decode('bXVsdGlPVFA=');
        $this->_version = '4.3.2.6'; // You should add a suffix for your changes (for example 4.3.2.2-andy-2015-06-09)
        $this->_date = '2015-07-18'; // You should add a suffix for your changes (for example YYYY-MM-DD / YYY2-M2-XX)
        $this->_copyright = base64_decode('KGMpIDIwMTAtMjAxNSBTeXNDbyBzeXN0ZW1lcyBkZSBjb21tdW5pY2F0aW9uIHNh');
        $this->_website = base64_decode('aHR0cDovL3d3dy5tdWx0aU9UUC5uZXQ=');
        
        $this->_log_header_written    = FALSE; // Flag indicating if the header has already been written in the log file or not
        $this->_valid_algorithms      = '*mOTP*HOTP*TOTP*YubicoOTP*'; // Supported algorithms, don't change it (unless you have added the handling of a new algorithm ;-)
        $this->_attributes_to_encrypt = '*admin_password_hash*challenge*device_secret*ldap_hash_cache*ldap_server_password*scratch_passwords*seed_password*server_secret*sms_api_id*sms_otp*sms_password*sms_userkey*smtp_password*sql_password*token_seed*user_pin*'; // This default list of attributes can be changed using SetAttributesToEncrypt(). Each attribute must be between "*".
        
        $this->_ldap_server_reachable = FALSE;
        
        $this->_sql_tables = array('cache',
                                   'config',
                                   'devices',
                                   'groups',
                                   'log',
                                   'tokens',
                                   'users'
                                  );
        
        $this->_sql_tables_schema['cache']   = array(
            'active_users_count'      => "int(10) DEFAULT -1",
            'last_update'             => "int(10) DEFAULT 0",
            'locked_users_count'      => "int(10) DEFAULT -1",
            'locked_users_list'       => "int(10) DEFAULT -1",
            'users_count'             => "int(10) DEFAULT -1");
        $this->_sql_tables_index['cache']    = '**';
        $this->_sql_tables_ignore['cache']   = "**";
        
        $this->_sql_tables_schema['config']  = array(
            'actual_version'             => "varchar(255) DEFAULT ''",
            'admin_password_hash'        => "varchar(255) DEFAULT ''",
            'attributes_to_encrypt'      => "varchar(255) DEFAULT ''",
            // Backend storage type (files / mysql)
            'backend_type'               => "varchar(255) DEFAULT 'files'",
            // By default, backend_type is not validated
            'backend_type_validated'     => "int(10) DEFAULT 0",
            'auto_resync'                => "int(1) DEFAULT 1",
            'cache_data'                 => "int(1) DEFAULT 0",
            'cache_ldap_hash'            => "int(1) DEFAULT 1",
            'case_sensitive_users'       => "int(1) DEFAULT 0",
            'clear_otp_attribute'        => "varchar(255) DEFAULT ''",
            // No console authentication by default
            'console_authentication'     => "int(10) DEFAULT 0",
            // Debug mode (to enable it permanently)
            'debug'                      => "int(10) DEFAULT 0",
            'default_user_group'         => "varchar(255) DEFAULT ''",
            'default_request_ldap_pwd'   => "int(10) DEFAULT 1",
            'default_request_prefix_pin' => "int(10) DEFAULT 1",
            'demo_mode'                  => "int(10) DEFAULT 0",
            // Display log mode (to enable it permanently)
            'display_log'                => "int(10) DEFAULT 0",
            'domain_name'                => "varchar(255) DEFAULT ''",
            'email_admin_address'        => "varchar(255) DEFAULT ''",
            'encryption_key_full_path'   => "varchar(255) DEFAULT ''",
            // Locking delay in seconds between two trials after "max_delayed_failures" failures
            'failure_delayed_time'       => "int(10) DEFAULT 300",
            'group_attribute'            => "varchar(255) DEFAULT 'Filter-Id'",
            'hash_salt_full_path'        => "varchar(255) DEFAULT ''",
            'issuer'                     => "varchar(255) DEFAULT 'multiOTP'",
            'last_update'                => "int(10) DEFAULT 0",
            'ldap_account_suffix'        => "varchar(255) DEFAULT ''",
            'ldap_activated'             => "int(1) DEFAULT 0",
            'ldap_base_dn'               => "varchar(255) DEFAULT ''",
            'ldap_bind_dn'               => "varchar(255) DEFAULT ''",
            'ldap_cn_identifier'         => "varchar(255) DEFAULT 'sAMAccountName'",
            'ldap_domain_controllers'    => "varchar(255) DEFAULT ''",
            'ldap_group_attribute'       => "varchar(255) DEFAULT 'memberOf'",
            'ldap_group_cn_identifier'   => "varchar(255) DEFAULT 'sAMAccountName'",
            // Hash cache time: 7 * 24 * 60 * 60 = 604800 = 1 week
            'ldap_hash_cache_time'       => "int(10) DEFAULT 604800",
            'ldap_in_group'              => "varchar(255) DEFAULT ''",
            'ldap_network_timeout'       => "int(10) DEFAULT 10",
            'ldap_port'                  => "varchar(255) DEFAULT '389'",
            'ldap_server_password'       => "varchar(255) DEFAULT ''",
            // Default type 1 is Active Directory, 2 for Generic LDAP
            'ldap_server_type'           => "int(10) DEFAULT 1",
            'ldap_ssl'                   => "int(1) DEFAULT 0",
            'ldap_time_limit'            => "int(10) DEFAULT 30",
            'log'                        => "int(10) DEFAULT 0",
            'max_block_failures'         => "int(10) DEFAULT 6",
            'max_delayed_failures'       => "int(10) DEFAULT 3",
            'max_event_resync_window'    => "int(10) DEFAULT 10000",
            'max_event_window'           => "int(10) DEFAULT 100",
            'max_time_resync_window'     => "int(10) DEFAULT 90000",
            // Maximum time window to be accepted, in seconds (+/-)
            // Initialized to a little bit more than +/- 10 minutes
            // (was 8000 seconds in version 3.x, and Stefan Kügler suggested to put a lower default value)
            'max_time_window'            => "int(10) DEFAULT 600",
            'ntp_server'                 => "varchar(255) DEFAULT 'pool.ntp.org'",
            'radius_reply_attributor'    => "varchar(255) DEFAULT ' = '",
            'radius_reply_separator_hex' => "varchar(255) DEFAULT '".bin2hex(',')."'",
            'scratch_passwords_digits'   => "int(10) DEFAULT 6",
            'scratch_passwords_amount'   => "int(10) DEFAULT 10",
            'self_registration'          => "int(1) DEFAULT 1",
            // Client-server configuration
            'server_cache_level'         => "int(10) DEFAULT 1",
            // 1552000 = 6 monthes
            'server_cache_lifetime'      => "int(10) DEFAULT 15552000",
            'server_secret'              => "varchar(255) DEFAULT 'ClientServerSecret'",
            'server_timeout'             => "int(10) DEFAULT 5",
            'server_type'                => "varchar(255) DEFAULT 'xml'",
            'server_url'                 => "varchar(255) DEFAULT ''",
            'sms_api_id'                 => "varchar(255) DEFAULT ''",
            'sms_message_prefix'         => "varchar(255) DEFAULT '%s is your SMS-Code'",
            'sms_originator'             => "varchar(255) DEFAULT 'multiOTP'",
            'sms_password'               => "varchar(255) DEFAULT ''",
            'sms_provider'               => "varchar(255) DEFAULT ''",
            'sms_userkey'                => "varchar(255) DEFAULT ''",
            'sms_digits'                 => "int(10) DEFAULT 6",
            // SMS timeout before authenticating (in seconds)
            'sms_timeout'                => "int(10) DEFAULT 180",
            'smtp_auth'                  => "int(10) DEFAULT 0",
            'smtp_password'              => "varchar(255) DEFAULT ''",
            'smtp_port'                  => "int(10) DEFAULT 25",
            'smtp_sender'                => "varchar(255) DEFAULT ''",
            'smtp_sender_name'           => "varchar(255) DEFAULT ''",
            'smtp_server'                => "varchar(255) DEFAULT ''",
            'smtp_ssl'                   => "int(10) DEFAULT 0",
            'smtp_username'              => "varchar(255) DEFAULT ''",
            'sql_server'                 => "varchar(255) DEFAULT ''",
            'sql_username'               => "varchar(255) DEFAULT ''",
            'sql_password'               => "varchar(255) DEFAULT ''",
            'sql_database'               => "varchar(255) DEFAULT ''",
            // Default SQL table names. If empty, the related data will be written to a file.
            'sql_config_table'           => "varchar(255) DEFAULT 'multiotp_config'",
            'sql_cache_table'            => "varchar(255) DEFAULT 'multiotp_cache'",
            'sql_devices_table'          => "varchar(255) DEFAULT 'multiotp_devices'",
            'sql_groups_table'           => "varchar(255) DEFAULT 'multiotp_groups'",
            'sql_log_table'              => "varchar(255) DEFAULT 'multiotp_log'",
            'sql_tokens_table'           => "varchar(255) DEFAULT 'multiotp_tokens'",
            'sql_users_table'            => "varchar(255) DEFAULT 'multiotp_users'",
            'syslog_facility'            => "int(10) DEFAULT 7",
            'syslog_level'               => "int(10) DEFAULT 5",
            'syslog_port'                => "int(10) DEFAULT 514",
            'syslog_server'              => "varchar(255) DEFAULT ''",
            'tel_default_country_code'   => "varchar(255) DEFAULT ''",
            'timezone'                   => "varchar(255) DEFAULT 'Europe/Zurich'",
            'token_serial_number_length' => "varchar(255) DEFAULT '12'",
            'token_otp_list_of_length'   => "varchar(255) DEFAULT '6'",
            'verbose_log_prefix'         => "varchar(255) DEFAULT ''",
            'encryption_hash'            => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['config']   = '**';
        $this->_sql_tables_ignore['config']  = '*backend_type*backend_type_validated*sql_server*sql_username*sql_password*sql_database*sql_config_table*';

        
        $this->_sql_tables_schema['devices'] = array(
            'device_id'                  => "varchar(255) DEFAULT ''",
            'challenge_response_enabled' => "int(1) DEFAULT 0",
            'description'                => "varchar(255) DEFAULT ''",
            'device_group'               => "varchar(255) DEFAULT ''",
            'device_secret'              => "varchar(255) DEFAULT ''",
            'ip_or_fqdn'                 => "varchar(255) DEFAULT ''",
            'last_update'                => "int(10) DEFAULT 0",
            'shortname'                  => "varchar(255) DEFAULT ''",
            'sms_challenge_enabled'      => "int(1) DEFAULT 0",
            'subnet'                     => "varchar(255) DEFAULT ''",
            'text_sms_challenge'         => "varchar(255) DEFAULT 'Please enter the code received on your mobile phone'",
            'text_token_challenge'       => "varchar(255) DEFAULT 'Please enter the code displayed on the token'",
            'encryption_hash'            => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['devices']  = '*device_id*ip_or_fqdn*shortname*';
        $this->_sql_tables_ignore['devices'] = "**";

        $this->_sql_tables_schema['groups']  = array(
            'group_id'                => "varchar(255) DEFAULT ''",
            'description'             => "varchar(255) DEFAULT ''",
            'name'                    => "varchar(255) DEFAULT ''",
            'last_update'             => "int(10) DEFAULT 0",
            'encryption_hash'         => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['groups']   = '*group_id*name*';
        $this->_sql_tables_ignore['groups'] = "**";

        $this->_sql_tables_schema['log']     = array(
            'category'                => "varchar(100) DEFAULT ''",
            'datetime'                => "datetime DEFAULT NULL",
            'destination'             => "varchar(100) DEFAULT ''",
            'last_update'             => "int(10) DEFAULT 0",
            'logentry'                => "text",
            'note'                    => "varchar(255) DEFAULT ''",
            'severity'                => "varchar(100) DEFAULT ''",
            'source'                  => "varchar(100) DEFAULT ''",
            'user'                    => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['log']      = '*datetime*';
        $this->_sql_tables_ignore['log']     = "**";

        $this->_sql_tables_schema['tokens']  = array(
            'algorithm'               => "varchar(255) DEFAULT ''",
            'attributed_users'        => "varchar(255) DEFAULT ''",
            'delta_time'              => "int(10) DEFAULT 0",
            'description'             => "varchar(255) DEFAULT ''",
            'error_counter'           => "int(10) DEFAULT 0",
            'format'                  => "varchar(255) DEFAULT ''",
            'issuer'                  => "varchar(255) DEFAULT ''",
            'key_algorithm'           => "varchar(255) DEFAULT ''",
            'last_error'              => "int(10) DEFAULT 0",
            'last_event'              => "int(10) DEFAULT -1",
            'last_login'              => "int(10) DEFAULT 0",
            'last_update'             => "int(10) DEFAULT 0",
            'locked'                  => "int(1) DEFAULT 0",
            'manufacturer'            => "varchar(255) DEFAULT 'multiOTP'",
            'number_of_digits'        => "int(10) DEFAULT 6",
            'otp'                     => "varchar(255) DEFAULT ''",
            'time_interval'           => "int(10) DEFAULT 0",
            'token_algo_suite'        => "varchar(255) DEFAULT ''",
            'token_id'                => "varchar(255) DEFAULT ''",
            // Token seed, default set to the RFC test seed, hexadecimal coded
            'token_seed'              => "varchar(255) DEFAULT '3132333435363738393031323334353637383930'",
            'token_serial'            => "varchar(255) DEFAULT ''",
            'encryption_hash'         => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['tokens']   = '*attributed_users*token_id*token_serial*';
        $this->_sql_tables_ignore['tokens']  = "**";

        $this->_sql_tables_schema['users']   = array(
            'algorithm'               => "varchar(255) DEFAULT ''",
            // Autolock time (for cached data)
            'autolock_time'           => "int(10) DEFAULT 0",
            // Challenge initialization
            'challenge'               => "varchar(255) DEFAULT ''",
            'challenge_validity'      => "int(10) DEFAULT 0",
            // Delta time in seconds for a time based token
            'delta_time'              => "int(10) DEFAULT 0",
            // Desactivated user info
            'desactivated'            => "int(1) DEFAULT 0",
            'description'             => "varchar(255) DEFAULT ''",
            'email'                   => "varchar(255) DEFAULT ''",
            // Login error counter
            'error_counter'           => "int(10) DEFAULT 0",
            'group'                   => "varchar(255) DEFAULT ''",
            'key_id'                  => "varchar(255) DEFAULT ''",
            // Last error login
            'last_error'              => "int(10) DEFAULT 0",
            // Last successful event
            'last_event'              => "int(10) DEFAULT -1",
            // Last successful login
            'last_login'              => "int(10) DEFAULT 0",
            'last_update'             => "int(10) DEFAULT 0",
            // LDAP password hash caching mechanism
            'ldap_hash_cache'         => "varchar(255) DEFAULT ''",
            'ldap_hash_validity'      => "int(10) DEFAULT 0",
            // Token locked
            'locked'                  => "int(1) DEFAULT 0",
            // User is a special multi-account user (the real user is in the token, like this: "user[space]token"
            'multi_account'           => "int(10) DEFAULT 0",
            // Number of digits returned by the token
            'number_of_digits'        => "int(10) DEFAULT 6",
            // Request the LDAP password as a prefix of the returned token value
            'request_ldap_pwd'        => "int(10) DEFAULT 0",
            'request_prefix_pin'      => "int(10) DEFAULT 0",
            'scratch_passwords'       => "text",
            'seed_password'           => "varchar(255) DEFAULT ''",
            'sms'                     => "varchar(255) DEFAULT ''",
            'sms_otp'                 => "varchar(255) DEFAULT ''",
            // User sms otp validity
            'sms_validity'            => "int(10) DEFAULT 0",
            // Synchronized user info
            'synchronized'            => "int(1) DEFAULT 0",
            'synchronized_channel'    => "varchar(255) DEFAULT ''",
            'synchronized_dn'         => "varchar(255) DEFAULT ''",
            'synchronized_server'     => "varchar(255) DEFAULT ''",
            'synchronized_time'       => "int(10) DEFAULT 0",
            // Time interval in seconds for a time based token
            'time_interval'           => "int(10) DEFAULT 0",
            'token_algo_suite'        => "varchar(255) DEFAULT ''",
            // Token seed, default set to the RFC test seed, hexadecimal coded
            'token_seed'              => "varchar(255) DEFAULT '3132333435363738393031323334353637383930'",
            'token_serial'            => "varchar(255) DEFAULT ''",
            'user'                    => "varchar(255) DEFAULT ''",
            'user_pin'                => "varchar(255) DEFAULT ''",
            'encryption_hash'         => "varchar(255) DEFAULT ''");
        $this->_sql_tables_index['users']    = '*desactivated*locked*user*';
        $this->_sql_tables_ignore['users']   = "**";

        if ("" == $encryption_key)
        {
            $this->_encryption_key = 'MuLtIoTpEnCrYpTiOn'; // This default value should be changed for each project using SetEncryptionKey()
        }
        else
        {
            $this->_encryption_key = $encryption_key;
        }

        $current_dir = $base_dir;
        if ("" == $current_dir)
        {
            $env_folder_path = getenv('MULTIOTP_PATH');
            if (FALSE !== $env_folder_path)
            {
                $current_dir = $env_folder_path;
            }
        }
        $this->SetBaseDir($current_dir);

        if ("" != trim($config_dir))
        {
            $this->SetConfigFolder($config_dir, TRUE, FALSE);
        }
        
        $this->_parser_pointers         = array();
        
        $this->_hash_salt               = 'MySalt'; // Can be Set in your application using SetHashSalt()
        $this->_random_salt             = "Random"; // Updated regulary with SetRandomSalt

        $this->_source_tag              = "";

        $this->_source_ip               = "";
        $this->_source_mac              = "";
        
        $this->_calling_ip              = "";
        $this->_calling_mac             = "";

        $this->_chap_challenge          = "";
        $this->_chap_id                 = "";
        $this->_chap_password           = "";
        
        $this->_ms_nt_key               = "";
        
        $this->_encryption_check        = TRUE; // Check if the encryption hash is valid, default is TRUE

        $this->_user                    = ""; // Name of the current user to authenticate
        $this->_user_data_read_flag     = FALSE; // Flag to know if the data concerning the current user has been read
        $this->_users_folder            = ""; // Folders which contain the users flat files

        $this->_last_ldap_error         = FALSE;
        $this->_log_file_name           = 'multiotp.log';
        $this->_log_flag                = FALSE;
        $this->_log_folder              = ""; // Folder which contains the log file
        $this->_log_verbose_flag        = FALSE;
        $this->_log_display_flag        = FALSE;
        
        $this->_mysql_database_link     = NULL;
        $this->_mysqli                  = NULL;
        
        $this->_migration_from_file     = FALSE; // To allow an automatic migration of users profiles,
                                                 // enable a database backend and set the migration option ;-) !

        $this->_reply_array_for_radius = array();
        
        $this->_servers_temp_bad_list  = array();

        $this->_initialize_backend = $initialize_backend;
        
        $this->_debug_via_html = FALSE;
        
        $this->_linux_file_mode = "";


        $this->ReadConfigData(true); // Read the configuration data, for the encryption information only
        if (("" == $encryption_key) || ('MuLtIoTpEnCrYpTiOn' == $encryption_key) || ('DefaultCliEncryptionKey' == $encryption_key))
        {
            if (("" != $this->GetEncryptionKeyFullPath()) && file_exists($this->GetEncryptionKeyFullPath()))
            {
                if ($encryption_key_file_handler = fopen($this->GetEncryptionKeyFullPath(), "rt"))
                {
                    $temp_encryption_key = trim(fgets($encryption_key_file_handler));
                    if ("" != $temp_encryption_key)
                    {
                        $this->SetEncryptionKey($temp_encryption_key, FALSE);
                    }
                    fclose($encryption_key_file_handler);
                }
            }
        }

        $this->_server_challenge = $this->GetEncryptionKey();

        $this->_keep_local = FALSE;
        
        $this->_xml_dump_in_log = FALSE; // For debugging purpose only
        
        $this->_sms_providers_array = array(array("aspsms", "aspsms", "http://www.aspsms.com/"),
                                            array("clickatell", "Clickatell", "http://www.clickatell.com/"),
                                            array("intellisms", "IntelliSMS", "http://www.intellisms.co.uk/")
                                           );

        // As various accounts are using the same files
        $this->SetLinuxFileMode('0666');
        
        // Reset/initialize the errors text array, should be the first reset method to call
        $this->ResetErrorsArray();

        // Reset/initialize the config array, should be the second reset method to call
        $this->ResetConfigArray();
        
        // Reset/initialize the device array
        $this->ResetDeviceArray();

        // Reset/initialize the group array
        $this->ResetGroupArray();

        // Reset/initialize the user array
        $this->ResetUserArray();
        
        // Reset/initialize the token array
        $this->ResetTokenArray();

        // In case of initialization, we will disable the backend validation
        $this->ReadConfigData();
 
        // Reset/initialize the cache array
        $this->ResetCacheArray();
        if ($this->IsCacheData())
        {
            $this->ReadCacheData();
        }
    }

    // Class destructor, also called in PHP4
    function __destruct()
    {
        /*
        if ($this->IsCacheData())
        {
            $this->WriteCacheData();
        }
        */
    }


    // Customized information (to be overcharged if needed)
    function GetCustomInfo()
    {
        return "";
    }


    function GetLibraryHash($param1 = "", $param2 = "")
    {
        if (file_exists(__FILE__))
        {
            $me_handler = fopen(__FILE__, "rt");
            $content = "";
            while (!feof($me_handler))
            {
                $content.= fgets($me_handler);
            }
            fclose($me_handler);
            $hash = md5($content);
        }
        else
        {
            $hash = '00000000000000000000000000000000';
        }
        return ($hash);
    }

    function UpgradeSchemaIfNeeded()
    {
        if ($this->GetActualVersion() != $this->GetVersion())
        {
            if ($this->InitializeBackend() < 20)
            {
                $this->SetActualVersion($this->GetVersion());
                $this->WriteConfigData();
            }
        }
    }


    // Reset the errors array
    function ResetErrorsArray()
    {
        $this->_errors_text[0] = "OK: Token accepted";

        $this->_errors_text[10] = "INFO: Access Challenge returned back to the client";

        $this->_errors_text[11] = "INFO: User successfully created or updated";
        $this->_errors_text[12] = "INFO: User successfully deleted";
        $this->_errors_text[13] = "INFO: User PIN code successfully changed";
        $this->_errors_text[14] = "INFO: Token has been resynchronized successfully";
        $this->_errors_text[15] = "INFO: Tokens definition file successfully imported";
        $this->_errors_text[16] = "INFO: QRcode successfully created";
        $this->_errors_text[17] = "INFO: UrlLink successfully created";
        $this->_errors_text[18] = "INFO: SMS code request received";
        $this->_errors_text[19] = "INFO: Requested operation successfully done";

        $this->_errors_text[21] = "ERROR: User doesn't exist";
        $this->_errors_text[22] = "ERROR: User already exists";
        $this->_errors_text[23] = "ERROR: Invalid algorithm";
        $this->_errors_text[24] = "ERROR: User locked (too many tries)";
        $this->_errors_text[25] = "ERROR: User delayed (too many tries, but still a hope in a few minutes)";
        $this->_errors_text[26] = "ERROR: The token has already been used";
        $this->_errors_text[27] = "ERROR: Resynchronization of the token has failed";
        $this->_errors_text[28] = "ERROR: Unable to write the changes in the file";
        $this->_errors_text[29] = "ERROR: Token doesn't exist";

        $this->_errors_text[30] = "ERROR: At least one parameter is missing";
        $this->_errors_text[31] = "ERROR: Tokens definition file doesn't exist";
        $this->_errors_text[32] = "ERROR: Tokens definition file not successfully imported";
        $this->_errors_text[33] = "ERROR: Encryption hash error, encryption key is not matching";
        $this->_errors_text[34] = "ERROR: Linked user doesn't exist";
        $this->_errors_text[35] = "ERROR: User not created";
        $this->_errors_text[37] = "ERROR: Token already attributed";
        $this->_errors_text[38] = "ERROR: User is desactivated";
        $this->_errors_text[39] = "ERROR: Requested operation aborted";
       
        $this->_errors_text[41] = "ERROR: SQL error";
        
        $this->_errors_text[50] = "ERROR: QRcode not created";
        $this->_errors_text[51] = "ERROR: UrlLink not created (no provisionable client for this protocol)";

        $this->_errors_text[60] = "ERROR: No information on where to send SMS code";
        $this->_errors_text[61] = "ERROR: SMS code request received, but an error occurred during transmission";
        $this->_errors_text[62] = "ERROR: SMS provider not supported";
        
        $this->_errors_text[70] = "ERROR: Server authentication error";
        $this->_errors_text[71] = "ERROR: Server request is not correctly formatted";
        $this->_errors_text[72] = "ERROR: Server answer is not correctly formatted";
        
        $this->_errors_text[80] = "ERROR: Server cache error";
        $this->_errors_text[81] = "ERROR: Cache too old for this user, account autolocked";

        $this->_errors_text[98] = "ERROR: Authentication failed (wrong token length)";
        $this->_errors_text[99] = "ERROR: Authentication failed (and other possible unknown errors)";
    }


    function GetErrorText($error_number = 99)
    {
        $text = "";
        if (isset($this->_errors_text[$error_number]))
        {
            $text = $this->_errors_text[$error_number];
        }
        elseif (intval($error_number) > 0)
        {
            $text = $this->_errors_text[99];
        }
        return $text;
    }


    // Reset the cache array
    function ResetCacheArray()
    {
        // First, we reset all values (we know the key based on the schema)
        reset($this->_sql_tables_schema['cache']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['cache'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $this->_cache_data[$valid_key] = $value;
        }
    }

    
    function WriteData(
        $item,
        $table,
        $folder,
        $data_array,
        $force_file = false,
        $id_field = '',
        $id_value = '',
        $id_case_sensitive = false,
        $automatically = false,
        $update_last_change = true
    ) {
    /**
     * @brief   Write specific data in the backend (SQL table or file), generic method
     *
     * @param   string  $item                Item family to be handled (Cache, Configuration, Token, etc.)
     * @param   string  $table               Name of the table if the backend is handling tables
     * @param   string  $folder              Name of the folder if the backend is handling folders
     * @param   string  $data_array          Data array of the item to be written
     * @param   string  $force_file          File backend must also always be used
     * @param   string  $id_field            Index field of the item if the backend is handlinh tables
     * @param   string  $id_value            Value of the indexed item
     * @param   string  $id_case_sensitive   We want to be case sensitive for the backend storage
     * @param   string  $automatically       The process is done automatically (for long content only)
     * @param   string  $update_last_change  Update the last_update field (true by default)
     * @retval  boolean                      Result of the operation
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @date    2015-01-23
     * @since   2014-12-30
     */
        if ('configuration' == strtolower($item)) {
            $filename = 'multiotp.ini';
            $force_file = true;
        } elseif ('cache' == strtolower($item)) {
            $filename = 'cache.ini';
        } else {
            $filename = $id_value.'.db';
        }

        $now_epoch = time();
        if ($update_last_change) {
            $data_array['last_update'] = $now_epoch;
        }
        $result = false;

        $esc_id_value = escape_mysql_string($id_value);
        $item_created = FALSE;
        
        $data_array['encryption_hash'] = $this->CalculateControlHash($this->GetEncryptionKey());
        
        if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_'.$table.'_table'])) || ('files' == $this->GetBackendType()) || $force_file) {
            if (('files' == $this->GetBackendType()) || $force_file) {
                $file_time = $now_epoch;
                if (!$id_case_sensitive) {
                    $filename = strtolower($filename);
                }
                $file_created = FALSE;
                if (!file_exists($folder.$filename)) {
                    $item_created = TRUE;
                    $file_created = TRUE;
                } elseif ((!$update_last_change) && (!$file_created)) {
                    $file_time = filemtime($folder.$filename);
                }
                if (!($file_handler = fopen($folder.$filename, "wt"))) {
                    $this->WriteLog("Error: database file for ".trim($item." ".$id_value)." cannot be written", FALSE, FALSE, 28, 'System', '');
                }
                else {
                    fwrite($file_handler,"multiotp-database-format-v3"."\n");
                    
                    if ('configuration' == strtolower($item)) {
                        fwrite($file_handler,"; If backend is set to something different than files,\n");
                        fwrite($file_handler,"; and backend_type_validated is set to 1,\n");
                        fwrite($file_handler,"; only the specific information needed for the backend\n");
                        fwrite($file_handler,"; is used from this config file.\n");
                        fwrite($file_handler,"\n");
                    }
                    
                    // foreach (array() as $key => $value) // this is not working well in PHP4
                    reset($data_array);
                    while(list($key, $value) = each($data_array)) {
                        if ('' != trim($key)) {
                            $line = strtolower($key);
                            if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$key.'*'))) {
                                $value = $this->Encrypt($key,$value,$this->GetEncryptionKey());
                                $line = $line.":";
                            }
                            $line = $line."=".$value;
                            fwrite($file_handler,$line."\n");
                        }
                    }
                    $result = TRUE;
                    fclose($file_handler);
                    if ((!$update_last_change) && (!$file_created)) {
                        touch($folder.$filename, $file_time);
                    }
                    if ($file_created && ('' != $this->GetLinuxFileMode())) {
                        chmod($folder.$filename, octdec($this->GetLinuxFileMode()));
                    }
                }
                if ($this->GetVerboseFlag()) {
                    if ($file_created) {
                        $this->WriteLog("Info: *File created: ".$folder.$filename, FALSE, FALSE, 19, 'System', "");
                    }
                }                    
            }
            if ('mysql' == $this->GetBackendType()) {
                if ($this->OpenMysqlDatabase()) {
                    $result = TRUE;
                    $sQi_Columns = '';
                    $sQi_Values  = '';
                    $sQu_Data    = '';
                    reset($data_array);
                    while(list($key, $value) = each($data_array)) {
                        $in_the_schema = FALSE;
                        reset($this->_sql_tables_schema[$table]);
                        while(list($valid_key, $valid_format) = each($this->_sql_tables_schema[$table])) {
                            if ($valid_key == $key) {
                                $in_the_schema = TRUE;
                            }
                        }
                        if (($in_the_schema) && ($key != $id_field)) {
                            if ((FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$key.'*'))) && ('' != $value)) {
                                $value = 'ENC:'.$this->Encrypt($key,$value,$this->GetEncryptionKey()).':ENC';
                            }
                            $value = escape_mysql_string($value);
                            $sQu_Data    .= "`{$key}`='{$value}',"; // Data for UPDATE query
                            $sQi_Columns .= "`{$key}`,"; // Columns for INSERT query
                            $sQi_Values  .= "'{$value}',"; // Values for INSERT query
                        } elseif ((!$in_the_schema) && ('unique_id' != $key)  && $this->GetVerboseFlag()) {
                            $this->WriteLog("Warning: *The key ".$key." is not in the $table database schema", FALSE, FALSE, 98, 'System', '');
                        }
                    }
                    $num_rows = 0;
                    $sQuery = "SELECT * FROM `".$this->_config_data['sql_'.$table.'_table']."`";
                    if ('' != $id_field) {
                        $sQuery.= " WHERE `$id_field`='".$esc_id_value."'";
                    }
                    
                    if (is_object($this->_mysqli)) {
                        if (!($result = $this->_mysqli->query($sQuery))) {
                            $this->WriteLog("Error: SQL database query error ".trim($this->_mysqli->error)." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                        } else {
                            $num_rows = $result->num_rows;                                    
                        }
                    } elseif (!($result = mysql_query($sQuery, $this->_mysql_database_link))) {
                        $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                    } else {
                        $num_rows = mysql_num_rows($result);
                    }

                    if ($num_rows > 0) {
                        $sQuery = "UPDATE `".$this->_config_data['sql_'.$table.'_table']."` SET ".substr($sQu_Data,0,-1);
                        if ('' != $id_field) {
                            $sQuery.= " WHERE `$id_field`='".$esc_id_value."'";
                        }
                        if (is_object($this->_mysqli)) {
                            if (!($rResult = $this->_mysqli->query($sQuery))) {
                                $this->WriteLog("Error: SQL database query error ".trim($this->_mysqli->error)." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                                $result = FALSE;
                            }
                        } elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                            $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                            $result = FALSE;
                        }
                    } else {
                        if ('' != $id_field) {
                            $sQuery = "INSERT INTO `".$this->_config_data['sql_'.$table.'_table']."` (`$id_field`,".substr($sQi_Columns,0,-1).") VALUES ('".$esc_id_value."',".substr($sQi_Values,0,-1).")";
                        } else {
                            $sQuery = "INSERT INTO `".$this->_config_data['sql_'.$table.'_table']."` (".substr($sQi_Columns,0,-1).") VALUES (".substr($sQi_Values,0,-1).")";
                        }
                        if (is_object($this->_mysqli)) {
                            if (!($rResult = $this->_mysqli->query($sQuery))) {
                                $this->WriteLog("Error: SQL database query error ".trim($this->_mysqli->error)." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                            } elseif (0 == $this->_mysqli->affected_rows) {
                                $this->WriteLog("Error: SQL database entry for ".trim($item." ".$id_value)." cannot be created or changed", FALSE, FALSE, 28, 'System', '');
                                $result = FALSE;
                            } else {
                                $item_created = TRUE;
                            }
                        } elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                            $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                            $result = FALSE;
                            break;
                        } elseif (0 == mysql_affected_rows($this->_mysql_database_link)) {
                            $this->WriteLog("Error: SQL database entry for ".trim($item." ".$id_value)." cannot be created or changed", FALSE, FALSE, 28, 'System', '');
                            $result = FALSE;
                        } else {
                            $item_created = TRUE;
                        }
                    }
                }
            }
        }
        if ($item_created && $result) {
            if ($automatically) {
                $this->WriteLog("Info: ".trim($item." ".$id_value)." automatically created", FALSE, FALSE, 19, 'System', '');
            }
            else {
                $this->WriteLog("Info: ".trim($item." ".$id_value)." manually created", FALSE, FALSE, 19, 'System', '');
            }
        }
        return $result;
    }


    function ReadCacheValue($key)
    {
        return ((isset($this->_cache_data[$key]))?$this->_cache_data[$key]:"");
    }


    function WriteCacheValue($key, $value)
    {
        $this->_cache_data[$key] = $value;
    }


    function ReadCacheData() {
        $this->ResetCacheArray();
        $result = false;
        
        // First, we read the cache file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile())) {
            $cache_filename = 'cache.ini'; // File exists in v3 format only, we don't need any conversion
            if (file_exists($this->GetCacheFolder().$cache_filename)) {
                $file_handler = fopen($this->GetCacheFolder().$cache_filename, "rt");
                $first_line = trim(fgets($file_handler));
                
                while (!feof($file_handler)) {
                    $line = str_replace(chr(10), "", str_replace(chr(13), "", fgets($file_handler)));
                    $line_array = explode("=",$line,2);
                    if (('#' != substr($line, 0, 1)) && (';' != substr($line, 0, 1)) && ("" != trim($line)) && (isset($line_array[1]))) {
                        if ("" != $line_array[0]) {
                            $this->_cache_data[strtolower($line_array[0])] = $line_array[1];
                        }
                    }
                }
                fclose($file_handler);
                $result = TRUE;
            }
        }
        
        // And now, we override the values if another backend type is defined
        if ($this->GetBackendTypeValidated()) {
            switch ($this->GetBackendType()) {
                case 'mysql':
                    if ($this->OpenMysqlDatabase()) {
                        if ("" != $this->_config_data['sql_cache_table']) {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_cache_table']."` ";
                            
                            $aRow = NULL;

                            if (is_object($this->_mysqli)) {
                                if (!($result = $this->_mysqli->query($sQuery))) {
                                    $this->WriteLog("Error: ".trim($this->_mysqli->error)." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                                    $result = FALSE;
                                } else {
                                    $aRow = $result->fetch_assoc();
                                }
                            } else {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                                    $this->WriteLog("Error: ".mysql_error()." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                                    $result = FALSE;
                                } else {
                                    $aRow = mysql_fetch_assoc($rResult);
                                }
                            }

                            if (NULL != $aRow) {
                                $result = TRUE;
                                while(list($key, $value) = @each($aRow)) {
                                    $in_the_schema = FALSE;
                                    reset($this->_sql_tables_schema['cache']);
                                    while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['cache'])) {
                                        if ($valid_key == $key) {
                                            $in_the_schema = TRUE;
                                        }
                                    }
                                    if ($in_the_schema) {
                                        $this->_cache_data[$key] = $value;
                                    } elseif (('unique_id' != $key) && $this->GetVerboseFlag()) {
                                        $this->WriteLog("Warning: *the key ".$key." is not in the cache database schema", FALSE, FALSE, 98, 'System', "");
                                    }
                                }
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }
        }
        
        // If cache is too old (more than one day), we reset the cache and we save it
        if (((24*60*60) + intval($this->_cache_data['last_update'])) < time()) {
            $this->ResetCacheArray();
            $this->WriteCacheData();
        }
        return $result;
    }


    function WriteCacheData()
    {
        $result = $this->WriteData('Cache',
                                   'cache',
                                   $this->GetCacheFolder(),
                                   $this->_cache_data
                                  );
        return $result;
    }


    // Reset the config array
    function ResetConfigArray() {
        // First, we reset all values (we know the key based on the schema)
        reset($this->_sql_tables_schema['config']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['config'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $this->_config_data[$valid_key] = $value;
        }
    }


    // TODO, could be nice to backup the configuration in a file somewhere
    function BackupConfiguration(
        $param1 = "",
        $param2 = "",
        $param3 = "",
        $param4 = ""
    ) {
        return TRUE;
    }


    function SetConsoleAuthentication($value)
    {
        $this->_config_data['console_authentication'] = ((intval($value) > 0)?1:0);
    }


    function EnableConsoleAuthentication()
    {
        $this->_config_data['console_authentication'] = 1;
    }


    function DisableConsoleAuthentication()
    {
        $this->_config_data['console_authentication'] = 0;
    }


    function IsConsoleAuthentication()
    {
        return (1 == ($this->_config_data['console_authentication']));
    }


    function SetLogFileName(
        $filename
    ) {
        $this->_log_file_name = trim($filename);
    }


    function GetLogFileName() {
        return $this->_log_file_name;
    }

    function SetLogHeaderWritten(
        $log_header_written
    ) {
        $this->_log_header_written = $log_header_written;
    }


    function GetLogHeaderWritten() {
        return $this->_log_header_written;
    }


    function SetLogFolder(
        $folder
    ) {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/") {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_log_folder = $new_folder;
        if (!file_exists($new_folder)) {
            @mkdir($new_folder);
        }
    }


    function GetLogFolder() {
        if ("" == $this->_log_folder) {
            $this->SetLogFolder($this->GetScriptFolder()."log/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_log_folder);
    }


    function WriteLog(
        $info,
        $file_only = false,
        $hide_on_display = false,
        $error_code = 9999,
        $category = '*DEFAULT*',
        $user = '*DEFAULT*',
        $overwrite_severity = -1
    ) {
    /**
     * @brief   Write information in the log file/database, to the syslog server and on the screen
     *
     * @param   string  $info                Information to log
     * @param   boolean $file_only           Define that the information must not be written in the database
     *                                        (in case of database error for example)
     * @param   boolean $hide_on_display     Define that the information must never be displayed
     * @param   int     $error_code          Error code (to define a matching severity, which can be overwritten if needed)
     * @param   string  $category            Define the category, will be "Authentication" if not defined
     * @param   string  $user                Define the user concerned, the default value will take $this->GetUser()
     * @param   int     $overwrite_severity  Define the severity (0-7), -1 will take the default severity, based on error number
     * @retval  void
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.1.0
     * @date    2014-01-03
     * @since   2010-12-19
     *
     *   Severity values:
     *     0 Emergency: system is unusable
     *     1 Alert: action must be taken immediately
     *     2 Critical: critical conditions
     *     3 Error: error conditions
     *     4 Warning: warning conditions
     *     5 Notice: normal but significant condition (default value)
     *     6 Informational: informational messages
     *     7 Debug: debug-level messages
     */

        if ('*DEFAULT*' != $user) {
            $user_log = $user;
        } else {
            $user_log = $this->GetUser();
        }
        
        if ('*DEFAULT*' != $category) {
            $category_log = $category;
        } else {
            $category_log = "Authentication"; // $this->_class;
        }

        if (0 == $error_code) {
            $severity = 5;
        } elseif (8888 <= $error_code) {
            $severity = 7;
        } elseif (20 > $error_code) {
            $severity = 6;
        } elseif (100 > $error_code) {
            $severity = 4;
        } elseif (200 > $error_code) {
            $severity = 3;
        } elseif (300 > $error_code) {
            $severity = 2;
        } elseif (400 > $error_code) {
            $severity = 1;
        } elseif (500 > $error_code) {
            $severity = 0;
        } else {
            $severity = 3;
        }
        
        if ((intval($overwrite_severity) >= 0) && (intval($overwrite_severity) <= 7)) {
            $severity = intval($overwrite_severity);
        }
        
        switch ($severity) {
            case 0:
                $severity_txt = 'emergency';
                break;
            case 1:
                $severity_txt = 'alert';
                break;
            case 2:
                $severity_txt = 'critical';
                break;
            case 3:
                $severity_txt = 'error';
                break;
            case 4:
                $severity_txt = 'warning';
                break;
            case 5:
                $severity_txt = 'notice';
                break;
            case 6:
                $severity_txt = 'info';
                break;
            case 7:
                $severity_txt = 'debug';
                break;
            default:
                $severity_txt = 'error';
        }

        $post_info = "";
        $pre_info = "";
        if ("" != ($this->GetSourceIp().$this->GetSourceMac())) {
            $post_info.= "from ";
            if ("" != $this->GetSourceIp()) {
                $post_info.= $this->GetSourceIp().' ';
            }
            if ("" != $this->GetSourceMac()) {
                $post_info.= '['.$this->GetSourceMac().'] ';
            }
        }
        if ("" != ($this->GetCallingIp().$this->GetCallingMac())) {
            $post_info.= "for ";
            if ("" != $this->GetCallingIp()) {
                $post_info.= $this->GetCallingIp().' ';
            }
            if ("" != $this->GetCallingMac()) {
                $post_info.= '['.$this->GetCallingMac().'] ';
            }
        }
        $log_info = trim(trim($pre_info).' '.$info.' '.trim($post_info));
        
        // Cleaning the log info, just to be sure that we don't have tabs (\t)
        // in them, and also that the CRLF, CR or LF is the good done (\n)
        $log_info = str_replace(chr(13).chr(10), "<<CRLF>>", $log_info);
        $log_info = str_replace(chr(13), "<<CRLF>>", $log_info);
        $log_info = str_replace(chr(10), "<<CRLF>>", $log_info);
        $log_info = str_replace("<<CRLF>>", "\n", $log_info);
        $log_info = str_replace("\t", " ", $log_info);

        $log_datetime = date("Y-m-d H:i:s");
        
        // In the logfile, we don't want to have several lines for one entry,
        // therefore we are replacing the "\n" with "; " (or <br /> if we want to debug in HTML mode
        
        $logfile_content = $log_datetime."\t".$severity_txt."\t".$user_log."\t".$category_log."\t".str_replace("\n", $this->IsDebugViaHtml()?"<br />":"; ", $log_info);

        if (($this->GetDisplayLogFlag()) && (!$hide_on_display)) {
            $display_text = "\nLOG ".$log_datetime.' '.$severity_txt.' '.(("" == $user_log)?"":'(user '.$user_log.') ').$category_log.' '.$log_info."\n";
            if ($this->IsDebugViaHtml()) {
                $display_text = str_replace("\n","<br />\n", $display_text);
            }
            echo $display_text;
        }
        
        if ("" != trim($this->GetSysLogServer())) {
            if ($severity <= $this->GetSyslogLevel()) {
                $syslog = new MultiotpSyslog();
                $syslog->SetFacility($this->GetSyslogFacility());
                $syslog->SetSeverity($severity);
                $syslog->SetHostname($this->GetSystemName());
                $syslog->SetFqdn($this->GetSystemName().(("" != $this->GetDomainName())?'.'.$this->GetDomainName():""));
                $syslog->SetIpFrom($this->GetLocalIpAddress());
                $syslog->SetProcess('multiOTP');
                $syslog->SetContent(str_replace("\n", "; ", $log_info));
                $syslog->SetServer($this->GetSysLogServer());
                $syslog->SetPort($this->GetSysLogPort());
                $syslog->Send();
            }
        }

        $log_link = NULL;
        if ($this->IsLogEnabled()) {
            if ((!$file_only) && ('mysql' == $this->GetBackendType()) && $this->GetBackendTypeValidated() && ("" != $this->_config_data['sql_log_table'])) {
                if ('mysql' == $this->GetBackendType()) {
                    if ($this->OpenMysqlDatabase()) {
                        $log_severity_escaped = escape_mysql_string($severity_txt);
                        $log_user_escaped = escape_mysql_string($user_log);
                        $log_category_escaped = escape_mysql_string($category_log);
                        $log_info_escaped = substr(escape_mysql_string($log_info),0,255);

                        $sQuery  = "INSERT INTO `".$this->_config_data['sql_log_table']."` (`datetime`,`severity`,`user`,`category`,`logentry`) VALUES ('".$log_datetime."','".$log_severity_escaped."','".$log_user_escaped."','".$log_category_escaped."','".$log_info_escaped."')";
                        
                        if (is_object($this->_mysqli)) {
                            if (!($rResult = $this->_mysqli->query($sQuery))) {
                                $this->WriteLog("Error: SQL database query error ($sQuery) : ".trim($this->_mysqli->error), TRUE, FALSE, 199, 'System', "");
                            }
                        } elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                            $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', "");
                        }
                    }
                    //mysql_close($log_link);
                }
            } else {
                if (!file_exists($this->GetLogFolder())) {
                    @mkdir($this->GetLogFolder());
                }
                $file_created = (!file_exists($this->GetLogFolder().$this->GetLogFileName()));
                $log_file_handle = fopen($this->GetLogFolder().$this->GetLogFileName(),"ab+");
                if ($this->GetVerboseFlag()) {
                    if (!$this->GetLogHeaderWritten()) {
                        fwrite($log_file_handle,str_repeat("=",40)."\n");
                        fwrite($log_file_handle,'multiotp '.$this->GetVersion()."\n");
                        if ($this->GetVerboseFlag()) {
                            fwrite($log_file_handle,'Your script is running from '.$this->GetScriptFolder()."\n");
                        }
                    }
                    $this->SetLogHeaderWritten(TRUE);
                }
                
                fwrite($log_file_handle,$logfile_content."\n");
                fclose($log_file_handle);
                if ($file_created && ("" != $this->GetLinuxFileMode())) {
                    chmod($this->GetLogFolder().$this->GetLogFileName(), octdec($this->GetLinuxFileMode()));
                }
            }
        }
    }


    function ShowLog($as_result = FALSE) {
        $result = "";
        if ('mysql' == $this->GetBackendType()) {
            if ($this->OpenMysqlDatabase()) {
                $sQuery  = "SELECT * FROM `".$this->_config_data['sql_log_table']."`";
                
                if (is_object($this->_mysqli)) {
                    if (!($rResult = $this->_mysqli->query($sQuery))) {
                        $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', "");
                        $result = FALSE;
                    } else {
                        while ($aRow = $rResult->fetch_assoc()) {
                            if ($as_result) {
                                $result.= trim($aRow['datetime'].' '.$aRow['user']).' '.$aRow['logentry']."\n";
                            } else {
                                echo trim($aRow['datetime'].' '.$aRow['user']).' '.$aRow['logentry']."\n";
                            }
                        }                         
                    }
                } elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', "");
                    $result = FALSE;
                } else {
                    while ($aRow = mysql_fetch_assoc($rResult)) {
                        if ($as_result) {
                            $result.= trim($aRow['datetime'].' '.$aRow['user']).' '.$aRow['logentry']."\n";
                        } else {
                            echo trim($aRow['datetime'].' '.$aRow['user']).' '.$aRow['logentry']."\n";
                        }
                    }                         
                }
            }
            //mysql_close($log_link);
        } elseif (file_exists($this->GetLogFolder().$this->GetLogFileName())) {
            $log_file_handle = fopen($this->GetLogFolder().$this->GetLogFileName(),"r");
            while (!feof($log_file_handle)) {
                if ($as_result) {
                    $result.= trim(fgets($log_file_handle))."\n";
                } else {
                    echo trim(fgets($log_file_handle))."\n";
                }
            }
            fclose($log_file_handle);
        }
        return $result;
    }


    function ClearLog() {
        $result = TRUE;
        if ('mysql' == $this->GetBackendType()) {
            if ($this->OpenMysqlDatabase()) {
                $sQuery  = "TRUNCATE `".$this->_config_data['sql_log_table']."`";
                
                if (is_object($this->_mysqli)) {
                    if (!($rResult = $this->_mysqli->query($sQuery))) {
                        $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', "");
                        $result = FALSE;
                    }
                } elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link))) {
                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', "");
                    $result = FALSE;
                }
            } else {
                $result = FALSE;
            }
        }

        if (file_exists($this->GetLogFolder().$this->GetLogFileName())) {
            unlink($this->GetLogFolder().$this->GetLogFileName());
        }
        return $result;
    }


    function EnableLog() {
        $this->_log_flag = TRUE;
        if ("" == $this->_log_folder) {
            $this->SetLogFolder($this->GetScriptFolder()."log/");
        }
    }


    function IsLogEnabled() {
        return (TRUE === $this->_log_flag);
    }


    function DisableLog() {
        $this->_log_flag = FALSE;
    }


    function EnableVerboseLog() {
        $this->EnableLog();
        $this->_log_verbose_flag = TRUE;
    }


    function DisableVerboseLog() {
        $this->_log_verbose_flag = FALSE;
    }


    function GetVerboseFlag() {
        return $this->_log_verbose_flag;
    }


    function EnableDisplayLog() {
        $this->_log_display_flag = TRUE;
    }


    function DisableDisplayLog() {
        $this->_log_display_flag = FALSE;
    }


    function GetDisplayLogFlag() {
        return $this->_log_display_flag;
    }


    function SetDemoMode(
        $value
    ) {
        $this->_config_data['demo_mode'] = ((intval($value) > 0)?1:0);
    }


    function EnableDemoMode() {
        $this->_config_data['demo_mode'] = 1;
    }


    function DisableDemoMode() {
        $this->_config_data['demo_mode'] = 0;
    }


    function IsDemoMode() {
        return (1 == ($this->_config_data['demo_mode']));
    }


    function SetCacheLdapHash(
        $value
    ) {
        $this->_config_data['cache_ldap_hash'] = ((intval($value) > 0)?1:0);
    }


    function EnableCacheLdapHash() {
        $this->_config_data['cache_ldap_hash'] = 1;
    }


    function DisableCacheLdapHash() {
        $this->_config_data['cache_ldap_hash'] = 0;
    }


    function IsCacheLdapHash() {
        return (1 == ($this->_config_data['cache_ldap_hash']));
    }


    function IsLdapServerReachable() {
        return (TRUE === $this->_ldap_server_reachable);
    }


    function SetLdapServerReachable(
        $value
    ) {
        $this->_ldap_server_reachable = (TRUE === $value);
    }


    function SetEncryptionKeyFullPath(
        $full_path
    ) {
        $this->_config_data['encryption_key_full_path'] = $full_path;
    }


    function GetEncryptionKeyFullPath() {
        return trim(isset($this->_config_data['encryption_key_full_path'])?$this->_config_data['encryption_key_full_path']:"");
    }


    function SetHashSaltFullPath(
        $full_path
    ) {
        $this->_config_data['hash_salt_full_path'] = $full_path;
    }


    function GetHashSaltFullPath() {
        return trim($this->_config_data['hash_salt_full_path']);
    }


    function SetConfigFolder(
        $folder,
        $create = true,
        $read_config = true
    ) {
    /**
     * @brief   Set the configuration folder (for the config file).
     *
     * @param   string  $folder       Full path to the config folder.
     * @param   boolean $create       Create the folder if it doesn't exists.
     * @param   boolean $read_config  Read directly the configuration file.
     * @retval  void
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.0.0
     * @date    2013-05-13
     */
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/") {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_config_folder = $new_folder;
        if ($create && (!file_exists($new_folder))) {
            if (!@mkdir($new_folder)) {
                $this->WriteLog("Error: Unable to create the missing config folder ".$new_folder, true, false, 299, 'System', "");
            }
        }
        if ($read_config) {
            $this->ReadConfigData();
        }
    }


    function GetConfigFolder(
        $create_if_not_exist = false
    ) {
    /**
     * @brief   Get the configuration folder (for the config file).
     *
     * @param   boolean $create_if_not_exist Create the folder if it doesn't exists.
     * @retval  string                       Full path to the config folder.
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.0.0
     * @date    2013-05-13
     */
        $config_folder = $this->ConvertToWindowsPathIfNeeded($this->_config_folder);
        if ("" == $config_folder) {
            $this->SetConfigFolder($this->GetScriptFolder()."config/", $create_if_not_exist);
        } elseif (!file_exists($config_folder)) {
            if ($create_if_not_exist) {
                if (!@mkdir($config_folder)) {
                    $this->WriteLog("Error: Unable to create the missing config folder ".$config_folder, FALSE, FALSE, 299, 'System', "");
                }
            }
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_config_folder);
    }


    function SetCacheFolder(
        $folder,
        $create = true,
        $read_cache = true
    ) {
    /**
     * @brief   Set the cache folder (for the cache file).
     *
     * @param   string  $folder       Full path to the cache folder.
     * @param   boolean $create       Create the folder if it doesn't exists.
     * @param   boolean $read_cache   Read directly the cache file.
     * @retval  void
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.2.5.0
     * @date    2014-07-25
     */
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/") {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_cache_folder = $new_folder;
        if ($create && (!file_exists($new_folder))) {
            if (!@mkdir($new_folder)) {
                $this->WriteLog("Error: Unable to create the missing cache folder ".$new_folder, TRUE, FALSE, 299, 'System', "");
            }
        }
        if ($read_cache) {
            $this->ReadCacheData();
        }
    }


    function GetCacheFolder(
        $create_if_not_exist = false
        ) {
    /**
     * @brief   Get the cache folder (for the cache file).
     *
     * @param   boolean $create_if_not_exist Create the folder if it doesn't exists.
     * @retval  string                       Full path to the cache folder.
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.2.5.0
     * @date    2014-07-25
     */
        $cache_folder = $this->ConvertToWindowsPathIfNeeded($this->_cache_folder);
        if ("" == $cache_folder) {
            $this->SetCacheFolder($this->GetScriptFolder()."cache/", $create_if_not_exist);
        } elseif (!file_exists($cache_folder)) {
            if ($create_if_not_exist) {
                if (!@mkdir($cache_folder)) {
                    $this->WriteLog("Error: Unable to create the missing cache folder ".$cache_folder, FALSE, FALSE, 299, 'System', "");
                }
            }
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_cache_folder);
    }


    function GetLocalIpAddress() {
        $local_ip_address = "";
        if (strtolower(substr(PHP_OS, 0, 3)) === 'win') { // Windows
            exec("ipconfig /all", $output);
            foreach($output as $line) {
                $line = $line."  ";
                if (preg_match("/.*IPv4.*[^\.]+([[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3})[^\.]+/", $line)) {
                    preg_match_all("/[^\.[:xdigit:]]+([[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3}[\.][[:xdigit:]]{1,3})/", $line, $result_array, PREG_SET_ORDER);
                    if (isset($result_array[0][1])) {
                        $temp = trim($result_array[0][1]);
                        if ('0.0.0.0' != $temp) {
                            $local_ip_address = strtoupper($temp);
                            break;
                        }
                    }
                }
            }
        } else { // Linux
            exec("ifconfig eth0 | grep \"inet addr\" | grep -o -E '([[:xdigit:]]{1,3}\.){3}[[:xdigit:]]{1,3}'", $output);
            $local_ip_address = strtoupper($output[0]);
        }
        return $local_ip_address;
    }


    function GetSystemName() {
        $system_name = trim(php_uname('n'));
        return $system_name;
    }


    function SetDomainName($value) {
        $this->_config_data['domain_name'] = ($value);
    }


    function GetDomainName() {
        return $this->_config_data['domain_name'];
    }


    function SetEmailAdminAddress(
        $value
    ) {
        $this->_config_data['email_admin_address'] = ($value);
    }


    function GetEmailAdminAddress() {
        return $this->_config_data['email_admin_address'];
    }


    function SetHashSalt(
        $salt
    ) {
        $this->_hash_salt  = trim($salt);
    }


    function GetHashSalt() {
        $salt = $this->_hash_salt;
        if ((("" == $salt) ||
             ("MySalt" == $salt) ||
             ("AjaxH@shS@lt" == $salt)
            ) &&
            ("" != $this->GetHashSaltFullPath()) &&
            file_exists($this->GetHashSaltFullPath())) {
            if ($hash_salt_file_handler = fopen($this->GetHashSaltFullPath(), "rt")) {
                $temp = trim(fgets($hash_salt_file_handler));
                if ("" != $temp) {
                    $salt = $temp;
                }
                fclose($hash_salt_file_handler);
            }
        }
        return trim($salt);
    }


    function SetRandomSalt(
        $salt
    ) {
        $this->_random_salt  = trim($salt);
    }


    function GetRandomSalt() {
        return trim($this->_random_salt);
    }


    function SetAdminPassword(
        $password
    ) {
        return $this->SetConfigAttribute('admin_password_hash',md5($this->GetHashSalt().$password.$this->GetHashSalt()));
    }


    function SetAdminPasswordHash(
        $password_hash
    ) {
        return $this->SetConfigAttribute('admin_password_hash',$password_hash);
    }

    // Weak security check: the client side should return password (for internal call only)
    function CheckAdminPassword(
        $password
    ) {
        return ($this->GetConfigAttribute('admin_password_hash') == md5($this->GetHashSalt().$password.$this->GetHashSalt()));
    }


    // Regular security check: the client side should return md5(hash_salt + password + hash_salt)
    function CheckAdminPasswordHash(
        $password_hash_with_salt
    ) {
        if (32 == strlen($password_hash_with_salt)) {
            return ($this->GetConfigAttribute('admin_password_hash') == $password_hash_with_salt);
        } else {
            return false;
        }
    }


    // Better security check: the client side should return md5(salt + md5(hash_salt + password + hash_salt) + salt)
    function CheckAdminPasswordHashWithRandomSalt($password_hash_with_salt) {
        if (32 == strlen($password_hash_with_salt)) {
            return (md5($this->GetRandomSalt().$this->GetConfigAttribute('admin_password_hash').$this->GetRandomSalt()) == $password_hash_with_salt);
        } else {
            return false;
        }
    }


    function EnableDebugViaHtml() {
        $this->_debug_via_html = TRUE;
    }


    function IsDebugViaHtml() {
        return ($this->_debug_via_html);
    }


    function EnableKeepLocal() {
        $this->_keep_local = TRUE;
    }


    function IsKeepLocal() {
        return ($this->_keep_local);
    }


    function SetLinuxFileMode(
        $mode
    ) {
        $this->_linux_file_mode = $mode;
    }


    function GetLinuxFileMode() {
        return ($this->_linux_file_mode);
    }


    function SetConfigData(
        $key,
        $value
    ) {
        if (isset($this->_config_data[$key])) {
            $this->_config_data[$key] = $value;
        }
    }


    function SetLogOption(
        $value
    ) {
        $this->_config_data['log'] = $value;
        if (1 == $this->_config_data['log']) {
            $this->EnableLog();
        }
    }


    function SetDebugOption(
        $value
    ) {
        $this->_config_data['debug'] = $value;
        if (1 == $this->_config_data['debug']) {
            $this->EnableVerboseLog();
        }
    }


    function SetDisplayLogOption(
        $value
    ) {
        $this->_config_data['display_log'] = $value;
        if (1 == $this->_config_data['display_log']) {
            $this->EnableDisplayLog();
        }
    }


    function SetMigrationFromFile(
        $value
    ) {
        $this->_migration_from_file = ($value?TRUE:FALSE);
    }


    function GetMigrationFromFile() {
        return $this->_migration_from_file;
    }


    function SetBackendType(
        $type
    ) {
        $this->_config_data['backend_type'] = $type;
        $this->_config_data['backend_type_validated'] = 0;
    }


    function GetBackendType() {
        return $this->_config_data['backend_type'];
    }


    function SetBackendTypeValidated(
        $backend_type_validated,
        $value
    ) {
        if ("" != $backend_type_validated) {
            $this->_config_data['backend_type'] = $backend_type_validated;
        }
        $this->_config_data['backend_type_validated'] = ($value?1:0);
    }

    function GetBackendTypeValidated() {
        return (1 == (isset($this->_config_data['backend_type_validated'])?$this->_config_data['backend_type_validated']:0));
    }

    function SetScratchPasswordsDigits(
        $value
    ) {
        $this->_config_data['scratch_passwords_digits'] = $value;
    }


    function GetScratchPasswordsDigits() {
        return $this->_config_data['scratch_passwords_digits'];
    }


    function SetDefaultUserGroup(
        $value
    ) {
        $this->_config_data['default_user_group'] = $value;
    }


    function GetDefaultUserGroup() {
        return $this->_config_data['default_user_group'];
    }


    function SetGroupAttribute(
        $value
    ) {
        $this->_config_data['group_attribute'] = $value;
    }


    function GetGroupAttribute() {
        return $this->_config_data['group_attribute'];
    }


    function SetIssuer(
        $value
    ) {
        $this->_config_data['issuer'] = $value;
    }


    function GetIssuer() {
        if (isset($this->_config_data['issuer'])) {
            return $this->_config_data['issuer'];
        } else {
            return "";
        }
    }


    function SetClearOtpAttribute($value) {
        $this->_config_data['clear_otp_attribute'] = $value;
    }


    function GetClearOtpAttribute() {
        return $this->_config_data['clear_otp_attribute'];
    }


    function SetSqlServer(
        $server
    ) {
        $this->_config_data['sql_server'] = $server;
    }


    function SetSqlUsername(
        $username
    ) {
        $this->_config_data['sql_username'] = $username;
    }


    function SetSqlPassword(
        $password
    ) {
        $this->_config_data['sql_password'] = $password;
    }


    function SetSqlDatabase(
        $database
    ) {
        $this->_config_data['sql_database'] = $database;
    }


    function SetSqlTableName(
        $table_to_define,
            $table_name
    ) {
        if (isset($this->_config_data['sql_'.$table_to_define.'_table'])) {
            $this->_config_data['sql_'.$table_to_define.'_table'] = $table_name;
        }
    }


    function MySqlAddRowIfNeeded($table, $row, $row_type, $is_an_index = FALSE) {
        $result = FALSE;
        if (is_object($this->_mysqli)) {
            $sql_query = "SELECT `".$row."` FROM ".$table;
            if ($result = $this->_mysqli->query($sql_query)) {
                $result = TRUE;
            } else { //$select_row = $result->fetch_assoc();
                $sql_query = "ALTER TABLE ".$table." ADD `".$row."` ".$row_type;
                if ($is_an_index) {
                    $sql_query.= " , ADD INDEX ( `".$row."` )";
                }
                if (!$this->_mysqli->query($sql_query)) {
                    $this->WriteLog("Error: ".trim($this->_mysqli->error)." ".$sql_query, TRUE, FALSE, 199, 'System', "");
                    $result = FALSE;
                }
            }
        } elseif (NULL != $this->_mysql_database_link) {
            $sql_query = "SELECT `".$row."` FROM ".$table;
            if (($select_row = mysql_query($sql_query, $this->_mysql_database_link))) {
                $result = TRUE;
            } elseif (!$select_row) {
                $sql_query = "ALTER TABLE ".$table." ADD `".$row."` ".$row_type;
                if ($is_an_index) {
                    $sql_query.= " , ADD INDEX ( `".$row."` )";
                }
                if (!mysql_query($sql_query, $this->_mysql_database_link)) {
                    $this->WriteLog("Error: ".mysql_error()." ".$sql_query, TRUE, FALSE, 199, 'System', "");
                    $result = FALSE;
                }
            }
        } elseif ($this->GetVerboseFlag()) {
            $this->WriteLog("Error: *The database link is down!", TRUE, FALSE, 199, 'System', "");
        }
        return $result;
    }


    function OpenMysqlDatabase() {
        if ((is_object($this->_mysqli)) || (NULL != $this->_mysql_database_link)) {
            $result = TRUE;
        } else {
            $result = FALSE;
            if (("" != $this->_config_data['sql_server']) &&
                ("" != $this->_config_data['sql_username']) &&
                ("" != $this->_config_data['sql_password']) &&
                ("" != $this->_config_data['sql_database'])) {
                if (class_exists('mysqli')) {
                    $this->_mysqli = @new mysqli($this->_config_data['sql_server'],
                                                 $this->_config_data['sql_username'],
                                                 $this->_config_data['sql_password'],
                                                 $this->_config_data['sql_database']);
                    if (0 != $this->_mysqli->connect_errno) {
                        $this->WriteLog("Error: Bad SQL authentication parameters, ".$this->_mysqli->connect_errno.', '.trim($this->_mysqli->connect_error), TRUE, FALSE, 199, 'System', "");
                        unset($this->_mysqli);
                        $this->_mysqli = NULL;
                    } else {
                        $result = TRUE;
                    }
                } elseif (!($this->_mysql_database_link = mysql_connect($this->_config_data['sql_server'],
                                                                        $this->_config_data['sql_username'],
                                                                        $this->_config_data['sql_password']))) {
                    $this->WriteLog("Error: Bad SQL authentication parameters, ".mysql_error(), TRUE, FALSE, 199, 'System', "");
                } else {
                    if (!mysql_select_db($this->_config_data['sql_database'])) {
                        $this->WriteLog("Error: Bad SQL database", TRUE, FALSE, 199, 'System', "");
                        mysql_close($this->_mysql_database_link);
                        $this->_mysql_database_link = NULL;
                    } else {
                        $result = TRUE;
                    }
                }
            }
        }
        return $result;
    }


    function InitializeBackend() {
        $write_config_data = false;
        $backend_type = $this->GetBackendType();
        if ('mysql' == $backend_type) {
            if ($this->OpenMysqlDatabase()) {
                foreach ($this->_sql_tables as $sql_table) {
                    if ("" != $this->_config_data['sql_'.$sql_table.'_table']) {
                        $sql_query = "CREATE TABLE IF NOT EXISTS `".$this->_config_data['sql_'.$sql_table.'_table']."` (unique_id bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (unique_id));";
                        if (is_object($this->_mysqli)) {
                            if (!($result = $this->_mysqli->query($sql_query))) {
                                $this->WriteLog("Error: Bad SQL request ($sql_query), ".trim($this->_mysqli->error), TRUE, FALSE, 199, 'System', "");
                                return 41;
                            }
                        } elseif (!mysql_query($sql_query, $this->_mysql_database_link)) {
                            $this->WriteLog("Error: Bad SQL request (CREATE TABLE ".$this->_config_data['sql_'.$sql_table.'_table']."), ".mysql_error(), TRUE, FALSE, 199, 'System', "");
                            return 41;
                        }
                        reset($this->_sql_tables_schema[$sql_table]);
                        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema[$sql_table])) {
                            $this->MySqlAddRowIfNeeded($this->_config_data['sql_'.$sql_table.'_table'], $valid_key, $valid_format, (FALSE !== strpos($this->_sql_tables_index[$sql_table], "*".$valid_key."*")));
                        }
                    }
                }
                $this->SetBackendTypeValidated($backend_type, TRUE);
                $write_config_data = true;
            }
        }
        if ($write_config_data) {
            $this->WriteConfigData();
        }
        return 19;
    }


    function IsOptionInSchema($schema, $option) {
        $in_the_schema = FALSE;
        if (isset($this->_sql_tables_schema[$schema])) {
            reset($this->_sql_tables_schema[$schema]);
            while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema[$schema])) {
                if ($valid_key == $option) {
                    $in_the_schema = TRUE;
                }
            }
        }
        return $in_the_schema;
    }


    function ReadConfigData(
        $encryption_only = false
    ) {
        $result = FALSE;
        
        // We initialize the encryption hash to empty
        $this->_config_data['encryption_hash'] = "";

        // First, we read the config file in any case
        $config_filename = 'multiotp.ini'; // File exists in v3 format only, we don't need any conversion
        if (file_exists($this->GetConfigFolder().$config_filename))
        {
            $file_handler = fopen($this->GetConfigFolder().$config_filename, "rt");
            $first_line = trim(fgets($file_handler));
            
            while (!feof($file_handler))
            {
                $line = str_replace(chr(10), "", str_replace(chr(13), "", fgets($file_handler)));
                $line_array = explode("=",$line,2);
                if (('#' != substr($line, 0, 1)) && (';' != substr($line, 0, 1)) && ("" != trim($line)) && (isset($line_array[1])))
                {
                    if (":" == substr($line_array[0], -1))
                    {
                        $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                        $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                    }
                    if ("" != $line_array[0])
                    {
                        $this->_config_data[strtolower($line_array[0])] = $line_array[1];
                    }
                }
            }
            fclose($file_handler);
            $result = TRUE;
            if (("" != $this->_config_data['encryption_hash']) && (!$encryption_only))
            {
                if ($this->_config_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                {
                    $this->_config_data['encryption_hash'] = "ERROR";
                    $this->WriteLog("Error: the configuration encryption key is not matching", FALSE, FALSE, 299, 'System', "");
                    $result = FALSE;
                }
            }
        }
        
        if (!$encryption_only)
        {
            if ($this->_initialize_backend)
            {
                $this->SetBackendTypeValidated("", FALSE);
                $this->WriteConfigData();
            }
            // And now, we override the values if another backend type is defined
            if ($this->GetBackendTypeValidated())
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            if ("" != $this->_config_data['sql_config_table'])
                            {
                                $sQuery  = "SELECT * FROM `".$this->_config_data['sql_config_table']."` ";
                                
                                $aRow = NULL;

                                if (is_object($this->_mysqli))
                                {
                                    if (!($result = $this->_mysqli->query($sQuery)))
                                    {
                                        $this->WriteLog("Error: ".trim($this->_mysqli->error)." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                                        $result = FALSE;
                                    }
                                    else
                                    {
                                        $aRow = $result->fetch_assoc();
                                    }
                                }
                                else
                                {
                                    if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                    {
                                        $this->WriteLog("Error: ".mysql_error()." ".$sQuery, TRUE, FALSE, 199, 'System', "");
                                        $result = FALSE;
                                    }
                                    else
                                    {
                                        $aRow = mysql_fetch_assoc($rResult);
                                    }
                                }

                                if (NULL != $aRow) {
                                    $result = TRUE;
                                    while(list($key, $value) = @each($aRow)) {
                                        $in_the_schema = FALSE;
                                        reset($this->_sql_tables_schema['config']);
                                        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['config'])) {
                                            if ($valid_key == $key) {
                                                $in_the_schema = TRUE;
                                            }
                                        }
                                        if ($in_the_schema) {
                                            if (FALSE === strpos($this->_sql_tables_ignore['config'], "*".$valid_key."*")) {
                                                if (('ENC:' == substr($value,0,4)) && (':ENC' == substr($value,-4))) {
                                                    $value = substr($value,4);
                                                    $value = substr($value,0,strlen($value)-4);
                                                    $this->_config_data[$key] = $this->Decrypt($key,$value,$this->GetEncryptionKey());
                                                } else {
                                                    $this->_config_data[$key] = $value;
                                                }
                                            }
                                        } elseif (('unique_id' != $key) && $this->GetVerboseFlag()) {
                                            $this->WriteLog("Warning: *the key ".$key." is not in the config database schema", FALSE, FALSE, 98, 'System', "");
                                        }
                                    }
                                }
                            }
                            if (("" != $this->_config_data['encryption_hash']) && ($this->_encryption_check)) {
                                if ($this->_config_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey())) {
                                    $this->_config_data['encryption_hash'] = "ERROR";
                                    $this->WriteLog("Error: the configuration mysql encryption key is not matching", FALSE, FALSE, 299, 'System', "");
                                    $result = FALSE;
                                }
                            }
                        }
                        break;
                    default:
                    // Nothing to do if the backend type is unknown
                        break;
                }
            }
            
            if (isset($this->_config_data['log']) && (1 == $this->_config_data['log']))
            {
                $this->EnableLog();
            }

            if (isset($this->_config_data['debug']) && (1 == $this->_config_data['debug']))
            {
                $this->EnableVerboseLog();
            }

            if (isset($this->_config_data['display_log']) && (1 == $this->_config_data['display_log']))
            {
                $this->EnableDisplayLog();
            }
            
            $this->SetAttributesToEncrypt(trim(isset($this->_config_data['attributes_to_encrypt'])?$this->_config_data['attributes_to_encrypt']:""));
            
            $timezone = $this->GetTimezone(); // Read the timezone (and set it in PHP automatically)
        }
        
        if ((!isset($this->_config_data['server_secret'])) || ('' == $this->_config_data['server_secret'])) {
            $this->_config_data['server_secret'] = 'ClientServerSecret';
        }
        return $result;
    }


    function WriteConfigData()
    {
        $result = $this->WriteData('Configuration',
                                   'config',
                                   $this->GetConfigFolder(true),
                                   $this->_config_data,
                                   true
                                  );
        return $result;
    }


    // Reset the temporary user array
    function ResetTempUserArray() {
        $temp_user_array = array();

        // First, we reset all values (we know the key based on the schema)
        reset($this->_sql_tables_schema['users']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['users'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $temp_user_array[$valid_key] = $value;
        }

        // Request the pin as a prefix of the returned token value
        $temp_user_array['request_prefix_pin'] = $this->GetDefaultRequestPrefixPin();
        
        return $temp_user_array;
    }


    // Reset the user array
    function ResetUserArray() {
        $this->_user_data = array();
        $this->_user_data = $this->ResetTempUserArray();

        // The user data array is not read actually
        $this->SetUserDataReadFlag(false);
    }


    function ResetTokenArray() {
        // First, we reset all values (we know the key based on the schema)
        reset($this->_sql_tables_schema['tokens']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['tokens'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $this->_token_data[$valid_key] = $value;
        }
        $this->_token_data['issuer'] = $this->GetIssuer();
        
        // The token data array is not read actually
        $this->SetTokenDataReadFlag(FALSE);
    }


    function ResetDeviceArray() {
        reset($this->_sql_tables_schema['devices']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['devices'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $this->_device_data[$valid_key] = $value;
        }
    }


    function ResetGroupArray() {
        reset($this->_sql_tables_schema['groups']);
        while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['groups'])) {
            $pos = strpos(strtoupper($valid_format), 'DEFAULT');
            $value = "";
            if ($pos !== FALSE) {
                $value = trim(substr($valid_format, $pos + strlen("DEFAULT")));
                if (("'" == substr($value,0,1)) && ("'" == substr($value,-1))) {
                    $value = substr($value,1,-1);
                }
            }
            $this->_group_data[$valid_key] = $value;
        }
    }


    function CleanPhoneNumber(
        $phone_number
    ) {
        $pn = trim(preg_replace('[\D]', "", $phone_number));
        // $pn_len = strlen($pn);
      
        if ('00' == substr($pn,0, 2)) {
            $pn = substr($pn, 2);
        } elseif ('0' == substr($pn,0, 1)) {
            $pn = $this->GetTelDefaultCountryCode() . substr($pn, 1);
        }
        return $pn;
    }


    function GetClassName() {
        return $this->_class;
    }


    function GetVersion() {
        return $this->_version;
    }


    function GetDate() {
        return $this->_date;
    }


    function GetVersionDate() {
        return $this->_version." (".$this->_date.")";
    }


    function GetFullVersionInfo() {
        return $this->_class." ".$this->_version." (".$this->_date.")";
    }


    function GetCopyright() {
        return $this->_copyright;
    }


    function GetWebsite() {
        return $this->_website;
    }


    function SetSourceTag(
        $value = ""
    ) {
        $this->_source_tag = trim($value);
    }


    function GetSourceTag() {
        return trim($this->_source_tag);
    }


    function SetSourceIp(
        $value = ""
    ) {
        $this->_source_ip = $value;
    }


    function GetSourceIp() {
        return $this->_source_ip;
    }


    function SetSourceMac(
        $value
    ) {
        $this->_source_mac = $value;
    }


    function GetSourceMac() {
        return $this->_source_mac;
    }


    function SetCallingIp(
        $value
    ) {
        $this->_calling_ip = $value;
    }


    function GetCallingIp() {
        return $this->_calling_ip;
    }


    function SetCallingMac(
        $value
    ) {
        $this->_calling_mac = $value;
    }


    function GetCallingMac() {
        return $this->_calling_mac;
    }


    function SetChapChallenge(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        $this->_chap_challenge = strtolower($temp);
    }


    function GetChapChallenge() {
        return strtolower($this->_chap_challenge);
    }


    function SetChapPassword(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        
        if (32 < strlen($temp)) {
            $this->SetChapId(substr($temp, 0, 2));
            $temp = substr($temp, 2);
        }
        $this->_chap_password = strtolower($temp);
    }


    function GetChapPassword() {
        return strtolower($this->_chap_password);
    }


    function SetMsChapChallenge(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        $this->_ms_chap_challenge = strtolower($temp);
    }


    function GetMsChapChallenge() {
        return strtolower($this->_ms_chap_challenge);
    }


    function SetMsChapResponse(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        $this->_ms_chap_response = strtolower($temp);
    }


    function GetMsChapResponse() {
        return strtolower($this->_ms_chap_response);
    }


    function SetMsChap2Response(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        $this->_ms_chap2_response = strtolower($temp);
    }


    function GetMsChap2Response() {
        return strtolower($this->_ms_chap2_response);
    }


    function SetChapId(
        $hex_value
    ) {
        $pos = strpos(strtolower($hex_value), 'x');
        if (FALSE === $pos) {
            $temp = $hex_value;
        } else {
            $temp = substr($hex_value, $pos+1);
        }
        $this->_chap_id = strtolower($temp);
    }


    function GetChapId() {
        return strtolower($this->_chap_id);
    }


    function SetNtKey(
        $hex_value
    ) {
        $temp = $hex_value;
        if (16 == strlen($temp)) {
            $temp = bin2hex($temp);
        }
        $pos = strpos(strtolower($temp), 'x');
        if (FALSE !== $pos) {
            $temp = substr($temp, $pos+1);
        }
        if (32 != strlen($temp)) {
            $temp = '';
        }
        $this->_ms_nt_key = strtoupper($temp);
    }


    function GetNtKey() {
        $temp = $this->_ms_nt_key;
        if (16 == strlen($temp)) {
            $temp = bin2hex($temp);
        } elseif (32 != strlen($temp)) {
            $temp = '';
        }
        return strtoupper($temp);
    }


    function GetSmsProvidersArray() {
        return $this->_sms_providers_array;
    }


    function GetSmsProvidersList() {
        $providers_list = '';
        foreach($this->GetSmsProvidersArray() as $one_provider) {
            $providers_list.= (('' != $providers_list)?"\t":'');
            $providers_list.= $one_provider[1];
            $providers_list.= ('' != $one_provider[0])?' ('.$one_provider[0].')':'';
            $providers_list.= ('' != $one_provider[2])?', '.$one_provider[2]:'';
        }
        return $providers_list;
    }


    function SetSmsProvider(
        $value
    ) {
        $this->_config_data['sms_provider'] = $value;
    }


    function GetSmsProvider() {
        return $this->_config_data['sms_provider'];
    }


    function SetSmsOriginator(
        $value
    ) {
        $this->_config_data['sms_originator'] = $value;
    }


    function GetSmsOriginator() {
        return $this->_config_data['sms_originator'];
    }


    function SetTelDefaultCountryCode(
        $value
    ) {
        $this->_config_data['tel_default_country_code'] = $value;
    }


    function GetTelDefaultCountryCode() {
        return $this->_config_data['tel_default_country_code'];
    }


    function SetSmsUserkey(
        $value
    ) {
        $this->_config_data['sms_userkey'] = $value;
    }


    function GetSmsUserkey() {
        return $this->_config_data['sms_userkey'];
    }


    function SetSmsPassword(
        $value
    ) {
        $this->_config_data['sms_password'] = $value;
    }


    function GetSmsPassword() {
        return $this->_config_data['sms_password'];
    }


    function SetSmsApiId(
        $value
    ) {
        $this->_config_data['sms_api_id'] = $value;
    }


    function GetSmsApiId() {
        return $this->_config_data['sms_api_id'];
    }


    function SetDefaultRequestLdapPwd(
        $value
    ) {
        $this->_config_data['default_request_ldap_pwd'] = ((intval($value) > 0)?1:0);
    }


    function GetDefaultRequestLdapPwd() {
        return $this->_config_data['default_request_ldap_pwd'];
    }


    function IsDefaultRequestLdapPwd() {
        return (1 == ($this->_config_data['default_request_ldap_pwd']));
    }


    function SetDefaultRequestPrefixPin(
        $value
    ) {
        $this->_config_data['default_request_prefix_pin'] = ((intval($value) > 0)?1:0);
    }


    function GetDefaultRequestPrefixPin() {
        return $this->_config_data['default_request_prefix_pin'];
    }


    function IsDefaultRequestPrefixPin() {
        return (1 == ($this->_config_data['default_request_prefix_pin']));
    }


    function EnableLdapError() {
        $this->_last_ldap_error = TRUE;
    }


    function DisableLdapError() {
        $this->_last_ldap_error = FALSE;
    }


    function IsLdapError() {
        return $this->_last_ldap_error;
    }


    function SetLdapActivated(
        $value
    ) {
        $this->_config_data['ldap_activated'] = ((intval($value) > 0)?1:0);
    }


    function EnableLdapActivated() {
        $this->_config_data['ldap_activated'] = 1;
    }


    function DisableLdapActivated() {
        $this->_config_data['ldap_activated'] = 0;
    }


    function IsLdapActivated() {
        return (1 == ($this->_config_data['ldap_activated']));
    }


    function SetLdapSsl(
        $value
    ) {
        $this->_config_data['ldap_ssl'] = ((intval($value) > 0)?1:0);
    }


    function EnableLdapSsl() {
        $this->_config_data['ldap_ssl'] = 1;
    }


    function DisableLdapSsl() {
        $this->_config_data['ldap_ssl'] = 0;
    }


    function IsLdapSsl() {
        return (1 == ($this->_config_data['ldap_ssl']));
    }


    function SetLdapAccountSuffix(
        $value
    ) {
        $this->_config_data['ldap_account_suffix'] = $value;
    }


    function GetLdapAccountSuffix() {
        return $this->_config_data['ldap_account_suffix'];
    }


    function SetLdapCnIdentifier(
        $value
    ) {
        if ('' != trim($value)) {
            $this->_config_data['ldap_cn_identifier'] = trim($value);
        }
    }


    function GetLdapCnIdentifier() {
        return ($this->_config_data['ldap_cn_identifier']);
    }


    function SetLdapGroupCnIdentifier(
        $value
    ) {
        if ('' != trim($value)) {
            $this->_config_data['ldap_group_cn_identifier'] = trim($value);
        }
    }


    function GetLdapGroupCnIdentifier() {
        return ($this->_config_data['ldap_group_cn_identifier']);
    }


    function GetLdapFieldsArray() {
        if (1 == $this->GetLdapServerType()) { // Active Directory
            // "department" removed, while not used
            $ldap_fields = array($this->GetLdapCnIdentifier(),
                                 "mail",
                                 $this->GetLdapGroupAttribute(),
                                 "displayName",
                                 "description",
                                 "telephoneNumber",
                                 "primaryGroupID",
                                 "mobile",
                                 "msNPAllowDialin",
                                 "userAccountControl", // (userAccountControl & 2) -> Account disabled
                                 "ms-DS-User-Account-Control-Computed", // (ms-DS-User-Account-Control-Computed & 16) -> Account locked
                                 "accountExpires", // Expiration of the account in 100-nanosecond (10000000 x epoch time !)
                                 "distinguishedName"
                                );
        } else { // Generic LDAP, no attribute like "msNPAllowDialin"
            /*
             * shadowexpire: -1: not used, otherwise, number of days since 01.01.1970 when the account will be disabled
             * sambaAcctFlags (details: http://pig.made-it.com/samba-accounts.html):
             *  U    Regular user account.
             *  W    Workstation Trust Account.
             *  S    Server Trust Account.
             *  I    Domain Trust Account.
             *  M    MNS logon user account (Majority Node Set (MNS) logon account).
             *  H    Home directory required.
             *  N    No password required. This means the account has no password.
             *  X    Password does not expire.
             *  D    Account disabled.
             *  T    Temporary duplicate of other account.
             *  L    The account has been automatically locked.
             */
            $ldap_fields = array($this->GetLdapCnIdentifier(),
                                 "mail",
                                 $this->GetLdapGroupAttribute(),
                                 "displayName",
                                 "description",
                                 "gecos",
                                 "telephoneNumber",
                                 "gidNumber",
                                 "mobile",
                                 "sambaAcctFlags",
                                 "shadowExpire",
                                 "distinguishedName"
                                );
        }
        return ($ldap_fields);
    }


    function SetLdapBaseDn(
        $value
    ) {
        $this->_config_data['ldap_base_dn'] = $value;
    }


    function GetLdapBaseDn() {
        return $this->_config_data['ldap_base_dn'];
    }


    function SetLdapBindDn(
        $value
    ) {
        $this->_config_data['ldap_bind_dn'] = $value;
    }


    function GetLdapBindDn() {
        return encode_utf8_if_needed($this->_config_data['ldap_bind_dn']);
    }


    function SetLdapDomainControllers(
        $value
    ) {
        $this->_config_data['ldap_domain_controllers'] = trim($value);
    }


    function GetLdapDomainControllers() {
        return $this->_config_data['ldap_domain_controllers'];
    }


    function GetLdapPrimaryController() {
        $domain_controllers = str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()));
        $controllers_array = explode(" ",$this->GetLdapDomainControllers());
        return trim(isset($controllers_array[0])?$controllers_array[0]:'');
    }


    function GetLdapSecondaryController() {
        $domain_controllers = str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()));
        $controllers_array = explode(" ",$this->GetLdapDomainControllers());
        return trim(isset($controllers_array[1])?$controllers_array[1]:'');
    }


    function SetLdapInGroup(
        $value
    ) {
        $this->_config_data['ldap_in_group'] = $value;
    }


    function GetLdapInGroup() {
        return $this->_config_data['ldap_in_group'];
    }


    function SetLdapGroupAttribute(
        $value
    ) {
        if ('' != trim($value)) {
            $this->_config_data['ldap_group_attribute'] = trim($value);
        }
    }


    function GetLdapGroupAttribute() {
        return ($this->_config_data['ldap_group_attribute']);
    }


    function SetLdapServerPassword(
        $value
    ) {
        $this->_config_data['ldap_server_password'] = $value;
    }


    function GetLdapServerPassword() {
        return encode_utf8_if_needed($this->_config_data['ldap_server_password']);
    }


    function SetLdapPort(
        $value
    ) {
        $this->_config_data['ldap_port'] = intval($value);
    }


    function GetLdapPort() {
        return $this->_config_data['ldap_port'];
    }


    function SetLdapServerType(
        $value,
        $default_parameters = false
    ) {
        $this->_config_data['ldap_server_type'] = intval($value);
        
        // These values are not in the options for now
        if (1 == $value) { // Active Directory
            $this->SetLdapGroupCnIdentifier('sAMAccountName');
        } else { // Generic LDAP
            $this->SetLdapGroupCnIdentifier('cn');
        }
        if ($default_parameters) {
            if (1 == $value) { // Active Directory
                $this->SetLdapCnIdentifier('sAMAccountName');
            } else { // Generic LDAP
                $this->SetLdapCnIdentifier('uid');
            }
        }
    }


    function GetLdapServerType() {
        return $this->_config_data['ldap_server_type'];
    }


    function SetLdapTimeLimit(
        $value
    ) {
        $this->_config_data['ldap_time_limit'] = intval($value);
    }


    function GetLdapTimeLimit() {
        return $this->_config_data['ldap_time_limit'];
    }


    function SetLdapNetworkTimeout(
        $value
    ) {
        $this->_config_data['ldap_network_timeout'] = intval($value);
    }


    function GetLdapNetworkTimeout() {
        return $this->_config_data['ldap_network_timeout'];
    }


    function SetLdapHashCacheTime(
        $value
    ) {
        $this->_config_data['ldap_hash_cache_time'] = intval($value);
    }


    function GetLdapHashCacheTime() {
        return $this->_config_data['ldap_hash_cache_time'];
    }


    function SetSmsMessage(
        $value
    ) {
        $this->_config_data['sms_message_prefix'] = $value;
    }


    function GetSmsMessage() {
        return $this->_config_data['sms_message_prefix'];
    }


    function SetSmsDigits(
        $value
    ) {
        $this->_config_data['sms_digits'] = intval($value);
    }


    function GetSmsDigits() {
        return $this->_config_data['sms_digits'];
    }


    function SetSmsTimeout(
        $value
    ) {
        $this->_config_data['sms_timeout'] = intval($value);
    }


    function GetSmsTimeout() {
        return $this->_config_data['sms_timeout'];
    }


    function SetConfigAttribute(
        $attribute,
        $value
    ) {
        $result = FALSE;
        if ($this->IsOptionInSchema('config',$attribute)) {
            $this->_config_data[$attribute] = $value;
            $result = TRUE;
        }
        return $result;
    }


    function GetConfigAttribute(
        $attribute
    ) {
        return isset($this->_config_data[$attribute])?$this->_config_data[$attribute]:'';
    }


    function SetMaxTimeWindow(
        $time_window
    ) {
        $this->_config_data['max_time_window'] = intval($time_window);
    }


    function GetMaxTimeWindow() {
        return $this->_config_data['max_time_window'];
    }


    function SetMaxTimeResyncWindow(
        $time_resync_window
    ) {
        $this->_config_data['max_time_resync_window'] = intval($time_resync_window);
    }


    function GetMaxTimeResyncWindow() {
        return $this->_config_data['max_time_resync_window'];
    }


    function SetMaxEventWindow(
        $event_window
    ) {
        $this->_config_data['max_event_window'] = intval($event_window);
    }


    function GetMaxEventWindow() {
        return $this->_config_data['max_event_window'];
    }


    function SetMaxEventResyncWindow(
        $event_resync_window
    ) {
        $this->_config_data['max_event_resync_window'] = intval($event_resync_window);
    }


    function GetMaxEventResyncWindow() {
        return $this->_config_data['max_event_resync_window'];
    }


    function SetMaxBlockFailures(
        $max_failures
    ) {
        $this->_config_data['max_block_failures'] = $max_failures;
    }


    function GetMaxBlockFailures() {
        return $this->_config_data['max_block_failures'];
    }


    function SetServerCacheLevel(
        $value
    ) {
        $this->_config_data['server_cache_level'] = intval($value);
    }


    function GetServerCacheLevel() {
        return intval($this->_config_data['server_cache_level']);
    }


    function SetServerCacheLifetime(
        $value
    ) {
        $this->_config_data['server_cache_lifetime'] = intval($value);
    }


    function GetServerCacheLifetime() {
        return intval($this->_config_data['server_cache_lifetime']);
    }


    function SetServerChallenge(
        $value
    ) {
        $this->_server_challenge = $value;
    }


    function GetServerChallenge() {
        return $this->_server_challenge;
    }


    function SetServerSecret(
        $value
    ) {
        $this->_config_data['server_secret'] = $value;
    }


    function GetServerSecret() {
        return $this->_config_data['server_secret'];
    }


    function SetServerType(
        $value
    ) {
        $this->_config_data['server_type'] = $value;
    }


    function GetServerType() {
        return $this->_config_data['server_type'];
    }


    function SetServerTimeout(
        $value
    ) {
        $this->_config_data['server_timeout'] = intval($value);
    }


    function GetServerTimeout() {
        return intval($this->_config_data['server_timeout']);
    }


    function SetServerUrl(
        $value
    ) {
        $this->_config_data['server_url'] = trim($value);
    }


    function GetServerUrl() {
        return trim($this->_config_data['server_url']);
    }


    function SetSelfRegistration(
        $value
    ) {
        $this->_config_data['self_registration'] = ((intval($value) > 0)?1:0);
    }


    function EnableSelfRegistration() {
        $this->_config_data['self_registration'] = 1;
    }


    function DisableSelfRegistration() {
        $this->_config_data['self_registration'] = 0;
    }


    function IsSelfRegistrationEnabled() {
        return (1 == ($this->_config_data['self_registration']));
    }


    function SetAutoResync(
        $value
    ) {
        $this->_config_data['auto_resync'] = ((intval($value) > 0)?1:0);
    }


    function EnableAutoResync() {
        $this->_config_data['auto_resync'] = 1;
    }


    function DisableAutoResync() {
        $this->_config_data['auto_resync'] = 0;
    }


    function IsAutoResync() {
        return (1 == ($this->_config_data['auto_resync']));
    }


    function SetCacheData(
        $value
    ) {
        $this->_config_data['cache_data'] = ((intval($value) > 0)?1:0);
    }


    function EnableCacheData() {
        $this->_config_data['cache_data'] = 1;
    }


    function DisableCacheData() {
        $this->_config_data['cache_data'] = 0;
    }


    function IsCacheData() {
        return (1 == ($this->_config_data['cache_data']));
    }


    function SetCaseSensitiveUsers() {
        $this->_config_data['case_sensitive_users'] = ((intval($value) > 0)?1:0);
    }


    function EnableCaseSensitiveUsers() {
        $this->_config_data['case_sensitive_users'] = 1;
    }


    function DisableCaseSensitiveUsers() {
        $this->_config_data['case_sensitive_users'] = 0;
    }


    function IsCaseSensitiveUsers() {
        return (1 == ($this->_config_data['case_sensitive_users']));
    }


    function SetNtpServer(
        $ntp_server
    ) {
        $this->_config_data['ntp_server'] = $ntp_server;
    }


    function GetNtpServer() {
        return trim($this->_config_data['ntp_server']);
    }


    function SetRadiusReplyAttributor(
        $radius_reply_attributor
    ) {
        $this->_config_data['radius_reply_attributor'] = $radius_reply_attributor;
    }


    function GetRadiusReplyAttributor() {
        return ($this->_config_data['radius_reply_attributor']);
    }


    function SetRadiusReplySeparator(
        $radius_reply_separator
    ) {
        switch (strtolower($radius_reply_separator)) {
            case 'colon':
                $radius_reply_separator = ':';
                break;
            case 'comma':
                $radius_reply_separator = ',';
                break;
            case 'cr':
                $radius_reply_separator = chr(13);
                break;
            case 'crlf':
                $radius_reply_separator = chr(13).chr(10);
                break;
            case 'lf':
                $radius_reply_separator = chr(10);
                break;
            case 'semicolon':
                $radius_reply_separator = ';';
                break;
        }
        $this->_config_data['radius_reply_separator_hex'] = bin2hex($radius_reply_separator);
    }


    function GetRadiusReplySeparator()
    {
        return hex2bin($this->_config_data['radius_reply_separator_hex']);
    }


    function SetTimezone($timezone)
    {
        $this->_config_data['timezone'] = $timezone;
        if (function_exists('date_default_timezone_set'))
        {
            date_default_timezone_set($timezone);
        }
    }


    function GetTimezone()
    {
        $timezone = trim(isset($this->_config_data['timezone'])?$this->_config_data['timezone']:'');
        if (('' != $timezone) && (function_exists('date_default_timezone_set')))
        {
            date_default_timezone_set($timezone);
        }
        return $timezone;
    }


    function SetSmtpAuth($value)
    {
        $this->_config_data['smtp_auth'] = ((intval($value) > 0)?1:0);
    }


    function GetSmtpAuth()
    {
        return (($this->_config_data['smtp_auth'] > 0)?1:0);
    }


    function IsSmtpAuth()
    {
        return (1 == ($this->_config_data['smtp_auth']));
    }


    function SetSmtpPassword($value)
    {
        $this->_config_data['smtp_password'] = $value;
    }


    function GetSmtpPassword()
    {
        return $this->_config_data['smtp_password'];
    }


    function SetSmtpPort($value)
    {
        $this->_config_data['smtp_port'] = intval($value);
    }


    function GetSmtpPort()
    {
        return intval($this->_config_data['smtp_port']);
    }


    function SetSmtpSender($value)
    {
        $this->_config_data['smtp_sender'] = $value;
    }


    function GetSmtpSenderName()
    {
        return $this->_config_data['smtp_sender_name'];
    }


    function SetSmtpSenderName($value)
    {
        $this->_config_data['smtp_sender_name'] = $value;
    }


    function GetSmtpSender()
    {
        return $this->_config_data['smtp_sender'];
    }


    function SetSmtpServer($value)
    {
        $this->_config_data['smtp_server'] = $value;
    }


    function GetSmtpServer()
    {
        return $this->_config_data['smtp_server'];
    }


    function SetSmtpSsl($value)
    {
        $this->_config_data['smtp_ssl'] = ((intval($value) > 0)?1:0);
    }


    function GetSmtpSsl()
    {
        return (($this->_config_data['smtp_ssl'] > 0)?1:0);
    }


    function SetSmtpUsername($value)
    {
        $this->_config_data['smtp_username'] = $value;
    }


    function GetSmtpUsername()
    {
        return $this->_config_data['smtp_username'];
    }


    function SetSyslogFacility($value)
    {
        $this->_config_data['syslog_facility'] = $value;
    }


    function GetSyslogFacility()
    {
        return $this->_config_data['syslog_facility'];
    }


    function SetSyslogLevel($value)
    {
        $this->_config_data['syslog_level'] = intval($value);
    }


    function GetSyslogLevel()
    {
        return intval($this->_config_data['syslog_level']);
    }


    function SetSysLogPort($value)
    {
        $this->_config_data['syslog_port'] = intval($value);
    }


    function GetSysLogPort()
    {
        return intval($this->_config_data['syslog_port']);
    }


    function SetSysLogServer($value)
    {
        $this->_config_data['syslog_server'] = $value;
    }


    function GetSysLogServer()
    {
        return $this->_config_data['syslog_server'];
    }


    function DefineMySqlConnection($sql_server, $sql_user, $sql_passwd, $sql_db, $sql_log_table = NULL, $sql_users_table = NULL, $sql_tokens_table = NULL)
    /**
     * @brief   DEPRECATED: Define the SQL parameters for the MySQL backend
     *
     * @param   string  $sql_server        MySQL server
     * @param   string  $sql_user          MySQL user
     * @param   string  $sql_passwd        MySQL password
     * @param   string  $sql_db            MySQL database
     * @param   string  $sql_log_table     MySQL log table
     * @param   string  $sql_users_table   MySQL users table
     * @param   string  $sql_tokens_table  MySQL tokens table
     * @retval  void
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.0.1
     * @date    2013-06-09
     * @since   2010-12-18
     */
    {
        // Backend storage type
        $this->SetBackendType('mysql');
        $this->SetSqlServer($sql_server);
        $this->SetSqlUsername($sql_user);
        $this->SetSqlPassword($sql_passwd);
        $this->SetSqlDatabase($sql_db);
        
        // If table names are not defined, we keep the default value defined in the class constructor.
        if (NULL !== $sql_log_table)
        {
            $this->SetSqlTableName('log', $sql_log_table);
        }
        if (NULL !== $sql_users_table)
        {
            $this->SetSqlTableName('users', $sql_users_table);
        }
        if (NULL !== $sql_tokens_table)
        {
            $this->SetSqlTableName('tokens', $sql_tokens_table);
        }
    }


    /*********************************************************************
     *
     * Name: ComputeMotp
     * Short description: Compute the mOTP result
     *
     * Creation 2010-06-07
     * Update 2013-12-23
     * @package multiotp
     * @version 2.0.0
     * @author SysCo/al
     *
     * @param   string  $seed_and_pin  Key used to compute the mOTP result (seed is in hexa)
     * @param   int     $timestep      Timestep used to calculate the token
     * @param   int     $token_size    Token size
     * @return  string                 mOTP result
     *
     *********************************************************************/
    function ComputeMotp($seed_and_pin, $timestep, $token_size)
    {
        return strtolower(substr(md5($timestep.$seed_and_pin),0,$token_size));
    }


    /*********************************************************************
     *
     * Name: GenerateOathHotp
     * Short description: Compute the HOTP token
     *
     * Creation 2013-11-26
     * Update 2013-12-23
     * @package multiotp
     * @version 4.1.0
     * @author SysCo/al
     *
     * @param   string  $key      Key used to compute the HOTP token
     * @param   int     $counter  Counter position
     * @param   int     $length   Token size
     * @return  string            HOTP token
     *
     *********************************************************************/
    function GenerateOathHotp($key, $counter, $length = 6, $hash_algo = 'HMAC-SHA1')
    {
        return $this->ComputeOathTruncate($this->ComputeOathHotp($key, $counter, $hash_algo),$length);
    }    


    /*********************************************************************
     *
     * Name: ComputeOathHotp
     * Short description: Compute the OATH defined hash
     *
     * Creation 2010-06-07
     * Update 2010-07-19
     * @package multiotp
     * @version 3.0.0
     * @author SysCo/al
     *
     * @param   string  $key      Key used to compute the OATH hash
     * @param   int     $counter  Counter position
     * @return  string            Full OATH hash
     *
     *********************************************************************/
    function ComputeOathHotp($key, $counter, $hash_algo = 'HMAC-SHA1')
    {
        // Counter
        //the counter value can be more than one byte long, so we need to go multiple times
        $cur_counter = array(0,0,0,0,0,0,0,0);
        for($i=7;$i>=0;$i--)
        {
            $cur_counter[$i] = pack ('C*', $counter);
            $counter = $counter >> 8;
        }
        $bin_counter = implode($cur_counter);
        // Pad to 8 chars
        if (strlen ($bin_counter) < 8)
        {
            $bin_counter = str_repeat(chr(0), 8 - strlen($bin_counter)) . $bin_counter;
        }

        // HMAC hash
        if ('HMAC-SHA512' == strtoupper($hash_algo))
        {
            $hash = hash_hmac('sha512', $bin_counter, $key);
        }
        elseif ('HMAC-SHA256' == strtoupper($hash_algo))
        {
            $hash = hash_hmac('sha256', $bin_counter, $key);
        }
        elseif ('HMAC-MD5' == strtoupper($hash_algo))
        {
            $hash = hash_hmac('md5', $bin_counter, $key);
        }
        else // if ('HMAC-SHA1' == strtoupper($hash_algo))
        {
            $hash = hash_hmac('sha1', $bin_counter, $key);
        }
        return $hash;
    }


    /*********************************************************************
     *
     * Name: ComputeOathTruncate
     * Short description: Truncate the result as defined by the OATH
     *
     * Creation 2010-06-07
     * Update   2014-01-15
     * @package multiotp
     * @version 4.1.1
     * @author SysCo/al
     *
     * @param   string  $hash     Full OATH hash to be truncated
     * @param   int     $length   Length of the result token
     * @return  string            Truncated OATH hash
     *
     *********************************************************************/
    function ComputeOathTruncate($hash, $length = 6)
    {
        // Convert hash to decimal
        foreach(str_split($hash,2) as $hex)
        {
            $hmac_result[]=hexdec($hex);
        }

        // Find offset
        $offset = $hmac_result[(strlen($hash)/2)-1] & 0xf;

        // Adapted algorithm ("substr -10" instead of "% pow(10,$length)")
        $result = substr(str_repeat('0',$length).
                         sprintf('%u',
                                      (($hmac_result[$offset+0] & 0x7f) << 24 ) |
                                      (($hmac_result[$offset+1] & 0xff) << 16 ) |
                                      (($hmac_result[$offset+2] & 0xff) << 8 ) |
                                       ($hmac_result[$offset+3] & 0xff)
                                ),
                         -$length);
        return $result;
    }


    function CalculateChapPassword($secret, $hex_chap_id = '', $hex_chap_challenge = '')
    {
        
        if ($hex_chap_id != '')
        {
            $id = hex2bin($hex_chap_id);
        }
        elseif (32 < strlen($this->GetChapPassword()))
        {
            $id = hex2bin(substr($this->GetChapPassword(),0,2));
        }
        else
        {
            $id = hex2bin($this->GetChapId());
        }
        
        if ($hex_chap_challenge != '')
        {
            $challenge = hex2bin($hex_chap_challenge);
        }
        else
        {
            $challenge = hex2bin($this->GetChapChallenge());
        }
        
        return md5($id.$secret.$challenge);
    }


    function Convert2Unicode($value) 
    {
        $unicode = '';
        $string = (string) $value;
        for ($i = 0; $i < strlen($string); $i++)
        {
            $asc = ord($string{$i}) << 8;
            $unicode .= sprintf("%X", $asc);
        }
        return pack('H*', $unicode);
    }


    function Padding7to8($value)
    {
        static $odd_parity = array(  1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
                                    16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
                                    32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
                                    49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
                                    64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
                                    81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
                                    97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
                                   112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
                                   128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
                                   145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
                                   161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
                                   176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
                                   193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
                                   208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
                                   224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
                                   241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254);

        $raw = '';
        for ($i = 0; $i < strlen($value); $i++)
        {
            $raw .= sprintf('%08s', decbin(ord($value{$i})));
        }

        $str1 = explode('-', substr(chunk_split($raw, 7, '-'), 0, -1));
        $x = '';
        foreach($str1 as $char)
        {
            $x .= sprintf('%02s', dechex($odd_parity[bindec($char. '0')]));
        }

        return pack('H*', $x);
    }


    function DesHashEcb($clear)
    {
        $cipher = new Crypt_DES(CRYPT_DES_MODE_ECB);
        $cipher->setKey($this->Padding7to8($clear));
        return $cipher->encrypt('KGS!@#$%');
    }


    function LmPasswordHash($clear)
    {
        $clear = substr(strtoupper($clear.str_repeat("\0",14)), 0, 14);
        return substr($this->DesHashEcb(substr($clear, 0, 7)),0,8).substr($this->DesHashEcb(substr($clear, 7, 7)),0,8);
    }


    function NtPasswordHash($clear) 
    {
        return pack('H*',hash('md4', $this->Convert2Unicode($clear)));
    }


    function NtPasswordHashHash($hash) 
    {
        return pack('H*',hash('md4', $hash));
    }


    function CalculateMsChapResponse($secret, $hex_mschap_challenge = '', $hex_mschap_response = '')
    {
        $temp_challenge = ('' != $hex_mschap_challenge)?$hex_mschap_challenge:$this->GetMsChapChallenge();
        $pos = strpos(strtolower($temp_challenge), 'x');
        if (FALSE !== $pos)
        {
            $temp_challenge = substr($temp_challenge, $pos+1);
        }

        $temp_response  = ('' != $hex_mschap_response)?$hex_mschap_response:$this->GetMsChapResponse();
        $this->SetMsChapResponse($temp_response);
        $pos = strpos(strtolower($temp_response), 'x');
        if (FALSE !== $pos)
        {
            $temp_response = substr($temp_response, $pos+1);
        }

        $mschap_challenge = hex2bin($temp_challenge);
        $mschap_response  = hex2bin($temp_response);

        if (24 == strlen($mschap_response))
        {
            $mschap_response = str_repeat("\0",2+24).$mschap_response;
        }
        
        $id          = substr($mschap_response,0,1);
        $flag        = ord(substr($mschap_response,1,1));   // 1 = use NT-Response, 0 = use LM-Response
        $lm_response = substr($mschap_response,2,24);  // LM-Response
        $nt_response = substr($mschap_response,26,24); // NT-Response
        
        if (1 == $flag)
        {
            $hash = $this->NtPasswordHash($secret);
            $response = $nt_response;
            $hash_for_nt_key = $hash;
            
        }
        else
        {
            $hash = $this->LmPasswordHash($secret);
            $response = $lm_response;
            $hash_for_nt_key = $this->NtPasswordHash($secret);
        }

        $this->SetNtKey(bin2hex($this->NtPasswordHashHash($hash)));

        $challenge = $mschap_challenge;

        $hash = substr($hash.str_repeat("\0",21), 0, 21);

        $cipher = new Crypt_DES(CRYPT_DES_MODE_ECB);
        $cipher->setKey($this->Padding7to8(substr($hash, 0, 7)));
        $part1 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $cipher->setKey($this->Padding7to8(substr($hash, 7, 7)));
        $part2 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $cipher->setKey($this->Padding7to8(substr($hash, 14, 7)));
        $part3 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $calculated_response = $part1.$part2.$part3;
        
        if ($calculated_response == $response)
        {
            $result = strtolower(bin2hex($mschap_response));
        }
        else
        {
            $result = 'Error: '.bin2hex($calculated_response).' instead of '.bin2hex($nt_response);
        }
        return $result;
    }


    function CheckMsChapResponse($secret, $hex_mschap_challenge = '', $hex_mschap_response = '')
    {
        $result = $this->CalculateMsChapResponse($secret, $hex_mschap_challenge, $hex_mschap_response);
        
        return ($this->GetMsChapResponse() == strtolower($result));
    }


    function CalculateMsChap2Response($user, $secret, $domain = "", $hex_mschap_challenge = '', $hex_mschap2_response = '')
    {
        $temp_challenge = ('' != $hex_mschap_challenge)?$hex_mschap_challenge:$this->GetMsChapChallenge();
        $pos = strpos(strtolower($temp_challenge), 'x');
        if (FALSE !== $pos)
        {
            $temp_challenge = substr($temp_challenge, $pos+1);
        }

        $temp_response  = ('' != $hex_mschap2_response)?$hex_mschap2_response:$this->GetMsChap2Response();
        $this->SetMsChap2Response($temp_response);
        $pos = strpos(strtolower($temp_response), 'x');
        if (FALSE !== $pos)
        {
            $temp_response = substr($temp_response, $pos+1);
        }

        $mschap_challenge = hex2bin($temp_challenge);
        $mschap2_response = hex2bin($temp_response);

        if (24 == strlen($mschap2_response))
        {
            $mschap2_response = str_repeat("\0",2+24).$mschap2_response;
        }

        $id             = substr($mschap2_response,0,1);
        $flag           = ord(substr($mschap2_response,1,1)); // 0 (reserved for future use)
        $peer_challenge = substr($mschap2_response,2,16);
        $empty          = substr($mschap2_response,18,8);
        $nt_response    = substr($mschap2_response,26,24);
        
        $hash = $this->NtPasswordHash($secret);

        $this->SetNtKey(bin2hex($this->NtPasswordHashHash($hash)));

        /*
        $kr = hash_hmac('md5',
                        pack('H*',hash('md4', $hash)),
                        $this->Convert2Unicode(strtoupper($user).$domain)
                       );
                       
        $nt_response_sig = hash_hmac('md5',
                                     $kr,
                                     $nt_response
                                    );

        $nt_key = hash_hmac('md5',
                            $kr,
                            $nt_response_sig
                           );

        $this->SetNtKey($nt_key);
        */

        if (8 == strlen($mschap_challenge))
        {
            $challenge = $mschap_challenge;
        }
        else
        {
            $challenge = substr(pack('H*',hash('sha1', $peer_challenge.$mschap_challenge.$user)), 0, 8);
        }

        $hash = substr($hash.str_repeat("\0",21), 0, 21);
        
        $cipher = new Crypt_DES(CRYPT_DES_MODE_ECB);
        $cipher->setKey($this->Padding7to8(substr($hash, 0, 7)));
        $part1 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $cipher->setKey($this->Padding7to8(substr($hash, 7, 7)));
        $part2 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $cipher->setKey($this->Padding7to8(substr($hash, 14, 7)));
        $part3 = substr($cipher->encrypt(substr($challenge,0,8)),0,8);
        
        $calculated_response = $part1.$part2.$part3;

        if ($calculated_response == $nt_response)
        {
            $result = strtolower(bin2hex($mschap2_response));
        }
        else
        {
            $result = 'Error: '.bin2hex($calculated_response).' instead of '.bin2hex($nt_response);
        }
        return $result;
    }


    function CheckMsChap2Response($user, $secret, $domain = "", $hex_mschap_challenge = '', $hex_mschap2_response = '')
    {
        $result = $this->CalculateMsChap2Response($user, $secret, $domain, $hex_mschap_challenge, $hex_mschap2_response);
        
        return ($this->GetMsChap2Response() == strtolower($result));
    }


    function SetEncryptionKey($key, $read_config = TRUE)
    {
        $this->_encryption_key = $key;
        if ($read_config)
        {
            $this->ReadConfigData();
        }
    }


    function GetEncryptionKey()
    {
        return $this->_encryption_key;
    }


    function CalculateControlHash($value_to_hash)
    {
        return strtoupper(md5("CaLcUlAtE".$value_to_hash."cOnTrOlHaSh"));
    }


    function Encrypt($key, $value, $encryption_key)
    {
        $result = '';
        if (strlen($encryption_key) > 0)
        {
            if (0 < strlen($value))
            {
                for ($i=0;  $i < strlen($value); $i++)
                {
                    $encrypt_char = ord(substr($encryption_key,$i % strlen($encryption_key),1));
                    $key_char = ord(substr($key,$i % strlen($key),1));
                    $result .= chr($encrypt_char^$key_char^ord(substr($value,$i,1)));
                }
                $result = base64_encode($result);
            }
        }
        else
        {
            $result = $value;
        }
        return $result;
    }


    function Decrypt($key, $value, $encryption_key)
    /**
     * @brief   Decrypt the encrypted value of a label using an encryption key.
     *
     * @param   string  $key             Label of the value.
     * @param   string  $value           Encrypted value.
     * @param   string  $encryption_key  Encryption key.
     * @retval  string                   Decrypted value.
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 1.1.0
     * @date    2013-11-02
     */
    {
        $result = '';
        if (strlen($encryption_key) > 0)
        {
            if (0 < strlen($value))
            {
                $value_to_decrypt = base64_decode($value);
                for ($i=0;  $i < strlen($value_to_decrypt); $i++)
                {
                    $encrypt_char = ord(substr($encryption_key,$i % strlen($encryption_key),1));
                    $key_char = ord(substr($key,$i % strlen($key),1));
                    $result .= chr($encrypt_char^$key_char^ord(substr($value_to_decrypt,$i,1)));
                }
            }
        }
        else
        {
            $result = $value;
        }
        return $result;
    }


    function SetMaxDelayedFailures($failures)
    {
        $this->_config_data['max_delayed_failures'] = $failures;
    }


    function GetMaxDelayedFailures()
    {
        return $this->_config_data['max_delayed_failures'];
    }


    function SetMaxDelayedTime($seconds)
    {
        $this->_config_data['failure_delayed_time'] = $seconds;
    }


    function GetMaxDelayedTime()
    {
        return $this->_config_data['failure_delayed_time'];
    }


    function SetActualVersion($value)
    {
        $this->_config_data['actual_version'] = $value;
    }


    function GetActualVersion()
    {
        return $this->_config_data['actual_version'];
    }


    /*********************************************************************
     *
     * Name: CreateUser
     * Short description: Create a new user
     *
     * Creation 2013-02-08
     * Update 2014-03-03
     * @package multiotp
     * @version 4.2.2
     * @author SysCo/al
     *
     * @param   string  $user      
     * @param   int     $prefix_pin_needed [-1|0|1]
     * @param   string  $algorithm
     * @param   string  $seed
     * @param   string  $pin
     * @param   string  $number_of_digits
     * @param   string  $time_interval_or_next_event
     * @param   string  $email
     * @param   string  $sms
     * @param   string  $description
     * @param   string  $group
     * @param   string  $token_algo_suite
     * @param   int     $activated [1|0]
     * @param   int     $synchronized [0|1]
     * @return  boolean
     *
     *********************************************************************/
    function CreateUser($user,
                        $prefix_pin_needed = -1,
                        $algorithm = 'totp',
                        $seed = '',
                        $pin = '',
                        $number_of_digits = 6,
                        $time_interval_or_next_event = -1,
                        $email = '',
                        $sms = '',
                        $description = '',
                        $group = '',
                        $token_algo_suite = '',
                        $activated = 1,
                        $synchronized = 0,
                        $ldap_pwd_needed = -1,
                        $automatically = FALSE
                       )
    {
        $result = FALSE;
        if ('' != trim($user))
        {
            if ((intval($ldap_pwd_needed) < 0) && (1 == $synchronized))
            {
                $request_ldap_pwd = $this->GetDefaultRequestLdapPwd();
            }
            else
            {
                $request_ldap_pwd = intval($ldap_pwd_needed);
            }
            if (intval($prefix_pin_needed) < 0)
            {
                $request_prefix_pin = $this->GetDefaultRequestPrefixPin();
            }
            else
            {
                $request_prefix_pin = intval($prefix_pin_needed);
            }
            if ($this->ReadUserData($user, TRUE, TRUE) || ('' == $user))
            {
                $result = FALSE; // ERROR: User already exists, or user is not set
                if ('' == $user)
                {
                    $this->WriteLog("Error: User is not set", FALSE, FALSE, 21, 'User', '');
                }
                else
                {
                    $this->WriteLog("Error: User ".$user." already exists", FALSE, FALSE, 22, 'User', $user);
                }
            }
            else
            {
                $this->SetUser($user);
                $this->SetUserPrefixPin($request_prefix_pin);
                $this->SetUserRequestLdapPassword($request_ldap_pwd);
                $this->SetUserAlgorithm($algorithm);
                $this->SetUserTokenAlgoSuite($token_algo_suite);

                $the_pin = $pin;
                if ('' == $the_pin)
                {
                    $the_pin = mt_rand(1000,9999);
                }
                $this->SetUserTokenNumberOfDigits($number_of_digits);

                /* This option is too long
                if (function_exists('openssl_random_pseudo_bytes')) {
                    $the_seed = (('' == $seed)?bin2hex(openssl_random_pseudo_bytes(20)):$seed);
                } else {
                */
                    $the_seed = (('' == $seed)?substr(md5(date("YmdHis").mt_rand(100000,999999)),0,20).substr(md5(mt_rand(100000,999999).date("YmdHis")),0,20):$seed);
                /* } */
                
                if ('hotp' == strtolower($algorithm))
                {
                    $next_event = ((-1 == $time_interval_or_next_event)?0:$time_interval_or_next_event);
                    $time_interval = 0;
                }
                else
                {
                    $next_event = 0;
                    $time_interval = ((-1 == $time_interval_or_next_event)?30:$time_interval_or_next_event);
                    if ("motp" == strtolower($algorithm))
                    {
                        // $the_seed = (('' == $seed)?substr(md5(date("YmdHis").mt_rand(100000,999999)),0,16):$seed);
                        $time_interval = 10;
                        if ((strlen($the_pin) < 4) || (0 == intval($the_pin)))
                        {
                            $the_pin = mt_rand(1000,9999);
                        }
                        $the_pin = substr($the_pin, 0, 4);
                    }
                }

                $this->SetUserPin($the_pin);
                $this->SetUserTokenSeed($the_seed);
                $this->SetUserTokenLastEvent($next_event - 1);
                $this->SetUserTokenTimeInterval($time_interval);
                
                $this_email = trim($email);
                if (('' == $this_email) && (FALSE !== strpos($user, '@')))
                {
                    $this_email = $user;
                }

                $this->SetUserEmail($this_email);
                $this->SetUserGroup(trim($group));
                $this->SetUserSms($sms);
                $this->SetUserDescription($description);
                $this->SetUserActivated($activated);
                $this->SetUserSynchronized($synchronized);
                $result = $this->WriteUserData($automatically); // WriteUserData write in the log file
            }
        }
        return $result;
    }


    /*********************************************************************
     * Name: CreateUserFromToken
     * Short description: Create a new user based on a token
     *
     * Creation 2013-02-17
     * Update 2013-12-23
     * @package multiotp
     * @version 4.1.0
     * @author SysCo/al
     *
     * @param   string  $user
     * @param   string  $token
     * @param   int     $email
     * @param   int     $sms
     * @param   string  $pin
     * @param   int     $prefix_pin_needed [0|1]
     * @param   string  $description
     * @param   string  $group
     * @return  int
     *********************************************************************/
    function CreateUserFromToken($user,
                                 $token,
                                 $email = '',
                                 $sms = '',
                                 $pin = '',
                                 $prefix_pin_needed = -1,
                                 $description = '',
                                 $group = '')
    {
        if (intval($prefix_pin_needed) < 0)
        {
            $request_prefix_pin = $this->GetDefaultRequestPrefixPin();
        }
        else
        {
            $request_prefix_pin = intval($prefix_pin_needed);
        }
        if ($this->ReadUserData($user, TRUE, TRUE) || ('' == $user))
        {
            $result = FALSE;
            if ('' == $user)
            {
                $this->WriteLog("Error: User is not set", FALSE, FALSE, 21, 'User', '');
            }
            else
            {
                $this->WriteLog("Error: User ".$user." already exists", FALSE, FALSE, 22, 'User', $user);
            }
        }
        elseif (!$this->ReadTokenData($token))
        {
            $result = FALSE;
            $this->WriteLog("Error: information about token ".$token." for user $user cannot be accessed", FALSE, FALSE, 29, 'Token', $token);
        }
        else
        {
            $this->AddTokenAttributedUsers($user);
            if (!$this->WriteTokenData())
            {
                $result = 28; // ERROR: Unable to write the changes in the file
                $this->WriteLog("Error: Unable to write the changes in the file for the token ".$this->GetToken(), FALSE, FALSE, $result, 'Token', $user);
            }
            else
            {
                $this->SetUser($user);
                $this->SetUserPrefixPin($request_prefix_pin);
                $this->SetUserKeyId($token);
                $this->SetUserTokenSerialNumber($token);
                $this->SetUserAlgorithm($this->GetTokenAlgorithm());
                $this->SetUserTokenAlgoSuite($this->GetTokenAlgoSuite());
                $this->SetUserTokenSeed($this->GetTokenSeed());
                $this->SetUserTokenNumberOfDigits($this->GetTokenNumberOfDigits());
                $this->SetUserTokenTimeInterval($this->GetTokenTimeInterval());
                $this->SetUserTokenLastEvent($this->GetTokenLastEvent());

                $the_pin = $pin;
                if ('' == $the_pin)
                {
                    $the_pin = mt_rand(1000,9999);
                }
                
                $this_email = trim($email);
                if (('' == $this_email) && (FALSE !== strpos($user, '@')))
                {
                    $this_email = $user;
                }
                
                $this->SetUserPin($the_pin);
                $this->SetUserEmail($this_email);
                $this->SetUserGroup(trim($group));
                $this->SetUserSms($sms);
                $this->SetUserDescription($description);
                
                $result = $this->WriteUserData(); // WriteUserData write in the log file
            }
        }
        return $result;
    }


    /**
     * @brief   Create the QRcode for the current user.
     *
     * @param   string  $user
     * @param   string  $display_name
     * @param   string  $file_name
     * @return  boolean or binary
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.0.6
     * @date    2013-08-25
     * @since   2013-02-17
     */
    function GetUserTokenQrCode($user = '', $display_name = '', $file_name = 'binary')
    {
        $result = FALSE;
        if (!function_exists('ImageCreate'))
        {
            $this->WriteLog("Error: PHP GD library is not installed", FALSE, FALSE, 299, 'System', '');
            return $result;
        }
        else
        {
            $data = $this->GetUserTokenUrlLink($user,$display_name);
            if($data)
            {
                $result = $this->qrcode($data, $file_name);
            }
            return $result;
        }
    }


    /**
     * @brief   Create the QRcode for the current token.
     *
     * @param   string  $token
     * @param   string  $display_name
     * @param   string  $file_name
     * @return  boolean or binary
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.1.1
     * @date    2014-01-19
     * @since   2013-02-18
     */
    function GetTokenQrCode($token = '', $display_name = '', $file_name = 'binary')
    {
        $result = FALSE;
        if (!function_exists('ImageCreate'))
        {
            $this->WriteLog("Error: PHP GD library is not installed", FALSE, FALSE, 299, 'System', '');
            return $result;
        }
        else
        {
            $data = $this->GetTokenUrlLink($token,$display_name);
            if($data)
            {
                $result = $this->qrcode($data, $file_name);
            }
            return $result;
        }
    }


    function GenerateHtmlQrCode($user = '', $alternate_html_template = '', $keep_qrcode_tags = FALSE)
    {
        $code_width=200;
        $code_height=200;

        if ('' != $user)
        {
            $this->SetUser($user);
        }

        $user = encode_utf8_if_needed($user);
        
        $descr = encode_utf8_if_needed($this->GetUserDescription());
        $descr = encode_utf8_if_needed(empty($descr) ? $user : $descr);

        if ('' != trim($alternate_html_template))
        {
            $html = $alternate_html_template;
        }
        else
        {
            // get template file
            $html = file_get_contents($this->GetTemplatesFolder().'template.html');
        }


        // Keep or clean LDAP information if not used
        // if ($this->IsUserSynchronized() && ('LDAP' == $this->GetUserSynchronizedChannel()) && $this->IsUserRequestLdapPasswordEnabled())
        if ($this->IsUserRequestLdapPasswordEnabled())
        {
            $request_ldap_pwd = TRUE;
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserLdapPwd\}\s*-->/', '', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserLdapPwd\}\s*-->/', '', $html);
        }
        else
        {
            $request_ldap_pwd = FALSE;
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserLdapPwd\}\s*-->/', ' -- {/IfMultiotpUserLdapPwd} -->', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserLdapPwd\}\s*-->/', '<!-- {/IfMultiotpUserLdapPwd} -- ', $html);
        }


        // Keep or clean pin information if not used
        if ($this->IsUserPrefixPin() && (!$request_ldap_pwd))
        {
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserPin\}\s*-->/', '', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserPin\}\s*-->/', '', $html);
        }
        else
        {
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserPin\}\s*-->/', ' -- {/IfMultiotpUserPin} -->', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserPin\}\s*-->/', '<!-- {/IfMultiotpUserPin} -- ', $html);
        }
        
        $token_serial = trim($this->GetUserTokenSerialNumber());
        if (('' == $token_serial) || (1 > strlen($token_serial)))
        {
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserTokenSerial\}\s*-->/', ' -- {/IfMultiotpUserTokenSerial} -->', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserTokenSerial\}\s*-->/', '<!-- {/IfMultiotpUserTokenSerial} -- ', $html);
        }
        else
        {
            $html = preg_replace('/<!--\s*\{\/IfMultiotpUserTokenSerial\}\s*-->/', '', $html);
            $html = preg_replace('/<!--\s*\{IfMultiotpUserTokenSerial\}\s*-->/', '', $html);
        }

        // Simplify current algorithm info
        $html = preg_replace('/IfMultiotpUserAlgorithm="[BCHIMOPTUY,]*'.strtoupper($this->GetUserAlgorithm()).'[BCHIMOPTUY,]*"}/', 'IfMultiotpUserAlgorithm="'.strtoupper($this->GetUserAlgorithm()).'"}', $html);


        // Clean other algorithms info
        foreach (explode("\t",$this->GetAlgorithmsList()) as $algorithm_one)
        {
            if (strtoupper($algorithm_one) != strtoupper($this->GetUserAlgorithm()))
            {
                $html = preg_replace('/<!--\s*\{\/IfMultiotpUserAlgorithm="[BCHIMOPTUY,]*'.strtoupper($algorithm_one).'[BCHIMOPTUY,]*"\}\s*-->/', ' -- {/IfMultiotpUserAlgorithm="DELETE"} -->', $html);
                $html = preg_replace('/<!--\s*\{IfMultiotpUserAlgorithm="[BCHIMOPTUY,]*'.strtoupper($algorithm_one).'[BCHIMOPTUY,]*"\}\s*-->/', '<!-- {IfMultiotpUserAlgorithm="DELETE"} -- ', $html);
            }
        }
        
        $html_cleaned = "";
        $html_slice = explode("-->",$html);
        foreach($html_slice as $one_slice)
        {
            $comment_pos = strpos($one_slice,'<!--');
            if(FALSE !== $comment_pos)
            {
                $html_cleaned.=substr($one_slice,0,$comment_pos);
            }
        }
        $html_cleaned .= end($html_slice);
        $html = $html_cleaned."\n";

        $html = str_replace('{MultiotpUserDescriptionUC}', strtoupper($descr), $html);
        $html = str_replace('{MultiotpUserDescription}', $descr, $html);

        $html = str_replace('{MultiotpUserAccount}', $user, $html);                    
        $html = str_replace('{MultiotpUserPin}', $this->GetUserPin(), $html);
        $html = str_replace('{MultiotpUserAlgorithm}', strtoupper($this->GetUserAlgorithm()), $html);
        $html = str_replace('{MultiotpUserTokenSeed}', $this->GetUserTokenSeed(), $html);
        $html = str_replace('{MultiotpUserTokenSeedBase32}', base32_encode(hex2bin($this->GetUserTokenSeed())), $html);
        $html = str_replace('{MultiotpUserTokenNumberOfDigits}', $this->GetUserTokenNumberOfDigits(), $html);
        $html = str_replace('{MultiotpUserTokenTimeInterval}', $this->GetUserTokenTimeInterval(), $html);
        $html = str_replace('{MultiotpUserTokenNextEvent}', 1+$this->GetUserTokenLastEvent(), $html);
        $html = str_replace('{MultiotpUserTokenSerial}', $token_serial, $html);

        $regex_url='/\surl=(.*?)[\}\s}]/';
        $regex_format='/\sformat=\"?([^\"\}]*)\"?.*\}/';
        $regex_w='/\swidth=(.*?)[\}\s]/';
        $regex_h='/\sheight=(.*?)[\}\s]/';

        // Date and time replacement
        $regex_tag='/\{MultiotpDateTime(.*)\}/';
        $format = "Y-m-d H:i:s";
        if(preg_match_all($regex_tag, $html, $matches))
        {
            foreach ($matches[0] as $item)
            {
                if(!empty($item))
                {
                    if(preg_match($regex_format, $item, $values))
                    {
                        $format = $values[1];
                    }
                    $html = str_replace($item, date($format), $html);
                }
            }
        }

        if (!$keep_qrcode_tags)
        {
            // Smartphone apps qrcode
            $regex_tag='/\{MultiotpQrCodeUrl\s(.*?)\}/';
            if(preg_match_all($regex_tag, $html, $matches))
            {
                foreach ($matches[0] as $item) {
                    $url = '';
                    $w = $code_width;
                    $h = $code_height;
                    if(!empty($item))
                    {
                        if(preg_match($regex_url, $item, $values))
                        {
                            $url= str_replace('"', '', explode('=', $values[0],2));
                            $url = $url[1];
                        }
                        if(preg_match($regex_w, $item, $values))
                        {
                            $w = str_replace('"', '', explode('=', $values[0],2));
                            $w = trim(str_replace('}', '', $w[1]));
                        }
                        if(preg_match($regex_h, $item, $values))
                        {
                            $h = str_replace('"', '', explode('=', $values[0],2));
                            $h = trim(str_replace('}', '', $h[1]));
                        }
                        $html = str_replace($item, "<a id=\"QrCodeUrl\" href=\"".$url."\" target=\"blank\"><img border=\"0\" width=\"".$w."\" height=\"".$h."\" src=\"data:image/png;base64,".base64_encode($this->qrcode($url, 'binary'))."\" /></a>", $html);
                    }
                }
            }
            // User token qrcode
            $regex_tag='/\{MultiotpQrCodeUserToken\s(.*?)\}/';

            if(preg_match_all($regex_tag, $html, $matches))
            {
                foreach ($matches[0] as $item)
                {
                    $url = $this->GetUserTokenUrlLink($user, $descr);
                    $w = $code_width;
                    $h = $code_height;
                    if(!empty($item))
                    {
                        if(preg_match($regex_w, $item, $values))
                        {
                            $w = str_replace('"', '', explode('=', $values[0],2));
                            $w = trim(str_replace('}', '', $w[1]));
                        }
                        if(preg_match($regex_h, $item, $values))
                        {
                            $h = str_replace('"', '', explode('=', $values[0],2));
                            $h = trim(str_replace('}', '', $h[1]));
                        }
                        $html = str_replace($item, "<a id=\"QrCodeUserToken\" href=\"".$url."\" target=\"blank\"><img border=\"0\" width=\"".$w."\" height=\"".$h."\" src=\"data:image/png;base64,".base64_encode($this->qrcode($url, 'binary'))."\"></a>", $html);
                    }
                }
            }
        }
        
        return $html;
    }


    /*********************************************************************
     *
     * Name: GetUserTokenUrlLink
     * Short description: Create the Urllink for the current user
     *
     * Creation 2013-04-29
     * Update 2013-04-29
     * @package multiotp
     * @version 1.0.0
     * @author SysCo/al
     *
     * @param   string  $user
     * @param   string  $display_name
     * @return  boolean (FALSE) or string
     *
     *********************************************************************/
    function GetUserTokenUrlLink($user = '', $display_name = '')
    {
        $result = false;
        
        $user_array = $this->ReadUserDataArray(('' != $user)?$user:$this->GetUser());
        if (false !== $user_array) {
            $the_user       = $user;
            $description    = $user_array['description'];
            $q_algorithm    = $user_array['algorithm'];
            $q_algo_suite   = $user_array['token_algo_suite'];
            $q_period       = $user_array['time_interval'];
            $q_digits       = $user_array['number_of_digits'];
            $q_seed         = $user_array['token_seed'];
            $q_counter      = $user_array['last_event'] + 1;
            $q_display_name = (('' != $display_name)?$display_name:(('' != $description)?$description:$the_user));
            $q_issuer       = $this->GetIssuer();
            switch (strtolower($q_algorithm)) {
                case 'totp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.rawurlencode($q_issuer);
                    break;
                case 'hotp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&counter='.$q_counter.'&issuer='.rawurlencode($q_issuer);
                    break;
                case 'motp':
                    $result = 'motp://'.rawurlencode($q_issuer).'/'.rawurlencode($q_display_name).'?secret='.$q_seed;
                    break;
                /*
                case 'token2':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.$q_issuer;
                    break;
                case 'motp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.$q_issuer;
                    break;
                */
                
                default:
                    // $result = FALSE;
                    $result = 'http://motp.sourceforge.net/no_qrcode_compatible_client_for_this_algorithm';
                    $this->WriteLog("Error: No known URL compatible client for this algorithm", FALSE, FALSE, 23, 'System', '');
            }
        } else {
            // $result = '';
        }
        return $result;
    }


    /**
     * @brief   Create the Urllink for the current token
     *
     * @param   string  $token
     * @param   string  $display_name
     * @return  boolean (FALSE) or string
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.1.1
     * @date    2014-01-19
     * @since   2014-01-19
     */
    function GetTokenUrlLink($token = '', $display_name = '')
    {
        $result = FALSE;
        if ('' != $token)
        {
            $this->SetToken($token);
        }

        if ($this->ReadTokenData())
        {
            $the_token      = $this->GetToken();
            $q_algorithm    = $this->GetTokenAlgorithm();
            $q_algo_suite   = $this->GetTokenAlgoSuite();
            $q_period       = $this->GetTokenTimeInterval();
            $q_digits       = $this->GetTokenNumberOfDigits();
            $q_seed         = $this->GetTokenSeed();
            $q_counter      = $this->GetTokenLastEvent() + 1;
            $q_display_name = (('' != $display_name)?$display_name:$the_token);
            $q_issuer       = $this->GetTokenIssuer();

            switch (strtolower($q_algorithm))
            {
                case 'totp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.rawurlencode($q_issuer);
                    break;
                case 'hotp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&counter='.$q_counter.'&issuer='.rawurlencode($q_issuer);
                    break;
                case 'motp':
                    $result = 'motp://'.rawurlencode($q_issuer).'/'.rawurlencode($q_display_name).'?secret='.$q_seed;
                    break;
                /*
                case 'token2':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.$q_issuer;
                    break;
                case 'motp':
                    $result = 'otpauth://'.$q_algorithm.'/'.rawurlencode($q_display_name).'?secret='.base32_encode(hex2bin($q_seed)).'&digits='.$q_digits.'&period='.$q_period.'&issuer='.$q_issuer;
                    break;
                */
                default:
                    // $result = FALSE;
                    $result = 'http://http://motp.sourceforge.net/no_qrcode_compatible_client_for_this_algorithm';
                    $this->WriteLog("Error: No known URL compatible client for this algorithm", FALSE, FALSE, 23, 'System', '');
            }
        }
        else
        {
            // $result = '';
        }
        return $result;
    }


    /*********************************************************************
     *
     * Name: FastCreateUser
     * Short description: Quickly create a new user with a new token (GA compatible)
     *
     * Creation 2013-02-16
     * Update 2014-03-03
     * @package multiotp
     * @version 4.2.2
     * @author SysCo/al
     *
     * @param   string  $user      
     * @param   string  $email
     * @param   string  $sms
     * @param   int     $prefix_pin_needed [-1|0|1]
     * @param   string  $algorithm [totp|hotp|motp]
     * @param   int     $activated [1|0]
     * @param   string  $description
     * @param   string  $group
     * @param   int     $synchronized [0|1]
     * @param   string  $pin
     * @param   boolean $automatically         Process is done automatically  
     * @param   string  $synchronized_channel 
     * @param   string  $synchronized_server
     * @param   string  $synchronized_dn
     * @param   string  $ldap_pwd_needed
     * @return  boolean
     *
     *********************************************************************/
    function FastCreateUser($user,
                            $email = '',
                            $sms = '',
                            $prefix_pin_needed = -1,
                            $algorithm = "totp",
                            $activated=1,
                            $description = "",
                            $group = "*DEFAULT*",
                            $synchronized = 0,
                            $pin = '',
                            $automatically = false,
                            $synchronized_channel = '',
                            $synchronized_server = '',
                            $synchronized_dn = '',
                            $ldap_pwd_needed = -1
                           )
    {
        $result = FALSE;
        if ('' != trim($user))
        {
            if ($this->ReadUserData($user, TRUE, TRUE) || ('' == $user))
            {
                $this->WriteLog("Error: Unable to create the user ".$user." because it already exists", FALSE, FALSE, 22, 'User', $user);
            }
            else
            {
                if ((intval($ldap_pwd_needed) < 0) && (1 == $synchronized))
                {
                    $request_ldap_pwd = $this->GetDefaultRequestLdapPwd();
                }
                else
                {
                    $request_ldap_pwd = intval($ldap_pwd_needed);
                }
                                   
                if (intval($prefix_pin_needed) < 0)
                {
                    $prefix_required = $this->GetDefaultRequestPrefixPin();
                }
                else
                {
                    $prefix_required = intval($prefix_pin_needed);
                }
            
                $this->SetUser($user, false); // This will do also an automatic reset of the user array

                $this->SetUserEmail($email);
                $this->SetUserDescription($description);
                $this->SetUserGroup(('*DEFAULT*' == $group)?$this->GetDefaultUserGroup():$group);
                $this->SetUserSms($sms);
                $this->SetUserAlgorithm($algorithm);
                
                $this->SetUserTokenAlgoSuite(''); // Default algorithm suite (HMAC-SHA1)
                $the_pin = $pin;
                if ('' == $the_pin)
                {
                    $the_pin = mt_rand(1000,9999);
                }
                $this->SetUserPrefixPin($prefix_required);
                $this->SetUserTokenNumberOfDigits(6);
                $next_event = 0;

                /* This option is too long
                if (function_exists('openssl_random_pseudo_bytes')) {
                    $seed = bin2hex(openssl_random_pseudo_bytes(20));
                } else {
                */
                    $seed = substr(md5(date("YmdHis").mt_rand(100000,999999)),0,20).substr(md5(mt_rand(100000,999999).date("YmdHis")),0,20);
                /* } */

                if ("totp" == strtolower($algorithm))
                {
                    $time_interval = 30;
                }
                elseif ("motp" == strtolower($algorithm))
                {
                    $seed = substr($seed,0,16);
                    $time_interval = 10;
                    if ((strlen($the_pin) < 4) || (0 == intval($the_pin)))
                    {
                        $the_pin = mt_rand(1000,9999);
                    }
                }
                else
                {
                    $time_interval = 0;
                }

                $this->SetUserPin($the_pin);
                $this->SetUserTokenSeed($seed);
                $this->SetUserTokenLastEvent($next_event-1);
                $this->SetUserTokenTimeInterval($time_interval);

                $this->SetUserActivated($activated);

                $this->SetUserSynchronized($synchronized);

                if (($automatically) && (1 == $synchronized))
                {
                    $this->SetUserSynchronizedTime();
                    $this->SetUserSynchronizedChannel($synchronized_channel);
                    $this->SetUserSynchronizedServer($synchronized_server);
                    $this->SetUserSynchronizedDn($synchronized_dn);
                }

                $this->SetUserRequestLdapPassword($request_ldap_pwd);

                $result = $this->WriteUserData($automatically); // WriteUserData write in the log file
            }
        }
        return $result;
    }


    function SetUser($user, $auto_read_data = true)
    {
        if ('' != $user)
        {
            if ($user != $this->GetUser())
            {
                $this->ResetUserArray();
                $this->_user = $user;
                if (!$this->IsCaseSensitiveUsers())
                {
                    $this->_user = strtolower($this->_user);
                }
                if ($auto_read_data) {
                    $this->ReadUserData('', false); // First parameter empty, otherwise it will loop with SetUser !
                }
            }
        }
        else
        {
            $this->ResetUserArray();
        }
    }


    function RenameCurrentUser($new_user, $no_error_info = FALSE)
    {
        $esc_actual = escape_mysql_string($this->GetUser());
        $esc_new    = escape_mysql_string($new_user);
        $result = FALSE;
        if ($this->CheckUserExists($new_user)) // Check if the new user already exists
        {
            $this->WriteLog("Error: Unable to rename the current user ".$this->GetUser()." to $new_user because $new_user already exists", FALSE, FALSE, 22, 'User');
        }
        else
        {
            if ($this->CheckUserExists()) // Check if the current user already exists
            {
                if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
                {
                    switch ($this->GetBackendType())
                    {
                        case 'mysql':
                            if ($this->OpenMysqlDatabase())
                            {
                                if ('' != $this->_config_data['sql_users_table'])
                                {
                                    $sQuery = "UPDATE `".$this->_config_data['sql_users_table']."` SET user='".strtolower($esc_new)."' WHERE `user`='".$esc_actual."'";
                                    
                                    if (is_object($this->_mysqli))
                                    {
                                        if (!($rResult = $this->_mysqli->query($sQuery)))
                                        {
                                            if (!$no_error_info)
                                            {
                                                $this->WriteLog("Error: Could not rename the user ".$this->GetUser().": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'User');
                                            }
                                        }
                                        else
                                        {
                                            $num_rows = $this->_mysqli->affected_rows;
                                        }
                                    }
                                    elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                    {
                                        if (!$no_error_info)
                                        {
                                            $this->WriteLog("Error: Could not rename the user ".$this->GetUser().": ".mysql_error(), FALSE, FALSE, 28, 'User');
                                        }
                                    }
                                    else
                                    {
                                        $num_rows = mysql_affected_rows($this->_mysql_database_link);
                                    }
                                    
                                    if (0 == $num_rows)
                                    {
                                        $this->WriteLog("Error: Could not rename the user ".$this->GetUser().". User does not exist", FALSE, FALSE, 21, 'User');
                                    }
                                    else
                                    {
                                        $this->WriteLog("Info: User ".$this->GetUser()." successfully renamed to $new_user", FALSE, FALSE, 11, 'User');
                                        $result = TRUE;
                                    }
                                }
                            }
                            break;
                        case 'files':
                        default:
                            $old_user_filename = strtolower(str_replace('/','',$this->GetUser())).'.db';
                            $new_user_filename = strtolower(str_replace('/','',$new_user)).'.db';
                            rename($this->GetUsersFolder().$old_user_filename, $this->GetUsersFolder().$new_user_filename);
                            $result = TRUE;
                            break;
                    }
                }
            }
            if ($result)
            {
                $this->_user = strtolower($new_user);
            }
        }
        return $result;
    }


    function GetUser()
    {
        return $this->_user;
    }


    // Check if user exists (locally only)
    function CheckUserExists($user = '', $no_server_check = FALSE, $no_error = FALSE)
    {
        $check_user = ('' != $user)?$user:$this->GetUser();
        $result = FALSE;

        if ('' != trim($check_user))
        {
            $server_result = -1;
            if ((!$no_server_check) && ('' != $this->GetServerUrl()))
            {
                $server_result = $this->CheckUserExistsOnServer($check_user);
                if (22 == $server_result)
                {
                    // We return only if the user exists, so we check also the local one
                    $result = TRUE;
                    return $result;
                }
            }

            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_users_table']."` WHERE `user` = '{$check_user}'";
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                if (!$no_error)
                                {
                                    $this->WriteLog("Error: User ".$check_user." does not exist", FALSE, FALSE, 299, 'System', '');
                                }
                                $result = FALSE;
                            }
                            else
                            {
                                $result = TRUE;
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $user_filename = str_replace('/','',$check_user).'.db';
                        if (!$this->IsCaseSensitiveUsers())
                        {
                            $user_filename = strtolower($user_filename);
                        }
                        $result = file_exists($this->GetUsersFolder().$user_filename);
                        break;
                }
            }
        }
        return $result;
    }


    function LockUser($user = '')
    {
        $result = FALSE;
        if ('' != $user)
        {
            $this->SetUser($user, false);
        }
        if ($this->ReadUserData('', FALSE, TRUE)) // LOCALLY ONLY, not on the server if any
        {
            $this->SetUserLocked(1);
            if ($this->GetVerboseFlag())
            {
                $this->WriteLog("Info: *User ".$this->GetUser()." successfully locked", FALSE, FALSE, 19, 'User');
            }
            $this->WriteUserData();
            $result = TRUE;
        }
        return $result;
    }


    function UnlockUser($user = '')
    {
        $result = FALSE;
        if ('' != $user)
        {
            $this->SetUser($user, false);
        }
        if ($this->ReadUserData('', FALSE, TRUE)) // LOCALLY ONLY, not on the server if any
        {
            $this->SetUserErrorCounter(0);
            $this->SetUserLocked(0);
            if ($this->GetVerboseFlag())
            {
                $this->WriteLog("Info: *User ".$this->GetUser()." successfully unlocked", FALSE, FALSE, 19, 'User');
            }
            $this->WriteUserData();
            $result = TRUE;
        }
        return $result;
    }


    function DeleteUser($user = '', $no_error_info = FALSE)
    {
        if ('' != $user)
        {
            $this->SetUser($user, false);
        }
        
        $result = FALSE;
        
        // First, we delete the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $user_filename = str_replace('/','',$this->GetUser()).'.db';
            if (!$this->IsCaseSensitiveUsers())
            {
                $user_filename = strtolower($user_filename);
            }
            if (!file_exists($this->GetUsersFolder().$user_filename))
            {
                if (!$no_error_info)
                {
                    if ($this->GetVerboseFlag())
                    {
                        $this->WriteLog("Error: *Unable to delete user ".$this->GetUser().", the users database file ".$this->GetUsersFolder().$user_filename." does not exist", FALSE, FALSE, 21, 'User');
                    }
                    else
                    {
                        $this->WriteLog("Error: Unable to delete user ".$this->GetUser(), FALSE, FALSE, 29, 'User');
                    }
                }
            }
            else
            {
                $result = unlink($this->GetUsersFolder().$user_filename);
                if ($result)
                {
                    if ($this->GetVerboseFlag())
                    {
                        $this->WriteLog("Info: *User ".$this->GetUser()." successfully deleted", FALSE, FALSE, 12, 'User');
                    }
                }
                elseif (!$this->GetMigrationFromFile())
                {
                    if (!$no_error_info)
                    {
                        $this->WriteLog("Error: Unable to delete user ".$this->GetUser(), FALSE, FALSE, 28, 'User');
                    }
                }
            }
        }

        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_users_table'])
                        {
                            $sQuery  = "DELETE FROM `".$this->_config_data['sql_users_table']."` WHERE `user` = '".$this->_user."'";
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    if (!$no_error_info)
                                    {
                                        $this->WriteLog("Error: Could not delete user ".$this->GetUser().": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'User');
                                    }
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete user ".$this->GetUser().": ".mysql_error(), FALSE, FALSE, 28, 'User');
                                }
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete user ".$this->GetUser().". User does not exist", FALSE, FALSE, 21, 'User');
                                }
                            }
                            else
                            {
                                if ($this->GetVerboseFlag())
                                {
                                    $this->WriteLog("Info: *User ".$this->GetUser()." successfully deleted", FALSE, FALSE, 12, 'User');
                                }
                                $result = TRUE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }                        
        }
        
        foreach(explode("\t", $this->GetTokensList()) as $one_token)
        {
            if ($this->RemoveTokenAttributedUsers($one_token, $this->GetUser()))
            {
                $this->WriteTokenData();
            }
        }
        
        return $result;
    }


    function GetUsersCount()
    {
        if (($this->IsCacheData()) && (intval($this->ReadCacheValue('users_count')) >= 0))
        {
            $users_count = intval($this->ReadCacheValue('users_count'));
        }
        else
        {
            $users_count = 0;
            switch ($this->GetBackendType())
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        $sQuery  = "SELECT user FROM `".$this->_config_data['sql_users_table']."` ";
                        
                        if (is_object($this->_mysqli))
                        {
                            if (!($result = $this->_mysqli->query($sQuery)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                            else
                            {
                                while ($aRow = $result->fetch_assoc())
                                {
                                    $users_count++;
                                }
                            }
                        }
                        else
                        {
                            if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                while ($aRow = mysql_fetch_assoc($rResult))
                                {
                                    $users_count++;
                                }                         
                            }
                        }
                    }
                    break;
                case 'files':
                default:
                    if ($users_handle = @opendir($this->GetUsersFolder()))
                    {
                        while ($file = readdir($users_handle))
                        {
                            if ((substr($file, -3) == ".db") && ($file != '.db'))
                            {
                                $users_count++;
                            }
                        }
                        closedir($users_handle);
                    }
            }
            if (($this->IsCacheData()) && ($users_count >= 0))
            {
                $this->WriteCacheValue('users_count', $users_count);
                $this->WriteCacheData();
            }
        }
        return $users_count;
    }


    function ReadUserDataArray($user = '', $create = false, $no_server_check = false)
    {
        $array_user = ('' != $user)?$user:$this->GetUser();
        $result = false;

        // We reset all values (we know the key based on the schema)
        $temp_user_array = $this->ResetTempUserArray();

        // First, we read the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $user_filename = str_replace('/','',$array_user).'.db';
            if (!$this->IsCaseSensitiveUsers())
            {
                $user_filename = strtolower($user_filename);
            }
            if (!file_exists($this->GetUsersFolder().$user_filename))
            {
                if (!$create)
                {
                    $this->WriteLog("Error: database file ".$this->GetUsersFolder().$user_filename." for user ".$array_user." does not exist", FALSE, FALSE, 21, 'System', '');
                }
            }
            else
            {
                $temp_user_array['multi_account'] = 0;
                $temp_user_array['time_interval'] = 0;
                
                $file_handler = fopen($this->GetUsersFolder().$user_filename, "rt");
                $first_line = trim(fgets($file_handler));
                $v3 = (false !== strpos(strtolower($first_line),"multiotp-database-format-v3"));
                
                // First version format support
                if (false === strpos(strtolower($first_line),"multiotp-database-format")) {
                    $temp_user_array['algorithm']          = $first_line;
                    $temp_user_array['token_seed']         = trim(fgets($file_handler));
                    $temp_user_array['user_pin']           = trim(fgets($file_handler));
                    $temp_user_array['number_of_digits']   = trim(fgets($file_handler));
                    $temp_user_array['last_event']         = intval(trim(fgets($file_handler)) - 1);
                    $temp_user_array['request_prefix_pin'] = intval(trim(fgets($file_handler)));
                    $temp_user_array['last_login']         = intval(trim(fgets($file_handler)));
                    $temp_user_array['error_counter']      = intval(trim(fgets($file_handler)));
                    $temp_user_array['locked']             = intval(trim(fgets($file_handler)));
                } else {
                    while (!feof($file_handler)) {
                        $line = trim(fgets($file_handler));
                        $line_array = explode("=",$line,2);
                        if ($v3) { // v3 format, only tags followed by := instead of = are encrypted
                            if (":" == substr($line_array[0], -1)) {
                                $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                            }
                        } else { // v2 format, only defined tags are encrypted
                            if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$line_array[0].'*'))) {
                                $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                            }
                        }
                        if ('' != trim($line_array[0])) {
                            $temp_user_array[strtolower($line_array[0])] = $line_array[1];
                        }
                    }
                }
                fclose($file_handler);
                $result = true;
                if ('' != $temp_user_array['encryption_hash']) {
                    if ($temp_user_array['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey())) {
                        $temp_user_array['encryption_hash'] = "ERROR";
                        $this->WriteLog("Error: the user information encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                        $result = false;
                    }
                }
            }
        }


        // And now, we override the values if another backend type is defined
        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_users_table'])
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_users_table']."` WHERE `user` = '".$array_user."'";
                            $aRow = NULL;
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".trim($this->_mysqli->error).' ', TRUE, FALSE, 199, 'System', '');
                                    $result = false;
                                }
                                else
                                {
                                    $aRow = $rResult->fetch_assoc();
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                                    $result = false;
                                }
                                else
                                {
                                    $aRow = mysql_fetch_assoc($rResult);
                                }
                            }

                            if (NULL != $aRow)
                            {
                                $result = false;
                                while(list($key, $value) = @each($aRow))
                                {
                                    $in_the_schema = FALSE;
                                    reset($this->_sql_tables_schema['users']);
                                    while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['users']))
                                    {
                                        if ($valid_key == $key)
                                        {
                                            $in_the_schema = TRUE;
                                        }
                                    }
                                    if (($in_the_schema) && ($key != 'user'))
                                    {
                                        if (('ENC:' == substr($value,0,4)) && (':ENC' == substr($value,-4)))
                                        {
                                            $value = substr($value,4);
                                            $value = substr($value,0,strlen($value)-4);
                                            $temp_user_array[$key] = $this->Decrypt($key,$value,$this->GetEncryptionKey());
                                        }
                                        else
                                        {
                                            $temp_user_array[$key] = $value;
                                        }
                                    }                                    
                                    elseif ((!$in_the_schema) && ('unique_id' != $key)  && $this->GetVerboseFlag())
                                    {
                                        $this->WriteLog("Warning: *The key ".$key." is not in the users database schema", FALSE, FALSE, 98, 'System', '');
                                    }
                                    $result = true;
                                }
                                if(0 == count($aRow) && !$create)
                                {
                                    $this->WriteLog("Error: SQL database entry for user ".$array_user." does not exist", FALSE, FALSE, 299, 'System', '');
                                }
                            }
                        }
                        if ('' != $temp_user_array['encryption_hash'])
                        {
                            if ($temp_user_array['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                            {
                                $temp_user_array['encryption_hash'] = "ERROR";
                                $this->WriteLog("Error: the users mysql encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                                $result = false;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }
        }

        // And now, we do the ReadUserData online on the server
        $server_result = -1;
        if ((!$no_server_check) && ('' != $this->GetServerUrl()))
        {
            $server_result = $this->ReadUserDataOnServer($array_user);
            if (20 < strlen($server_result))
            {
                $temp_user_array['encryption_hash'] = $this->CalculateControlHash($this->GetEncryptionKey());
                $server_array = explode("\n",$server_result);
                $server_result = 19;

                foreach ($server_array as $one_line)
                {
                    $line = trim($one_line);
                    $line_array = explode("=",$line,2);
                    if (":" == substr($line_array[0], -1))
                    {
                        $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                        $line_array[1] = $this->Decrypt($line_array[0], $line_array[1], $this->GetServerSecret());
                    }
                    if ('' != trim($line_array[0]))
                    {
                        if ('encryption_hash' != strtolower($line_array[0]))
                        {
                            $temp_user_array[strtolower($line_array[0])] = $line_array[1];
                        }
                    }
                }
                $result = true;
            }
        }

        if (false !== $result) {
            return $temp_user_array;
        } else {
            return false;
        }
    }


    function ReadUserData($user = '', $create = FALSE, $no_server_check = FALSE)
    {
        if ('' != $user) {
            $this->SetUser($user, false);
        }
        $result = false;
        $temp_user_array = $this->ReadUserDataArray($user, $create, $no_server_check);
        if (false !== $temp_user_array) {
            $this->_user_data = $temp_user_array;
            $result = true;
        } else {
            $this->_user_data = $this->ResetUserArray();
        }

        $this->SetUserDataReadFlag($result);
        return $result;
    }


    function WriteUserData(
        $automatically = false,
        $update_last_change = true
    ) {
        if ('' == trim($this->GetUser())) {
            $result = false;
        } else {
            $result = $this->WriteData('User',
                                       'users',
                                       $this->GetUsersFolder(),
                                       $this->_user_data,
                                       false,
                                       'user',
                                       $this->GetUser(),
                                       $this->IsCaseSensitiveUsers(),
                                       $automatically,
                                       $update_last_change
                                      );
        }
        return $result;
    }


    function GetUsersList()
    {
        return $this->GetList('user', 'sql_users_table', $this->GetUsersFolder());
    }


    function GetLockedUsersList($limit = 0)
    {
        if (($this->IsCacheData()) && (($this->ReadCacheValue('locked_users_list')) != '-1'))
        {
            $locked_users_list = ($this->ReadCacheValue('locked_users_list'));
        }
        else
        {
            $locked_users_list = '';
            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT user FROM `".$this->_config_data['sql_users_table']."` WHERE (`locked` = 1) ORDER BY user ASC";
                            if ($limit > 0)
                            {
                                $sQuery.= " LIMIT 0,".$limit;
                            }
                            if (is_object($this->_mysqli))
                            {
                                if (!($result = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    while ($aRow = $result->fetch_assoc())
                                    {
                                        if ('' != $aRow['user'])
                                        {
                                            $locked_users_list.= (('' != $locked_users_list)?"\t":'').$aRow['user'];
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    while ($aRow = mysql_fetch_assoc($rResult))
                                    {
                                        if ('' != $aRow['user'])
                                        {
                                            $locked_users_list.= (('' != $locked_users_list)?"\t":'').$aRow['user'];
                                        }
                                    }                         
                                }
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $locked_users_count = 0;
                        $active_users_count = 0;
                        $users_count = 0;
                        if ($users_handle = @opendir($this->GetUsersFolder()))
                        {
                            while ($file = readdir($users_handle))
                            {
                                $locked = FALSE;
                                $desactivated = FALSE;
                                if ((substr($file, -3) == ".db") && ($file != '.db'))
                                {
                                    $current_user = substr($file,0,-3);
                                    $file_handler = fopen($this->GetUsersFolder().$file, "rt");
                                    $first_line = trim(fgets($file_handler));
                                    $v3 = (FALSE !== strpos(strtolower($first_line),"multiotp-database-format-v3"));
                                    if (FALSE !== strpos(strtolower($first_line),"multiotp-database-format")) // Format V3
                                    {
                                        while (!feof($file_handler))
                                        {
                                            $line = trim(fgets($file_handler));
                                            $line_array = explode("=",$line,2);
                                            if ($v3) // v3 format, only tags followed by := instead of = are encrypted
                                            {
                                                if (":" == substr($line_array[0], -1))
                                                {
                                                    $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            else // v2 format, only defined tags are encrypted
                                            {
                                                if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$line_array[0].'*')))
                                                {
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            if ('locked' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $locked = TRUE;
                                                }
                                            }
                                            if ('desactivated' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $desactivated = TRUE;
                                                }
                                            }
                                        }
                                    }
                                    fclose($file_handler);
                                    $users_count++;
                                    
                                    if ($locked)
                                    {
                                        $locked_users_list.= (('' != $locked_users_list)?"\t":'').$current_user;
                                        $locked_users_count++;
                                    }
                                    if (!$desactivated)
                                    {
                                        $active_users_count++;
                                    }
                                }
                                if (($limit > 0) && (locked_users_count >= $limit))
                                {
                                    break;
                                }
                            }
                            closedir($users_handle);
                            
                            if (($limit <= 0) && ($this->IsCacheData()))
                            {
                                $this->WriteCacheValue('locked_users_list', $locked_users_list);
                                if ($locked_users_count >= 0)
                                {
                                    $this->WriteCacheValue('locked_users_count', $locked_users_count);
                                }
                                if ($active_users_count >= 0)
                                {
                                    $this->WriteCacheValue('active_users_count', $active_users_count);
                                }
                                if ($users_count >= 0)
                                {
                                    $this->WriteCacheValue('users_count', $users_count);
                                }
                                $this->WriteCacheData();
                            }
                            
                        }
                }
            }
        }
        return $locked_users_list;
    }


    function GetLockedUsersCount()
    {
        if (($this->IsCacheData()) && (intval($this->ReadCacheValue('locked_users_count')) >= 0))
        {
            $locked_users_count = intval($this->ReadCacheValue('locked_users_count'));
        }
        else
        {
            $locked_users_count = 0;
            $active_users_count = -1;
            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT COUNT(user) AS counter FROM `".$this->_config_data['sql_users_table']."` WHERE (`locked` = 1)";
                            if (is_object($this->_mysqli))
                            {
                                if (!($result = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    if ($aRow = $result->fetch_assoc())
                                    {
                                        $locked_users_count = $aRow['counter'];
                                    }
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    if ($aRow = mysql_fetch_assoc($rResult))
                                    {
                                        $locked_users_count = $aRow['counter'];
                                    }
                                }
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $active_users_count = 0;
                        $users_count = 0;
                        if ($users_handle = @opendir($this->GetUsersFolder()))
                        {
                            while ($file = readdir($users_handle))
                            {
                                $locked = FALSE;
                                $desactivated = FALSE;
                                if ((substr($file, -3) == ".db") && ($file != '.db'))
                                {
                                    $current_user = substr($file,0,-3);
                                    $file_handler = fopen($this->GetUsersFolder().$file, "rt");
                                    $first_line = trim(fgets($file_handler));
                                    $v3 = (FALSE !== strpos(strtolower($first_line),"multiotp-database-format-v3"));
                                    if (FALSE !== strpos(strtolower($first_line),"multiotp-database-format")) // Format V3
                                    {
                                        while (!feof($file_handler))
                                        {
                                            $line = trim(fgets($file_handler));
                                            $line_array = explode("=",$line,2);
                                            if ($v3) // v3 format, only tags followed by := instead of = are encrypted
                                            {
                                                if (":" == substr($line_array[0], -1))
                                                {
                                                    $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            else // v2 format, only defined tags are encrypted
                                            {
                                                if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$line_array[0].'*')))
                                                {
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            if ('locked' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $locked = TRUE;
                                                }
                                            }
                                            if ('desactivated' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $desactivated = TRUE;
                                                }
                                            }
                                        }
                                    }
                                    fclose($file_handler);
                                    $users_count++;
                                    
                                    if ($locked)
                                    {
                                        $locked_users_count++;
                                    }
                                    if (!$desactivated)
                                    {
                                        $active_users_count++;
                                    }
                                }
                            }
                            closedir($users_handle);
                        }
                }
            }
            if ($this->IsCacheData())
            {
                if ($locked_users_count >= 0)
                {
                    $this->WriteCacheValue('locked_users_count', $locked_users_count);
                }
                if ($active_users_count >= 0)
                {
                    $this->WriteCacheValue('active_users_count', $active_users_count);
                }
                if ($users_count >= 0)
                {
                    $this->WriteCacheValue('users_count', $users_count);
                }
                $this->WriteCacheData();                
            }
        }
        return $locked_users_count;
    }


    function GetActiveUsersList($limit = 0)
    {
        $list = '';
        if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
        {
            switch ($this->GetBackendType())
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        $sQuery  = "SELECT user FROM `".$this->_config_data['sql_users_table']."` WHERE (`desactivated` = 0) ORDER BY user ASC";
                        if ($limit > 0)
                        {
                            $sQuery.= " LIMIT 0,".$limit;
                        }
                        if (is_object($this->_mysqli))
                        {
                            if (!($result = $this->_mysqli->query($sQuery)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                            else
                            {
                                while ($aRow = $result->fetch_assoc())
                                {
                                    if ('' != $aRow['user'])
                                    {
                                        $list.= (('' != $list)?"\t":'').$aRow['user'];
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                while ($aRow = mysql_fetch_assoc($rResult))
                                {
                                    if ('' != $aRow['user'])
                                    {
                                        $list.= (('' != $list)?"\t":'').$aRow['user'];
                                    }
                                }                         
                            }
                        }
                    }
                    break;
                case 'files':
                default:
                    $active_users_count = 0;
                    $locked_users_count = 0;
                    $users_count = 0;
                    if ($users_handle = @opendir($this->GetUsersFolder()))
                    {
                        while ($file = readdir($users_handle))
                        {
                            $desactivated = FALSE;
                            $locked = FALSE;
                            if ((substr($file, -3) == ".db") && ($file != '.db'))
                            {
                                $current_user = substr($file,0,-3);
                                $file_handler = fopen($this->GetUsersFolder().$file, "rt");
                                $first_line = trim(fgets($file_handler));
                                $v3 = (FALSE !== strpos(strtolower($first_line),"multiotp-database-format-v3"));
                                if (FALSE !== strpos(strtolower($first_line),"multiotp-database-format")) // Format V3
                                {
                                    while (!feof($file_handler))
                                    {
                                        $line = trim(fgets($file_handler));
                                        $line_array = explode("=",$line,2);
                                        if ($v3) // v3 format, only tags followed by := instead of = are encrypted
                                        {
                                            if (":" == substr($line_array[0], -1))
                                            {
                                                $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                                $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                            }
                                        }
                                        else // v2 format, only defined tags are encrypted
                                        {
                                            if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$line_array[0].'*')))
                                            {
                                                $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                            }
                                        }
                                        if ('desactivated' == trim($line_array[0]))
                                        {
                                            if (1 == (isset($line_array[1])?$line_array[1]:0))
                                            {
                                                $desactivated = TRUE;
                                            }
                                        }
                                        if ('locked' == trim($line_array[0]))
                                        {
                                            if (1 == (isset($line_array[1])?$line_array[1]:0))
                                            {
                                                $locked = TRUE;
                                            }
                                        }
                                    }
                                }
                                fclose($file_handler);
                                $users_count++;
                                
                                if (!$desactivated)
                                {
                                    $list.= (('' != $list)?"\t":'').$current_user;
                                    $active_users_count++;
                                }
                                if ($locked)
                                {
                                    $locked_users_count++;
                                }
                            }
                            if (($limit > 0) && (active_users_count >= $limit))
                            {
                                break;
                            }
                        }
                        closedir($users_handle);
                        
                        if (($limit <= 0) && ($this->IsCacheData()))
                        {
                            if ($locked_users_count >= 0)
                            {
                                $this->WriteCacheValue('locked_users_count', $locked_users_count);
                            }
                            if ($active_users_count >= 0)
                            {
                                $this->WriteCacheValue('active_users_count', $active_users_count);
                            }
                            if ($users_count >= 0)
                            {
                                $this->WriteCacheValue('users_count', $users_count);

                            }
                            $this->WriteCacheData();
                        }
                    }
            }
        }
        return $list;
    }


    function GetActiveUsersCount()
    {
        if (($this->IsCacheData()) && (intval($this->ReadCacheValue('active_users_count')) >= 0))
        {
            $active_users_count = intval($this->ReadCacheValue('active_users_count'));
        }
        else
        {
            $active_users_count = 0;
            $locked_users_count = -1;
            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_users_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT COUNT(user) AS counter FROM `".$this->_config_data['sql_users_table']."` WHERE (`desactivated` = 0)";
                            if (is_object($this->_mysqli))
                            {
                                if (!($result = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    if ($aRow = $result->fetch_assoc())
                                    {
                                        $active_users_count = $aRow['counter'];
                                    }
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    if ($aRow = mysql_fetch_assoc($rResult))
                                    {
                                        $active_users_count = $aRow['counter'];
                                    }
                                }
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $locked_users_count = 0;
                        $users_count = 0;
                        if ($users_handle = @opendir($this->GetUsersFolder()))
                        {
                            while ($file = readdir($users_handle))
                            {
                                $desactivated = FALSE;
                                $locked = FALSE;
                                if ((substr($file, -3) == ".db") && ($file != '.db'))
                                {
                                    $current_user = substr($file,0,-3);
                                    $file_handler = fopen($this->GetUsersFolder().$file, "rt");
                                    $first_line = trim(fgets($file_handler));
                                    $v3 = (FALSE !== strpos(strtolower($first_line),"multiotp-database-format-v3"));
                                    if (FALSE !== strpos(strtolower($first_line),"multiotp-database-format")) // Format V3
                                    {
                                        while (!feof($file_handler))
                                        {
                                            $line = trim(fgets($file_handler));
                                            $line_array = explode("=",$line,2);
                                            if ($v3) // v3 format, only tags followed by := instead of = are encrypted
                                            {
                                                if (":" == substr($line_array[0], -1))
                                                {
                                                    $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            else // v2 format, only defined tags are encrypted
                                            {
                                                if (FALSE !== strpos(strtolower($this->GetAttributesToEncrypt()), strtolower('*'.$line_array[0].'*')))
                                                {
                                                    $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                                                }
                                            }
                                            if ('desactivated' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $desactivated = TRUE;
                                                }
                                            }
                                            if ('locked' == trim($line_array[0]))
                                            {
                                                if (1 == (isset($line_array[1])?$line_array[1]:0))
                                                {
                                                    $locked = TRUE;
                                                }
                                            }
                                        }
                                    }
                                    fclose($file_handler);
                                    $users_count++;
                                    
                                    if (!$desactivated)
                                    {
                                        $active_users_count++;
                                    }
                                    if ($locked)
                                    {
                                        $locked_users_count++;
                                    }
                                }
                            }
                            closedir($users_handle);
                        }
                }
            }
            if ($this->IsCacheData())
            {
                if ($active_users_count >= 0)
                {
                    $this->WriteCacheValue('active_users_count', $active_users_count);
                }
                if ($locked_users_count >= 0)
                {
                    $this->WriteCacheValue('locked_users_count', $locked_users_count);
                }
                if ($users_count >= 0)
                {
                    $this->WriteCacheValue('users_count', $users_count);
                }
                $this->WriteCacheData();
            }
        }
        return $active_users_count;
    }


    function GetDetailedUsersArray()
    // Completely new edition 2014-07-21
    {
        $users_array = array();
        $result = $this->GetNextUserArray(TRUE);
        if (isset($result['user']))
        {
            $users_array[$result['user']] = $result;
        }
        do
        {
            if ($result = $this->GetNextUserArray())
            {
                if (isset($result['user']))
                {
                    $users_array[$result['user']] = $result;
                }
            }
        }
        while (FALSE !== $result);
        return $users_array;
    }


    function GetNextUserArray($first = FALSE, $fields = NULL)
    {
        if (NULL != $fields)
        {
            $fields_array = $fields;
        }
        else
        {
            $fields_array = array('user',
                                  'description',
                                  'email',
                                  'group',
                                  'desactivated',
                                  'locked',
                                  'sms',
                                  'synchronized',
                                  'synchronized_channel',
                                  'synchronized_server',
                                  'synchronized_time',
                                  'token_serial',
                                  'synchronized_dn'
                                 );
        }
        $raw_id = $fields_array[0];
        
        $fields_text = '';
        $fields_separator = '';
        foreach($fields_array as $one_field)
        {
            $fields_text.= $fields_separator.'`'.$one_field.'`';
            $fields_separator = ',';
        }
        
        $table_name = 'sql_users_table';
        $folder = $this->GetUsersFolder();
        $parser_id = 'GET_NEXT_USER_ARRAY';
        $user_array = false;

        if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data[$table_name])) || ('files' == $this->GetBackendType()))
        {
            if ($first)
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery = "SELECT ".$fields_text." FROM `".$this->_config_data[$table_name]."`";
                            if (is_object($this->_mysqli))
                            {
                                if (!($this->_parser_pointers[$parser_id] = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                    $this->_parser_pointers[$parser_id] = FALSE;
                                    $result = FALSE;
                                    return $result;
                                }
                            }
                            else
                            {
                                if (!($this->_parser_pointers[$parser_id] = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                                    $this->_parser_pointers[$parser_id] = FALSE;
                                    $result = FALSE;
                                    return $result;
                                }
                            }
                        }
                        break;
                    case 'files':
                    default:
                        if (!($this->_parser_pointers[$parser_id] = @opendir($folder)))
                        {
                            $result = FALSE;
                            return $result;
                        }
                }
            } // if ($first)
            
            if (isset($this->_parser_pointers[$parser_id]) && (FALSE !== $this->_parser_pointers[$parser_id]))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            if (is_object($this->_mysqli))
                            {
                                do
                                {
                                    $aRow = $this->_parser_pointers[$parser_id]->fetch_assoc();
                                }
                                while ((FALSE !== $aRow)
                                       &&
                                       (NULL !== $aRow)
                                       &&
                                       ('' == $aRow['user'])
                                      );
                            }
                            else
                            {
                                do
                                {
                                    $aRow = mysql_fetch_assoc($this->_parser_pointers[$parser_id]);
                                }
                                while ((FALSE !== $aRow)
                                       &&
                                       (NULL !== $aRow)
                                       &&
                                       ('' == $aRow['user'])
                                      );
                            }
                            if (isset($aRow['user']))
                            {
                                $user_array = array('user'                 => $aRow['user'],
                                                    'description'          => $aRow['description'],
                                                    'email'                => $aRow['email'],
                                                    'enabled'              => (0 == $aRow['desactivated']),
                                                    'group'                => $aRow['group'],
                                                    'locked'               => (1 == $aRow['locked']),
                                                    'sms'                  => $aRow['sms'],
                                                    'synchronized'         => (1 == $aRow['synchronized']),
                                                    'synchronized_channel' => $aRow['synchronized_channel'],
                                                    'synchronized_server'  => $aRow['synchronized_server'],
                                                    'synchronized_time'    => $aRow['synchronized_time'],
                                                    'token'                => $aRow['token_serial'],
                                                    'synchronized_dn'      => $aRow['synchronized_dn']
                                                    );
                            }
                        }
                        break;
                    case 'files':
                    default:
                        do
                        {
                            $file = readdir($this->_parser_pointers[$parser_id]);
                        }
                        while ((FALSE !== $file)
                               &&
                               ((substr($file, -3) != ".db")
                                ||
                                ($file == '.db'))
                              );
                        if (FALSE !== $file)
                        {
                            $user = substr($file,0,-3);
                            $this->SetUser($user);
                            $user_array = array('user'                 => $user,
                                                'description'          => $this->GetUserDescription(),
                                                'email'                => $this->GetUserEmail(),
                                                'enabled'              => (1 == $this->GetUserActivated()),
                                                'group'                => $this->GetUserGroup(),
                                                'locked'               => (1 == $this->GetUserLocked()),
                                                'sms'                  => $this->GetUserSms(),
                                                'synchronized'         => (1 == $this->GetUserSynchronized()),
                                                'synchronized_channel' => $this->GetUserSynchronizedChannel(),
                                                'synchronized_server'  => $this->GetUserSynchronizedServer(),
                                                'synchronized_time'    => $this->GetUserSynchronizedTime(),
                                                'token'                => $this->GetUserTokenSerialNumber(),
                                                'synchronized_dn'      => $this->GetUserSynchronizedDn()
                                               );
                        }
                        else
                        {
                            $user_array = FALSE;
                            closedir($this->_parser_pointers[$parser_id]);
                        }
                }
            }
            
        }
        if (FALSE === $user_array)
        {
            unset($this->_parser_pointers[$parser_id]);
        }
        return $user_array;
    }


    function GetAlgorithmsList()
    {
        $algorithms_list = '';
        $algorithms_array = explode("*",$this->_valid_algorithms);
        foreach ($algorithms_array as $algorithm_one)
        {
            if ('' != trim($algorithm_one))
            {
                $algorithms_list.= (('' != $algorithms_list)?"\t":'').trim($algorithm_one);
            }
        }
        return $algorithms_list;
    }


    function IsValidAlgorithm($algo_to_check)
    {
        return (FALSE !== strpos(strtolower($this->_valid_algorithms), strtolower('*'.$algo_to_check.'*')));
    }


    function GetUserScratchPasswordsArray($user = '')
    {
        if ('' != $user)
        {
            $this->SetUser($user);
        }
        if ($this->_user_data['scratch_passwords'] != '')
        {
            return (explode(",",$this->_user_data['scratch_passwords']));
        }
        else
        {
            return array();
        }
        return (explode(",",$this->_user_data['scratch_passwords']));
    }


    function RemoveUserUsedScratchPassword($to_remove)
    {
        $scratch_passwords = trim($this->_user_data['scratch_passwords']);
        if (FALSE !== ($pos = strpos($scratch_passwords, $to_remove)))
        {
            $scratch_passwords = trim(substr($scratch_passwords.' ', $pos+strlen($to_remove)+1));
            $this->_user_data['scratch_passwords'] = $scratch_passwords;
            $result = $this->WriteUserData();
        }
        return TRUE;
    }


    function GetScratchPasswordsAmount()
    {
        return $this->_config_data['scratch_passwords_amount'];
    }


    function SetScratchPasswordsAmount($value)
    {
        // Must be between 3 and 400
        $amount = intval($value);
        $amount = ($amount < 3)?3:$amount;
        $amount = ($amount > 400)?400:$amount;
        $this->_config_data['scratch_passwords_amount'] = $amount;
        return TRUE;
    }


    function GetUserScratchPasswordsList($user = '')
    {
        if ('' != $user)
        {
            $this->SetUser($user);
        }
        $digits = $this->GetScratchPasswordsDigits();

        /* This option is too long
        if (function_exists('openssl_random_pseudo_bytes')) {
            $seed = openssl_random_pseudo_bytes(16);
        } else {
        */
            $seed = hex2bin(md5('sCratchP@sswordS'.$this->GetUser().bigdec2hex((time()-mktime(1,1,1,1,1,2000)).mt_rand(10000,99999))));
        /* } */

        $scratch_loop = $this->GetScratchPasswordsAmount();
        if (($scratch_loop * (1+$digits) * 2.5) > 65535)
        {
            $scratch_loop = inval(65535 / ((1+$digits) * 2.5));
            $this->SetScratchPasswordsAmount($scratch_loop);
        }
        $scratch_passwords = trim($this->_user_data['scratch_passwords']);
        if (strlen($scratch_passwords) > ((1.5 * $scratch_loop) * (1 + $digits)))
        {
            $scratch_passwords = '';
        }
        $passwords_list = '';

        for ($i=0; $i<$scratch_loop; $i++)
        {
            $one_password = $this->GenerateOathHotp($seed,$i,$digits);
            $scratch_passwords.= (('' != $scratch_passwords)?",":'').$one_password;
            $passwords_list.= (('' != $passwords_list)?"\t":'').$one_password;
        }
        $this->_user_data['scratch_passwords'] = $scratch_passwords;
        $result = $this->WriteUserData();
        if (!$result)
        {
            $passwords_list = '';
        }
        return ($passwords_list);
    }


    function SetUserDataReadFlag($flag)
    {
        $this->_user_data_read_flag = $flag;
        return TRUE;
    }


    function GetUserDataReadFlag()
    {
        return $this->_user_data_read_flag;
    }


    function SetUserMultiAccount($value)
    {
        $this->_user_data['multi_account'] = $value;
        return TRUE;
    }


    function GetUserMultiAccount()
    {
        return $this->_user_data['multi_account'];
    }


    function SetUserEmail($first_param, $second_param = "*-*")
    {
        $valid = FALSE;
        $result = "";
        if ($second_param == "*-*")
        {
            if (('' == $first_param) || (FALSE !== strpos($first_param, '@')))
            {
                $result = $first_param;
                $valid = TRUE;
            }
        }
        else
        {
            $this->SetUser($first_param);
            if (('' == $second_param) || (FALSE !== strpos($second_param, '@')))
            {
                $result = $second_param;
                $valid = TRUE;
            }
        }
        $this->_user_data['email'] = $result;

        return $valid;
    }


    function SetUserAttribute($first_param, $second_param, $third_param = "*-*")
    {
        $result = FALSE;
        if ($third_param == "*-*")
        {
            if ($this->IsOptionInSchema('users', $first_param))
            {
                $this->_user_data[$first_param] = $second_param;
                $result = TRUE;
            }
        }
        else
        {
            if ($this->IsOptionInSchema('users', $second_param))
            {
                $this->SetUser($first_param);
                $this->_user_data[$second_param] = $third_param;
                $result = TRUE;
            }
        }
        return $result;
    }


    function GetUserEmail($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return $this->_user_data['email'];
    }


    function SetUserGroup($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $result = $second_param;
        }
        $this->_user_data['group'] = $result;

        return $result;
    }


    function GetUserGroup($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return $this->_user_data['group'];
    }


    function SetUserDescription($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $result = $second_param;
        }
        $this->_user_data['description'] = $result;
        
        $this->SetUserMultiAccount((FALSE !== strpos($result,'multi_account'))?1:0);

        return $result;
    }


    function GetUserDescription($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return $this->_user_data['description'];
    }


    function SetUserSeedPassword($value)
    {
        $this->_user_data['seed_password'] = $value;
    }


    function GetUserSeedPassword()
    {
        return $this->_user_data['seed_password'];
    }


    function SetUserSms($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $result = $second_param;
        }
        $this->_user_data['sms'] = $result;
        return TRUE;
    }


    function GetUserSms($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return $this->_user_data['sms'];
    }


    function SetUserPrefixPin($value)
    {
        $this->_user_data['request_prefix_pin'] = ((intval($value) > 0)?1:0);
        return TRUE;
    }


    function GetUserPrefixPin()
    {
        return $this->_user_data['request_prefix_pin'];
    }


    function EnableUserPrefixPin()
    {
        $this->_user_data['request_prefix_pin'] = 1;
        return TRUE;
    }


    function DisableUserPrefixPin()
    {
        $this->_user_data['request_prefix_pin'] = 0;
        return TRUE;
    }


    function IsUserPrefixPin()
    {
        return (1 == ($this->_user_data['request_prefix_pin']));
    }


    function SetUserRequestLdapPassword($value)
    {
        $this->_user_data['request_ldap_pwd'] = ((intval($value) > 0)?1:0);
        return TRUE;
    }


    function EnableUserRequestLdapPassword()
    {
        $this->_user_data['request_ldap_pwd'] = 1;
        return TRUE;
    }


    function DisableUserRequestLdapPassword()
    {
        $this->_user_data['request_ldap_pwd'] = 0;
        return TRUE;
    }


    function IsUserRequestLdapPasswordEnabled()
    {
        return (1 == ($this->_user_data['request_ldap_pwd']));
    }


    function SetUserLdapHashCache($first_param, $second_param = "*-*")
    {
        $value = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $value = $second_param;
        }
        $this->_user_data['ldap_hash_cache'] = $value;
        $this->_user_data['ldap_hash_validity'] = time() + $this->GetLdapHashCacheTime();
        return TRUE;
    }
    
   
    function ResetUserLdapHashCache($user = '')
    {
        if ('' != $user)
        {
            $this->SetUser($user);
        }
        $this->_user_data['ldap_hash_cache'] = '';
        $this->_user_data['ldap_hash_validity'] = 0;
        return TRUE;
    }


    function GetUserLdapHashCache($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        if ($this->_user_data['ldap_hash_validity'] >= time())
        {
            $value = $this->_user_data['ldap_hash_cache'];
        }
        else
        {
            $this->_user_data['ldap_hash_cache'] = '';
            $value = '';
        }
        return $value;
    }


    function SetUserAlgorithm($algorithm)
    {
        $result = FALSE;
        if ($this->IsValidAlgorithm($algorithm))
        {
            $this->_user_data['algorithm'] = strtolower($algorithm);
            $result = TRUE;
        }
        else
        {
            $this->WriteLog("Error: ".$algorithm." algorithm is unknown", FALSE, FALSE, 23, 'User');
        }
        return $result;
    }


    function GetUserAlgorithm($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        $result = strtolower($this->_user_data['algorithm']);
        if (FALSE === strpos(strtolower($this->_valid_algorithms), strtolower('*'.$result.'*')))
        {
            $result = '';
        }

        return $result;
    }


    function SetUserTokenAlgoSuite($token_algo_suite)
    {
        $this->_user_data['token_algo_suite'] = strtoupper(('' == $token_algo_suite)?'HMAC-SHA1':$token_algo_suite);
        return TRUE;
    }


    function GetUserTokenAlgoSuite($user = '')
    {
        return strtoupper(('' == $this->_user_data['token_algo_suite'])?'HMAC-SHA1':$this->_user_data['token_algo_suite']);
    }


    function SetUserTokenSeed($seed)
    {
        $this->_user_data['token_seed'] = $seed;
    }


    function GetUserTokenSeed()
    {
        return $this->_user_data['token_seed'];
    }


    function SetUserSmsOtp($value)
    {
        $this->_user_data['sms_otp'] = $value;
    }


    function GetUserSmsOtp()
    {
        // Be sure that we never have an SMS OTP smaller than 4 digits
        if (strlen($this->_user_data['sms_otp']) < 4)
        {
            $this->_user_data['sms_otp'] = md5($this->GetEncryptionKey().$this->GetUserTokenSeed().mt_rand(100000,999999).date("YmdHis"));
        }
        return $this->_user_data['sms_otp'];
    }


    function SetUserSmsValidity($value)
    {
        $this->_user_data['sms_validity'] = $value;
    }


    function GetUserSmsValidity()
    {
        return $this->_user_data['sms_validity'];
    }


    function SetUserPin($pin)
    {
        $this->_user_data['user_pin'] = $pin;
    }


    function GetUserPin($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return $this->_user_data['user_pin'];
    }


    function SetUserAutolockTime($value)
    {
        $this->_user_data['autolock_time'] = intval($value);
    }


    function GetUserAutolockTime()
    {
        return intval($this->_user_data['autolock_time']);
    }


    function SetUserTokenDeltaTime($delta_time)
    {
        $this->_user_data['delta_time'] = $delta_time;
    }


    function GetUserTokenDeltaTime()
    {
        return $this->_user_data['delta_time'];
    }


    function SetUserKeyId($key_id)
    {
        $this->_user_data['key_id'] = $key_id;
    }


    function GetUserKeyId()
    {
        return $this->_user_data['key_id'];
    }


    function SetUserTokenNumberOfDigits($number_of_digits)
    {
        $this->_user_data['number_of_digits'] = $number_of_digits;
    }


    function GetUserTokenNumberOfDigits()
    {
        return $this->_user_data['number_of_digits'];
    }


    function SetUserTokenTimeInterval($interval)
    {
        if (intval($interval) > 0)
        {
            $this->_user_data['time_interval'] = intval($interval);
        }
    }


    function GetUserTokenTimeInterval()
    {
        return $this->_user_data['time_interval'];
    }


    function GetUserEncryptionHash()
    {
        return $this->_user_data['encryption_hash'];
    }


    function SetUserTokenSerialNumber($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $value = $second_param;
        }
        $this->_user_data['token_serial'] = strtolower($value);

        return $value;
    }


    // TODO Add new method RemoveUserTokenSerialNumber/AddUserTokenSerialNumber like AddTokenAttributedUsers
    
    function GetUserTokenSerialNumber($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return strtolower($this->_user_data['token_serial']);
    }


    function SetUserTokenLastEvent($last_event)
    {
        $this->_user_data['last_event'] = $last_event;
    }


    function GetUserTokenLastEvent()
    {
        return $this->_user_data['last_event'];
    }


    function SetUserTokenLastLogin($time)
    {
        $this->_user_data['last_login'] = $time;
    }


    function GetUserTokenLastLogin()
    {
        return $this->_user_data['last_login'];
    }


    function SetUserTokenLastError($time)
    {
        $this->_user_data['last_error'] = $time;
    }


    function GetUserTokenLastError()
    {
        return $this->_user_data['last_error'];
    }


    function SetUserLocked($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['locked'] = $data;

        return $data;
    }


    function GetUserLocked($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return intval($this->_user_data['locked']);
    }


    function SetUserActivated($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $desactive = ($data > 0)?0:1;
        $this->_user_data['desactivated'] = $desactive;
        
        if (0 == $desactive) {
            $this->SetUserErrorCounter(0);
            $this->SetUserLocked(0);
        }

        return $data;
    }


    function GetUserActivated($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        $active = intval($this->_user_data['desactivated'] > 0)?0:1;
        return $active;
    }


    function SetUserSynchronized($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['synchronized'] = $data;

        return $data;
    }


    function GetUserSynchronized($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return intval($this->_user_data['synchronized']);
    }
    

    function IsUserSynchronized($user = '')
    {
        return (1 == ($this->GetUserSynchronized($user)));
    }
    

    function SetUserSynchronizedChannel($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['synchronized_channel'] = $data;

        return $data;
    }


    function GetUserSynchronizedChannel($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return ($this->_user_data['synchronized_channel']);
    }
    

    function SetUserSynchronizedDn($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['synchronized_dn'] = $data;

        return $data;
    }


    function GetUserSynchronizedDn($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return ($this->_user_data['synchronized_dn']);
    }
    

    function SetUserSynchronizedServer($first_param, $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            $data = $first_param;
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['synchronized_server'] = $data;

        return $data;
    }


    function GetUserSynchronizedServer($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return ($this->_user_data['synchronized_server']);
    }
    

    function SetUserSynchronizedTime($first_param = "*-*", $second_param = "*-*")
    {
        $data = 0;
        if ($second_param == "*-*")
        {
            if ($first_param == "*-*")
            {
                $data = time();
            }
            else
            {
                $data = $first_param;
            }
        }
        else
        {
            $this->SetUser($first_param);
            $data = $second_param;
        }
        $this->_user_data['synchronized_time'] = $data;

        return $data;
    }


    function GetUserSynchronizedTime($user = '')
    {
        if($user != '')
        {
            $this->SetUser($user);
        }
        return intval($this->_user_data['synchronized_time']);
    }


    function SetUserErrorCounter($counter)
    {
        $this->_user_data['error_counter'] = $counter;
    }


    function GetUserErrorCounter()
    {
        return $this->_user_data['error_counter'];
    }


    /*********************************************************************
     *
     * Name: CreateToken
     * Short description: Create a new token, without parameter, create
     *                      a Google Authenticator compatible token
     *
     * Creation 2013-02-08
     * Update 2013-12-23
     * @package multiotp
     * @version 4.1.0
     * @author SysCo/al
     *
     * @param   string  $serial      
     * @param   string  $algorithm
     * @param   string  $seed
     * @param   int     $number_of_digits
     * @param   int     $time_interval_or_next_event
     * @param   string  $manufacturer
     * @param   string  $issuer
     * @param   string  $description
     * @return  boolean
     *
     *********************************************************************/
    function CreateToken($serial = '', $algorithm = 'totp', $seed = '', $number_of_digits = 6, $time_interval_or_next_event = -1, $manufacturer = 'multiOTP', $issuer = '', $description = '', $token_algo_suite = '')
    {
        $the_serial = strtolower($serial);
        if ('' == $the_serial)
        {
            $the_serial = strtolower('mu'.bigdec2hex((time()-mktime(1,1,1,1,1,2000)).mt_rand(10000,99999)));
        }
        $the_description = $description;
        if ('' == $the_description)
        {
            $the_description = trim($manufacturer.' '.$the_serial);
        }
        $the_token = strtolower($the_serial);
        if ($this->ReadTokenData($the_token, TRUE))
        {
            return FALSE; // ERROR: token already exists.
        }
        else
        {
            $this->SetToken($the_serial);
            $this->SetTokenDescription($the_description);
            $this->SetTokenManufacturer(('' != $manufacturer)?$manufacturer:'multiOTP');
            $this->SetTokenIssuer(('' != $issuer)?$issuer:$this->GetIssuer());
            $this->SetTokenSerialNumber($the_serial);
            $this->SetTokenAlgorithm(strtolower($algorithm));
            $this->SetTokenAlgoSuite(strtolower($token_algo_suite));
            $this->SetTokenKeyAlgorithm(strtolower($algorithm));
            $this->SetTokenOtp('TRUE');

            $this->SetTokenFormat('DECIMAL');
            $this->SetTokenNumberOfDigits($number_of_digits);
            $this->SetTokenDeltaTime(0);
            
            /* This option is too long
            if (function_exists('openssl_random_pseudo_bytes')) {
                $the_seed = (('' == $seed)?bin2hex(openssl_random_pseudo_bytes(20)):$seed);
            } else {
            */
                $the_seed = (('' == $seed)?substr(md5(date("YmdHis").mt_rand(100000,999999)),0,20).substr(md5(mt_rand(100000,999999).date("YmdHis")),0,20):$seed);
            /* } */

            if ('hotp' == strtolower($algorithm))
            {
                $next_event = ((-1 == $time_interval_or_next_event)?0:$time_interval_or_next_event);
                $time_interval = 0;
            }
            else
            {
                $next_event = 0;
                $time_interval = ((-1 == $time_interval_or_next_event)?30:$time_interval_or_next_event);
                if ("motp" == strtolower($algorithm))
                {
                    /* This option is too long
                    if (function_exists('openssl_random_pseudo_bytes')) {
                        $the_seed = (('' == $seed)?bin2hex(openssl_random_pseudo_bytes(8)):$seed);
                    } else {
                    */
                        $the_seed = (('' == $seed)?substr(md5(date("YmdHis").mt_rand(100000,999999)),0,16):$seed);
                    /* } */
                    $time_interval = 10;
                }
            }

            $this->SetTokenSeed($the_seed);
            $this->SetTokenLastEvent($next_event - 1);
            $this->SetTokenTimeInterval($time_interval);
            
            return $this->WriteTokenData();
        }
    }    


    function SetTokenSerialNumberLength($value)
    {
        $this->_config_data['token_serial_number_length'] = trim($value);
    }
    
    
    function AddTokenSerialNumberLength($length)
    {
        if (intval($length) > 0)
        {
            $actual = trim($this->GetTokenSerialNumberLength());
            $length_exists = FALSE;

            // We add the serial number length only if it is not already attributed
            $token_serial_number_length_array = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$actual))));
            foreach($token_serial_number_length_array as $one_length)
            {
                if (intval($one_length) == intval($length))
                {
                    $length_exists = TRUE;
                    break;
                }
            }
            if (!$length_exists)
            {
                $actual.=' '.intval($length);
                $this->SetTokenSerialNumberLength($actual);

                // And we save this information directly in the configuration
                $this->WriteConfigData();
            }
        }
        return TRUE;
    }


    function GetTokenSerialNumberLength()
    {
        $token_serial_number_length = $this->_config_data['token_serial_number_length'];
        if (FALSE === strpos($token_serial_number_length, '12'))
        {
            // 12 is the RFC size of the serial number, we must have it and we add it if needed
            $token_serial_number_length.=' 12';
        }
        return $token_serial_number_length;
    }


    function SetTokenOtpListOfLength($value)
    {
        $this->_config_data['token_otp_list_of_length'] = trim($value);
    }
    
    
    function AddTokenOtpListOfLength($length)
    {
        if (intval($length) > 0)
        {
            $actual = trim($this->GetTokenOtpListOfLength());
            $length_exists = FALSE;

            // We add the OTP length only if it is not already attributed
            $token_otp_list_of_length_array = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$actual))));
            foreach($token_otp_list_of_length_array as $one_length)
            {
                if (intval($one_length) == intval($length))
                {
                    $length_exists = TRUE;
                    break;
                }
            }
            if (!$length_exists)
            {
                $actual.=' '.intval($length);
                $this->SetTokenOtpListOfLength($actual);

                // And we save this information directly in the configuration
                $this->WriteConfigData();
            }
        }
        return TRUE;
    }


    function GetTokenOtpListOfLength()
    {
        $token_otp_list_of_length = $this->_config_data['token_otp_list_of_length'];
        if (FALSE === strpos($token_otp_list_of_length, '6'))
        {
            // 6 is an RFC size of the OTP, we should have it and we add it if needed
            $token_otp_list_of_length.=' 6';
        }
        return $token_otp_list_of_length;
    }


    function SetTokenDescription($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetToken($first_param);
            $value = $second_param;
        }
        $this->_token_data['description'] = $value;
        return $value;
    }


    function GetTokenDescription($token = '')
    {
        if($token != '')
        {
            $this->SetToken($token);
        }
        return $this->_token_data['description'];
    }


    function SetToken($token)
    {
        $this->ResetTokenArray();
        $this->_token = strtolower($token);
        $this->ReadTokenData('', TRUE); // First parameter empty, otherwise it will loop with SetToken !
    }


    function RenameCurrentToken($new_token, $no_error_info = FALSE)
    {
        $esc_actual = escape_mysql_string($this->GetToken());
        $esc_new    = escape_mysql_string($new_token);
        $result = FALSE;
        if ($this->CheckTokenExists($new_token)) // Check if the new token already exists
        {
            $this->WriteLog("Error: Unable to rename the current token ".$this->GetToken()." to ".$new_token." because it already exists", FALSE, FALSE, 28, 'Token', '');
        }
        else
        {
            if ($this->CheckTokenExists()) // Check if the current token already exists
            {
                if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_tokens_table'])) || ('files' == $this->GetBackendType()))
                {
                    switch ($this->GetBackendType())
                    {
                        case 'mysql':
                            if ($this->OpenMysqlDatabase())
                            {
                                if ('' != $this->_config_data['sql_tokens_table'])
                                {
                                    $sQuery = "UPDATE `".$this->_config_data['sql_tokens_table']."` SET token_id='".$esc_new."' WHERE `token_id`='".$esc_actual."'";
                                    
                                    if (is_object($this->_mysqli))
                                    {
                                        if (!($rResult = $this->_mysqli->query($sQuery)))
                                        {
                                            if (!$no_error_info)
                                            {
                                                $this->WriteLog("Error: Could not rename the token ".$this->GetToken().": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'Token');
                                            }
                                        }
                                        else
                                        {
                                            $num_rows = $this->_mysqli->affected_rows;
                                        }
                                    }
                                    elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                    {
                                        if (!$no_error_info)
                                        {
                                            $this->WriteLog("Error: Could not rename the token ".$this->GetToken().": ".mysql_error(), FALSE, FALSE, 28, 'Token');
                                        }
                                    }
                                    else
                                    {
                                        $num_rows = mysql_affected_rows($this->_mysql_database_link);
                                    }
                                    
                                    if (0 == $num_rows)
                                    {
                                        $this->WriteLog("Error: Could not rename the token ".$this->GetToken().". Token does not exist", FALSE, FALSE, 29, 'Token');
                                    }
                                    else
                                    {
                                        $this->WriteLog("Info: Token ".$this->GetToken()." successfully renamed to $new_token", FALSE, FALSE, 19, 'Token');
                                        $result = TRUE;
                                    }
                                }
                            }
                            break;
                        case 'files':
                        default:
                            $old_token_filename = strtolower($this->GetToken()).'.db';
                            $new_token_filename = strtolower($new_token).'.db';
                            rename($this->GetTokensFolder().$old_token_filename, $this->GetTokensFolder().$new_token_filename);
                            $result = TRUE;
                            break;
                    }
                }
            }
            if ($result)
            {
                $this->_token = $new_token;
            }
        }
        return $result;
    }


    function GetToken()
    {
        return strtolower($this->_token);
    }


    function CheckTokenExists($token = '')
    {
        $check_token = strtolower('' != $token)?$token:$this->GetToken();
        $result = FALSE;
        
        if ('' != trim($check_token))
        {
            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_tokens_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_tokens_table']."` WHERE `token_id` = '{$check_token}'";
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                $this->WriteLog("Error: Token ".$check_token.". does not exist", FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                            else
                            {
                                $result = TRUE;
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $token_filename = strtolower($check_token).'.db';
                        $result = file_exists($this->GetTokensFolder().$token_filename);
                        break;
                }
            }
        }
        return $result;
    }


    function ResetLastImportedTokensArray()
    {
        $this->_last_imported_tokens = array();
    }


    function AddLastImportedToken($token)
    {
        $this->_last_imported_tokens[] = $token;
    }


    function GetLastImportedTokens()
    {
        return $this->_last_imported_tokens;
    }


    function SetTokenManufacturer($manufacturer)
    {
        $this->_token_data['manufacturer'] = $manufacturer;
    }


    function GetTokenManufacturer()
    {
        return $this->_token_data['manufacturer'];
    }


    function GetTokenEncryptionHash()
    {
        return $this->_token_data['encryption_hash'];
    }


    // This will (re)set only one user to the token
    function SetTokenAttributedUsers($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetToken($first_param);
            $result = $second_param;
        }
        $this->_token_data['attributed_users'] = $result;

        return $result;
    }


    function AddTokenAttributedUsers($first_param, $second_param = "*-*")
    {
        $data = "";
        $result = FALSE;
        if ($second_param == "*-*")
        {
            $data = $first_param;
            $token = $this->GetToken();
        }
        else
        {
            $token = $first_param;
            if ($this->CheckTokenExists($token))
            {
                $this->SetToken($token);
            }
            $data = $second_param;
        }
        if ($this->CheckTokenExists($token))
        {
            $actual = trim($this->GetTokenAttributedUsers());
            // We attribute the user only if it is not already attributed
            if (FALSE === strpos(','.$actual.',', ','.$data.','))
            {
                $this->SetTokenAttributedUsers($actual.(('' != $actual)?',':'').$data);
            }
            $result = TRUE;
        }
        return $result;
    }


    function RemoveTokenAttributedUsers($first_param, $second_param = "*-*")
    {
        $data = "";
        $result = FALSE;
        if ($second_param == "*-*")
        {
            $data = $first_param;
            $token = $this->GetToken();
        }
        else
        {
            $token = $first_param;
            if ($this->CheckTokenExists($token))
            {
                $this->SetToken($token);
            }
            $data = $second_param;
        }
        if ($this->CheckTokenExists($token))
        {
            if (FALSE !== strpos(','.trim($this->_token_data['attributed_users']).',', ','.$data.','))
            {
                $actual = str_replace(','.$data.',',',',','.trim($this->_token_data['attributed_users']).',');
                $this->SetTokenAttributedUsers(substr($actual,1, strlen($actual)-2));
                $result = TRUE;
            }
        }
        return $result;
    }


    function GetTokenAttributedUsers($token = '')
    {
        if($token != '')
        {
            $this->SetToken($token);
        }
        return $this->_token_data['attributed_users'];
    }


    function SetTokenSerialNumber($token_serial)
    {
        $this->_token_data['token_serial'] = strtolower($token_serial);
        $len_token_serial = strlen($token_serial);
        if ($len_token_serial > 0)
        {
            // We add this length automatically in the list of the existing serial number length
            $this->AddTokenSerialNumberLength($len_token_serial);
        }
    }


    function GetTokenSerialNumber()
    {
        return strtolower($this->_token_data['token_serial']);
    }


    function SetTokenIssuer($issuer)
    {
        if ('' == $issuer)
        {
            $this->_token_data['issuer'] = $this->GetIssuer();
        }
        else
        {
            $this->_token_data['issuer'] = $issuer;
        }
    }


    function GetTokenIssuer()
    {
        return $this->_token_data['issuer'];
    }


    function SetTokenKeyAlgorithm($key_algorithm)
    {
        $this->_token_data['key_algorithm'] = $key_algorithm;
    }


    function GetTokenKeyAlgorithm()
    {
        return $this->_token_data['key_algorithm'];
    }


    function SetTokenAlgorithm($algorithm)
    {
        $result = FALSE;
        if (FALSE === strpos(strtolower($this->_valid_algorithms), strtolower('*'.$algorithm.'*')))
        {
            $this->WriteLog("Error: ".$algorithm." algorithm unknown for token ".$this->GetToken(), FALSE, FALSE, 23, 'Token');
        }
        else
        {
            $this->_token_data['algorithm'] = strtolower($algorithm);
            $result = TRUE;
        }
        return $result;
    }


    function GetTokenAlgorithm()
    {
        $result = $this->_token_data['algorithm'];
        if (FALSE === strpos(strtolower($this->_valid_algorithms), strtolower('*'.$result.'*')))
        {
            $result = '';
        }

        return $result;
    }


    function SetTokenAlgoSuite($token_algo_suite)
    {
        $this->_token_data['token_algo_suite'] = strtoupper(('' == $token_algo_suite)?'HMAC-SHA1':$token_algo_suite);
        return TRUE;
    }


    function GetTokenAlgoSuite()
    {
        return strtoupper(('' == $this->_token_data['token_algo_suite'])?'HMAC-SHA1':$this->_token_data['token_algo_suite']);
    }


    function SetTokenOtp($otp)
    {
        $this->_token_data['otp'] = $otp;
    }


    function GetTokenOtp()
    {
        return $this->_token_data['otp'];
    }


    function SetTokenFormat($format)
    {
        $this->_token_data['format'] = $format;
    }


    function GetTokenFormat()
    {
        return $this->_token_data['format'];
    }


    function SetTokenNumberOfDigits($number_of_digits)
    {
        $this->_token_data['number_of_digits'] = $number_of_digits;
        // We add this number of digits automatically in the list of the existing list of length
        $this->AddTokenOtpListOfLength($number_of_digits);
    }


    function GetTokenNumberOfDigits()
    {
        return $this->_token_data['number_of_digits'];
    }


    function SetTokenLastEvent($last_event)
    {
        $this->_token_data['last_event'] = $last_event;
    }


    function GetTokenLastEvent()
    {
        return $this->_token_data['last_event'];
    }


    function SetTokenLastLogin($time)
    {
        $this->_token_data['last_login'] = $time;
    }


    function GetTokenLastLogin()
    {
        return $this->_token_data['last_login'];
    }


    function SetTokenErrorCounter($counter)
    {
        $this->_token_data['error_counter'] = $counter;
    }


    function GetTokenErrorCounter()
    {
        return $this->_token_data['error_counter'];
    }


    function SetTokenDeltaTime($delta_time)
    {
        $this->_token_data['delta_time'] = $delta_time;
    }


    function GetTokenDeltaTime()
    {
        return $this->_token_data['delta_time'];
    }


    function SetTokenTimeInterval($time_interval)
    {
        $this->_token_data['time_interval'] = $time_interval;
    }


    function GetTokenTimeInterval()
    {
        return $this->_token_data['time_interval'];
    }


    /**
     * @brief   Set the token seed in hexadecimal
     *
     * @param   string  $token_seed  Token in hexadecimal
     * @return  none
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.1.0
     * @date      2014-01-04
     * @since   2010-08-12
     */
    function SetTokenSeed($token_seed)
    {
        $this->_token_data['token_seed'] = $token_seed;
    }


    function GetTokenSeed()
    {
        return $this->_token_data['token_seed'];
    }


    function SetTokensFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_tokens_folder = $new_folder;
        if (!file_exists($new_folder))
        {
            if (!@mkdir($new_folder))
            {
                $this->WriteLog("Error: Unable to create the missing tokens folder ".$new_folder, FALSE, FALSE, 28, 'System',  '');
            }
        }
    }


    function GetTokensFolder()
    {
        if ('' == $this->_tokens_folder)
        {
            $this->SetTokensFolder($this->GetScriptFolder()."tokens/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_tokens_folder);
    }


    function GetTokensList()
    {
        return $this->GetList('token_id', 'sql_tokens_table', $this->GetTokensFolder());
    }


    function DeleteToken($token = '', $no_error_info = FALSE)
    {
        if ('' != $token)
        {
            $this->SetToken($token);
        }
        
        $result = FALSE;
        
        // First, we delete the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $token_filename = strtolower($this->_token).'.db';
            if (!file_exists($this->GetTokensFolder().$token_filename))
            {
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Error: *Unable to delete token ".$this->GetToken().", the tokens database file ".$this->GetTokensFolder().$token_filename." does not exist", FALSE, FALSE, 29, 'Token',  '');
                }
                else
                {
                    $this->WriteLog("Error: Unable to delete token ".$this->GetToken(), FALSE, FALSE, 29, 'Token',  '');
                }
            }
            else
            {
                $result = unlink($this->GetTokensFolder().$token_filename);
                if ($result)
                {
                    if ($this->GetVerboseFlag())
                    {
                        $this->WriteLog("Info: *Token ".$this->GetToken()." successfully deleted", FALSE, FALSE, 19, 'Token', '');
                    }
                }
                else
                {
                    $this->WriteLog("Error: Unable to delete token ".$this->GetToken(), FALSE, FALSE, 28, 'Token',  '');
                }
            }
        }

        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_tokens_table'])
                        {
                            $sQuery  = "DELETE FROM `".$this->_config_data['sql_tokens_table']."` WHERE `token_id` = '".$this->GetToken()."'";
                            
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    if (!$no_error_info)
                                    {
                                        $this->WriteLog("Error: Could not delete token ".$this->GetToken().": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'Token', '');
                                    }
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete token ".$this->GetToken().": ".mysql_error(), FALSE, FALSE, 28, 'Token', '');
                                }
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete token ".$this->GetToken().". Token does not exist", FALSE, FALSE, 29, 'Token', '');
                                }
                            }
                            else
                            {
                                if ($this->GetVerboseFlag())
                                {
                                    $this->WriteLog("Info: token ".$this->GetToken()." successfully deleted", FALSE, FALSE, 19, 'Token', '');
                                }
                                $result = TRUE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }                        
        }
        return $result;
    }


    function ReadTokenData($token = '', $create = FALSE)
    {
        if ('' != $token)
        {
            $this->SetToken($token);
        }
        $result = FALSE;
        
        // We initialize the encryption hash to empty
        $this->_token_data['encryption_hash'] = '';
        
        // First, we read the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $token_filename = strtolower($this->GetToken()).'.db';
            if (!file_exists($this->GetTokensFolder().$token_filename))
            {
                if (!$create)
                {
                    $this->WriteLog("Error: database file ".$this->GetTokensFolder().$token_filename." for token ".$this->_token." does not exist", FALSE, FALSE, 29, 'System', '');
                }
            }
            else
            {
                $file_handler = fopen($this->GetTokensFolder().$token_filename, "rt");
                $first_line = trim(fgets($file_handler));
                
                while (!feof($file_handler))
                {
                    $line = trim(fgets($file_handler));
                    $line_array = explode("=",$line,2);
                    if (":" == substr($line_array[0], -1))
                    {
                        $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                        $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                    }
                    if ('' != trim($line_array[0]))
                    {
                        $this->_token_data[strtolower($line_array[0])] = $line_array[1];
                    }
                }
                
                fclose($file_handler);
                $result = TRUE;

                if ('' != $this->_token_data['encryption_hash'])
                {
                    if ($this->_token_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                    {
                        $this->_token_data['encryption_hash'] = "ERROR";
                        $this->WriteLog("Error: the token information encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                        $result = FALSE;
                    }
                }
            }
        }

        // And now, we override the values if another backend type is defined
        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_tokens_table'])
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_tokens_table']."` WHERE `token_id` = '".$this->_token."'";
                            $aRow = NULL;
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".trim($this->_mysqli->error).' ', TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = $rResult->fetch_assoc();
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = mysql_fetch_assoc($rResult);
                                }
                            }

                            if (NULL != $aRow)
                            {
                                $result = FALSE;
                                while(list($key, $value) = @each($aRow))
                                {
                                    $in_the_schema = FALSE;
                                    reset($this->_sql_tables_schema['tokens']);
                                    while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['tokens']))
                                    {
                                        if ($valid_key == $key)
                                        {
                                            $in_the_schema = TRUE;
                                        }
                                    }
                                    if (($in_the_schema) && ($key != 'token_id'))
                                    {
                                        if (('ENC:' == substr($value,0,4)) && (':ENC' == substr($value,-4)))
                                        {
                                            $value = substr($value,4);
                                            $value = substr($value,0,strlen($value)-4);
                                            $this->_token_data[$key] = $this->Decrypt($key,$value,$this->GetEncryptionKey());
                                        }
                                        else
                                        {
                                            $this->_token_data[$key] = $value;
                                        }
                                    }                                    
                                    elseif ((!$in_the_schema) && ('unique_id' != $key)  && $this->GetVerboseFlag())
                                    {
                                        $this->WriteLog("Warning: *The key ".$key." is not in the tokens database schema", FALSE, FALSE, 98, 'System', '');
                                    }
                                    $result = TRUE;
                                }
                                if(0 == count($aRow) && !$create)
                                {
                                    $this->WriteLog("Error: SQL database entry for token ".$this->_token." does not exist", FALSE, FALSE, 29, 'System', '');
                                }
                            }
                        }
                        if ('' != $this->_token_data['encryption_hash'])
                        {
                            if ($this->_token_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                            {
                                $this->_token_data['encryption_hash'] = "ERROR";
                                $this->WriteLog("Error: the tokens mysql encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }
        }
        $this->SetTokenDataReadFlag($result);
        return $result;
    }


    function WriteTokenData()
    {
        if ('' == trim($this->GetToken())) {
            $result = false;
        } else {
            $result = $this->WriteData('Token',
                                       'tokens',
                                       $this->GetTokensFolder(),
                                       $this->_token_data,
                                       false,
                                       'token_id',
                                       $this->GetToken()
                                      );
        }
        return $result;
    }


    function SetLastClearOtpValue($value = '')
    {
        $this->_last_clear_otp_value = $value;
    }


    function GetLastClearOtpValue()
    {
        return $this->_last_clear_otp_value;
    }


    function ResetTemporaryBadServer()
    {
        $this->_servers_temp_bad_list = array();
    }


    function AddTemporaryBadServer($server)
    {
        $this->_servers_temp_bad_list[] = $server;
    }


    function GetTemporaryBadServer()
    {
        return $this->_servers_temp_bad_list;
    }


    function CheckUserLdapPassword($ldap_username, $ldap_password)
    {
        $this->SetLdapServerReachable(FALSE);
        $result = FALSE;

        // DistinguishedName must be encoded in UTF-8
        $ldap_bind_dn = encode_utf8_if_needed($ldap_username);
        
        if (('' != $ldap_username) && (FALSE === strpos(strtolower($ldap_bind_dn), 'cn=')))
        {
            $ldap_bind_dn = 'CN='.$ldap_bind_dn.','.$this->GetLdapBaseDn();
        }

        if (!function_exists('ldap_connect'))
        {
            $this->WriteLog("Error: PHP LDAP library is not installed", FALSE, FALSE, 299, 'System', '');
            $this->EnableLdapError();
        }
        elseif (('' != $this->GetLdapDomainControllers()) && ('' != $ldap_username) && ('' != $ldap_password))
        {
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            $ldap_options = array('account_suffix'     => $this->GetLdapAccountSuffix(),
                                  'ad_password'        => $ldap_password,
                                  'ad_username'        => $ldap_bind_dn,
                                  'base_dn'            => $this->GetLdapBaseDn(),
                                  'cn_identifier'      => $this->GetLdapCnIdentifier(),
                                  'domain_controllers' => $domain_controllers,
                                  'group_attribute'    => $this->GetLdapGroupAttribute(),
                                  'group_cn_identifier'=> $this->GetLdapGroupCnIdentifier(),
                                  'ldap_server_type'   => $this->GetLdapServerType(),
                                  'network_timeout'    => $this->GetLdapNetworkTimeout(),
                                  'port'               => $this->GetLdapPort(),
                                  'recursive_groups'   => TRUE,
                                  'time_limit'         => $this->GetLdapTimeLimit(),
                                  'use_ssl'            => $this->IsLdapSsl()
                                 );

            $ldap_connection=new MultiotpAdLdap($ldap_options);

            $this->SetLdapServerReachable($ldap_connection->IsServerReachable());

            $result = !$ldap_connection->IsError();

            unset($ldap_connection);
        }
        return $result;
    }


    function GetLdapUsersList($user_filter = "*")
    {
        $this->DisableLdapError();
        $users_list = '';
        $in_groups_array = array();
        $result_array = array();
        
        if (!function_exists('ldap_connect'))
        {
            $result = FALSE;
            $this->WriteLog("Error: PHP LDAP library is not installed", FALSE, FALSE, 299, 'System', '');
            $this->EnableLdapError();
        }
        elseif (('' != $this->GetLdapDomainControllers()) && ('' != $this->GetLdapBindDn()) && ('' != $this->GetLdapServerPassword()))
        {
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            $ldap_options = array('account_suffix'     => $this->GetLdapAccountSuffix(),
                                  'ad_password'        => $this->GetLdapServerPassword(),
                                  'ad_username'        => $this->GetLdapBindDn(),
                                  'base_dn'            => $this->GetLdapBaseDn(),
                                  'cn_identifier'      => $this->GetLdapCnIdentifier(),
                                  'domain_controllers' => $domain_controllers,
                                  'group_attribute'    => $this->GetLdapGroupAttribute(),
                                  'group_cn_identifier'=> $this->GetLdapGroupCnIdentifier(),
                                  'ldap_server_type'   => $this->GetLdapServerType(),
                                  'network_timeout'    => $this->GetLdapNetworkTimeout(),
                                  'port'               => $this->GetLdapPort(),
                                  'recursive_groups'   => TRUE,
                                  'time_limit'         => $this->GetLdapTimeLimit(),
                                  'use_ssl'            => $this->IsLdapSsl()
                                 );

            $ldap_connection=new MultiotpAdLdap($ldap_options);
            if ($users_info = $ldap_connection->users_info($user_filter,
                                                           $this->GetLdapFieldsArray()))
            {
                if ($ldap_connection->IsError())
                {
                    $this->EnableLdapError();
                }
                // We continue only if there is no error
                else
                {
                    $all_results = (isset($users_info['count'])?$users_info['count']:0);
                    for ($results=0; $results < $all_results; $results++)
                    {
                        $accountdisable = FALSE;
                        $one_user = $users_info[$results];
                        $user = decode_utf8_if_needed(isset($one_user[strtolower($this->GetLdapCnIdentifier())][0])?($one_user[strtolower($this->GetLdapCnIdentifier())][0]):'');
                        if (isset($one_user['useraccountcontrol'][0]))
                        {
                            if (0 != ($one_user['useraccountcontrol'][0] & 2))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['ms-ds-user-account-control-computed'][0]))
                        {
                            if (0 != ($one_user['ms-ds-user-account-control-computed'][0] & 16))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['accountexpires'][0]))
                        {
                            if (($one_user['accountexpires'][0] > 0) && ((($one_user['accountexpires'][0] / 10000000) - 11644473600) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        
                        if (isset($one_user['shadowexpire'][0]))
                        {
                            if (($one_user['shadowexpire'][0] >= 0) && ((86400 * $one_user['shadowexpire'][0]) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['sambaacctflags'][0]))
                        {
                            if ((FALSE !== strpos($one_user['sambaacctflags'][0], "D")) || (FALSE !== strpos($one_user['sambaacctflags'][0], "L")))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        
                        if (!$accountdisable)
                        {
                            if ('' == trim($this->GetLdapInGroup()))
                            {
                                $in_a_group = TRUE;
                            }
                            else
                            {
                                $in_a_group = FALSE;
                                $in_groups_array_raw = explode(" ",trim(str_replace(","," ",str_replace(";"," ",strtolower($this->GetLdapInGroup())))));
                                foreach($in_groups_array_raw as $one_group)
                                {
                                    $in_groups_array[] = trim($one_group);
                                }
                            }

                            $groups_array_raw = $ldap_connection->user_groups($user);
                            $groups_array = array();
                            foreach($groups_array_raw as $one_group)
                            {
                                $this_group = decode_utf8_if_needed($one_group);
                                $groups_array[] = $this_group;
                                if (in_array(strtolower($this_group), $in_groups_array))
                                {
                                    $in_a_group = TRUE;
                                }
                            }

                            if ($in_a_group)
                            {
                                $users_list.= (('' != $users_list)?"\t":'').$user;
                            }
                        }
                    }
                }
            }
            else
            {
                $this->EnableLdapError();
                $this->WriteLog("Error: no LDAP binding", FALSE, FALSE, 30, 'LDAP', '');
            }
        }
        else
        {
            $this->WriteLog("Error: No LDAP connection information", FALSE, FALSE, 30, 'LDAP', '');
        }
        return $users_list;
    }


    function GetLdapUsersInfoArray($user_filter = "*", $include_disabled = TRUE, $ignore_in_group = FALSE)
    {
        $this->DisableLdapError();
        $in_groups_array = array();
        $result_array = array();

        if (!function_exists('ldap_connect'))
        {
            $result = FALSE;
            $this->WriteLog("Error: PHP LDAP library is not installed", FALSE, FALSE, 299, 'System', '');
            $this->EnableLdapError();
        }
        elseif (('' != $this->GetLdapDomainControllers()) && ('' != $this->GetLdapBindDn()) && ('' != $this->GetLdapServerPassword()))
        {
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            $ldap_options = array('account_suffix'     => $this->GetLdapAccountSuffix(),
                                  'ad_password'        => $this->GetLdapServerPassword(),
                                  'ad_username'        => $this->GetLdapBindDn(),
                                  'base_dn'            => $this->GetLdapBaseDn(),
                                  'cn_identifier'      => $this->GetLdapCnIdentifier(),
                                  'domain_controllers' => $domain_controllers,
                                  'group_attribute'    => $this->GetLdapGroupAttribute(),
                                  'group_cn_identifier'=> $this->GetLdapGroupCnIdentifier(),
                                  'ldap_server_type'   => $this->GetLdapServerType(),
                                  'network_timeout'    => $this->GetLdapNetworkTimeout(),
                                  'port'               => $this->GetLdapPort(),
                                  'recursive_groups'   => TRUE,
                                  'time_limit'         => $this->GetLdapTimeLimit(),
                                  'use_ssl'            => $this->IsLdapSsl()
                                 );

            $ldap_connection=new MultiotpAdLdap($ldap_options);
            if ($users_info = $ldap_connection->users_info($user_filter,
                                                           $this->GetLdapFieldsArray()))
            {
                if ($ldap_connection->IsError())
                {
                    $this->EnableLdapError();
                }
                // We continue only if there is no error
                else
                {
                    // Prepare the array "users_in_groups" if we are using a generic LDAP and an LdapInGroup Filtering
                    if (1 != $this->GetLdapServerType()) // Generic LDAP, eventually no memberOf function like in AD
                    {
                        $users_in_groups = array();
                        if ('' != trim($this->GetLdapInGroup()))
                        {
                            $in_groups_array_raw = explode(" ",trim(str_replace(","," ",str_replace(";"," ",strtolower($this->GetLdapInGroup())))));
                            foreach($in_groups_array_raw as $one_group)
                            {
                                $temp_array = $ldap_connection->group_users($one_group);
                                foreach($temp_array as $one_temp)
                                {
                                    $one_user = decode_utf8_if_needed($one_temp);
                                    if (!isset($users_in_groups[decode_utf8_if_needed($one_user)]))
                                    {
                                        $users_in_groups[$one_user] = $one_group;
                                    }
                                    else
                                    {
                                        $users_in_groups[$one_user] = $users_in_groups[$one_user].",".$one_group;
                                    }
                                }
                            }
                        }
                    }
                
                    $all_results = (isset($users_info['count'])?$users_info['count']:0);
                    for ($results=0; $results < $all_results; $results++)
                    {
                        $accountdisable = FALSE;
                        $one_user = $users_info[$results];
                        $user = decode_utf8_if_needed(isset($one_user[strtolower($this->GetLdapCnIdentifier())][0])?($one_user[strtolower($this->GetLdapCnIdentifier())][0]):'');
                        if (!$this->IsCaseSensitiveUsers())
                        {
                            $user = strtolower($user);
                        }
                        if (isset($one_user['useraccountcontrol'][0]))
                        {
                            if (0 != ($one_user['useraccountcontrol'][0] & 2))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['ms-ds-user-account-control-computed'][0]))
                        {
                            if (0 != ($one_user['ms-ds-user-account-control-computed'][0] & 16))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['accountexpires'][0]))
                        {
                            if (($one_user['accountexpires'][0] > 0) && ((($one_user['accountexpires'][0] / 10000000) - 11644473600) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }

                        if (isset($one_user['shadowexpire'][0]))
                        {
                            if (($one_user['shadowexpire'][0] >= 0) && ((86400 * $one_user['shadowexpire'][0]) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['sambaacctflags'][0]))
                        {
                            if ((FALSE !== strpos($one_user['sambaacctflags'][0], "D")) || (FALSE !== strpos($one_user['sambaacctflags'][0], "L")))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        
                        if ($include_disabled || (!$accountdisable))
                        {
                            if ('' == trim($this->GetLdapInGroup()))
                            {
                                $in_a_group = TRUE;
                            }
                            else
                            {
                                $in_a_group = FALSE;
                                $in_groups_array_raw = explode(" ",trim(str_replace(","," ",str_replace(";"," ",strtolower($this->GetLdapInGroup())))));
                                foreach($in_groups_array_raw as $one_group)
                                {
                                    $in_groups_array[] = trim($one_group);
                                }
                            }

                            if (1 != $this->GetLdapServerType()) // Generic LDAP, eventually no memberOf function like in AD
                            {
                                if (isset($users_in_groups[$user]))
                                $in_a_group = TRUE;
                            }
                            else // AD
                            {
                                // $groups_array_raw = $ldap_connection->user_groups($user);
                                $groups_array_raw=$ldap_connection->nice_names($one_user[$ldap_connection->_group_attribute]); //presuming the entry returned is our guy (unique usernames)

                                if ($ldap_connection->_recursive_groups)
                                {
                                    foreach ($groups_array_raw as $id => $group_name){
                                        $extra_groups=$ldap_connection->recursive_groups($group_name, TRUE); // recursive_groups with cache only
                                        if ('' != $ldap_connection->get_warning_message()) {
                                            $this->WriteLog("Warning: ".$ldap_connection->get_warning_message(), FALSE, FALSE, 98, 'LDAP', '');
                                        }
                                        if ($this->GetVerboseFlag() && ('' != $ldap_connection->get_debug_message())) {
                                            $this->WriteLog("Debug: ".$ldap_connection->get_debug_message(), FALSE, FALSE, 98, 'LDAP', '');
                                        }
                                        $groups_array_raw=array_merge($groups_array_raw,$extra_groups);
                                    }
                                }
                                
                                foreach($groups_array_raw as $one_group)
                                {
                                    $this_group = decode_utf8_if_needed($one_group);
                                    $groups_array[] = $this_group;
                                    if (in_array(strtolower($this_group), $in_groups_array))
                                    {
                                        $in_a_group = TRUE;
                                    }
                                }
                            }
                            
                            if ($ignore_in_group || $in_a_group)
                            {
                                $result_array[$user]['user'] = $user;
                                $result_array[$user]['groups'] = $groups_array;
                                $result_array[$user]['accountdisable'] = $accountdisable;
                                $result_array[$user]['mail'] = (isset($one_user['mail'][0])?decode_utf8_if_needed($one_user['mail'][0]):"");
                                $result_array[$user]['displayname'] = (isset($one_user['displayname'][0])?decode_utf8_if_needed($one_user['displayname'][0]):"");
                                $result_array[$user]['mobile'] = (isset($one_user['mobile'][0])?decode_utf8_if_needed($one_user['mobile'][0]):"");
                                $result_array[$user]['msnpallowdialin'] = ("TRUE" == (isset($one_user['msnpallowdialin'][0])?($one_user['msnpallowdialin'][0]):"FALSE"));
                                $result_array[$user]['synchronized_dn'] = (isset($one_user['distinguishedname'][0])?decode_utf8_if_needed($one_user['distinguishedname'][0]):"");
                            }
                        }
                    }
                }
            }
            else
            {
                $this->EnableLdapError();
                $this->WriteLog("Error: LDAP connection failed", FALSE, FALSE, 30, 'LDAP', '');
            }
        }
        else
        {
            $this->EnableLdapError();
            $this->WriteLog("Error: no LDAP connection information", FALSE, FALSE, 30, 'LDAP', '');
        }
        return $result_array;
    }


    function TestLdapUser($value)
    {
        $result = FALSE;
        $user_to_check = ($this->IsCaseSensitiveUsers()?$value:strtolower($value));
        $ldap_users_array = $this->GetLdapUsersInfoArray();
        if (!$this->IsLdapError())
        {
            foreach($ldap_users_array as $one_ldap_user)
            {
                $user = $one_ldap_user['user'];
                $user = ($this->IsCaseSensitiveUsers()?$user:strtolower($user));
                if ($user_to_check == $user)
                {
                    $result = TRUE;
                    break;
                }
            }
        }
        return $result;
    }


    /**
     * @brief   Synchronize AD/LDAP users
     *
     * @param   string  $user_filter           User name filter (* by default)
     * @param   boolean $include_disabled      Disabled users will also be synced
     * @param   boolean $ignore_in_group       Don't check if the users are in the selected groups or not
     *
     * @return  boolean                        Function has been successfully called
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.3.2.0
     * @date    2015-02-18
     * @since   2014-11-04 (completely redesigned)
     */
    function SyncLdapUsers(
        $user_filter = "*",
        $include_disabled = TRUE,
        $ignore_in_group = FALSE
    ) {
        $start_sync_time = time();

        $this->DisableLdapError();
        $in_groups_array = array();
        $result = FALSE;

        if (!function_exists('ldap_connect'))
        {
            $this->WriteLog("Error: PHP LDAP library is not installed", FALSE, FALSE, 299, 'System', '');
            $this->EnableLdapError();
        }
        // TODO: later, we could loop in several base-dn (semicolon separated)
        elseif (('' != $this->GetLdapDomainControllers()) && ('' != $this->GetLdapBindDn()) && ('' != $this->GetLdapServerPassword()))
        {
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            $ldap_options = array('account_suffix'     => $this->GetLdapAccountSuffix(),
                                  'ad_password'        => $this->GetLdapServerPassword(),
                                  'ad_username'        => $this->GetLdapBindDn(),
                                  'base_dn'            => $this->GetLdapBaseDn(),
                                  'cn_identifier'      => $this->GetLdapCnIdentifier(),
                                  'domain_controllers' => $domain_controllers,
                                  'group_attribute'    => $this->GetLdapGroupAttribute(),
                                  'group_cn_identifier'=> $this->GetLdapGroupCnIdentifier(),
                                  'ldap_server_type'   => $this->GetLdapServerType(),
                                  'network_timeout'    => $this->GetLdapNetworkTimeout(),
                                  'port'               => $this->GetLdapPort(),
                                  'recursive_groups'   => TRUE,
                                  'time_limit'         => $this->GetLdapTimeLimit(),
                                  'use_ssl'            => $this->IsLdapSsl()
                                 );

            $ldap_connection = new MultiotpAdLdap($ldap_options);
            
            if ($ldap_connection->IsError())
            {
                $this->EnableLdapError();
            }
            // We continue only if there is no error
            else
            {
                // Put all group_cn in cache
                $ldap_connection->group_cn(1, FALSE, TRUE);

                // Put all recursive_groups in cache
                $all_groups = $ldap_connection->all_groups(FALSE, '*', TRUE, TRUE);
                reset($all_groups);
                while(list($key, $one_group) = each($all_groups))
                {
                    $ldap_connection->recursive_groups($one_group);
                }

                $ldap_created_counter = 0;
                $modified_counter = 0;
                $result = TRUE;

                $page_cookie = '';


                // Prepare the array "users_in_groups" if we are using a generic LDAP and an LdapInGroup Filtering
                if (1 != $this->GetLdapServerType()) // Generic LDAP, eventually no memberOf function like in AD
                {
                    $users_in_groups = array();
                    if ('' != trim($this->GetLdapInGroup()))
                    {
                        $in_groups_array_raw = explode(" ",trim(str_replace(","," ",str_replace(";"," ",strtolower($this->GetLdapInGroup())))));
                        foreach($in_groups_array_raw as $one_group)
                        {
                            $temp_array = $ldap_connection->group_users($one_group);
                            foreach($temp_array as $one_temp)
                            {
                                $one_user = decode_utf8_if_needed($one_temp);
                                if (!isset($users_in_groups[decode_utf8_if_needed($one_user)]))
                                {
                                    $users_in_groups[$one_user] = $one_group;
                                }
                                else
                                {
                                    $users_in_groups[$one_user] = $users_in_groups[$one_user].",".$one_group;
                                }
                            }
                        }
                    }
                }

                do
                { // ldap pagination loop
                    if (function_exists('ldap_control_paged_result'))
                    {
                        ldap_control_paged_result($ldap_connection->_conn, 1000, true, $page_cookie); // Page size of 1000
                    }
                    $one_user = $ldap_connection->one_user_info(TRUE,
                                                                $user_filter,
                                                                $this->GetLdapFieldsArray(),
                                                                TRUE // $group_cn_cache_only = TRUE
                                                               );
                    if ($ldap_connection->IsError())
                    {
                        $this->EnableLdapError();
                        $this->WriteLog("Error: LDAP connection failed", FALSE, FALSE, 30, 'LDAP', '');
                        return FALSE;
                    }
                    if ('' != $ldap_connection->get_warning_message()) {
                        $this->WriteLog("Warning: ".$ldap_connection->get_warning_message(), FALSE, FALSE, 98, 'LDAP', '');
                    }
                    if ($this->GetVerboseFlag() && ('' != $ldap_connection->get_debug_message())) {
                        $this->WriteLog("Debug: ".$ldap_connection->get_debug_message(), FALSE, FALSE, 98, 'LDAP', '');
                    }

                    do
                    {
                        $accountdisable = FALSE;
                        $groups_array = array();
                        $user = decode_utf8_if_needed(isset($one_user[strtolower($this->GetLdapCnIdentifier())][0])?($one_user[strtolower($this->GetLdapCnIdentifier())][0]):'');
                        if (!$this->IsCaseSensitiveUsers())
                        {
                            $user = strtolower($user);
                        }
                        if (isset($one_user['useraccountcontrol'][0]))
                        {
                            if (0 != ($one_user['useraccountcontrol'][0] & 2))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['ms-ds-user-account-control-computed'][0]))
                        {
                            if (0 != ($one_user['ms-ds-user-account-control-computed'][0] & 16))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['accountexpires'][0]))
                        {
                            if (($one_user['accountexpires'][0] > 0) && ((($one_user['accountexpires'][0] / 10000000) - 11644473600) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }

                        if (isset($one_user['shadowexpire'][0]))
                        {
                            if (($one_user['shadowexpire'][0] >= 0) && ((86400 * $one_user['shadowexpire'][0]) < time()))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if (isset($one_user['sambaacctflags'][0]))
                        {
                            if ((FALSE !== strpos($one_user['sambaacctflags'][0], "D")) || (FALSE !== strpos($one_user['sambaacctflags'][0], "L")))
                            {
                                $accountdisable = TRUE;
                            }
                        }
                        if ($include_disabled || (!$accountdisable))
                        {
                            if ('' == trim($this->GetLdapInGroup()))
                            {
                                $in_a_group = TRUE;
                            }
                            else
                            {
                                $in_a_group = FALSE;
                                $in_groups_array_raw = explode(" ",trim(str_replace(","," ",str_replace(";"," ",strtolower($this->GetLdapInGroup())))));
                                foreach($in_groups_array_raw as $one_group)
                                {
                                    $in_groups_array[] = trim($one_group);
                                }
                            }

                            if (1 != $this->GetLdapServerType()) // Generic LDAP, eventually no memberOf function like in AD
                            {
                                if (isset($users_in_groups[$user]))
                                $in_a_group = TRUE;
                            }
                            else // AD
                            {
                                // $groups_array_raw = $ldap_connection->user_groups($user);
                                $groups_array_raw=$ldap_connection->nice_names($one_user[$ldap_connection->_group_attribute]); //presuming the entry returned is our guy (unique usernames)

                                if ($ldap_connection->_recursive_groups)
                                {
                                    foreach ($groups_array_raw as $id => $group_name){
                                        $extra_groups=$ldap_connection->recursive_groups($group_name, TRUE); // recursive_groups with cache only
                                        if ('' != $ldap_connection->get_warning_message())
                                        {
                                            $this->WriteLog("Warning: ".$ldap_connection->get_warning_message(), FALSE, FALSE, 98, 'LDAP', '');
                                        }
                                        $groups_array_raw=array_merge($groups_array_raw,$extra_groups);
                                    }
                                }
                                
                                foreach($groups_array_raw as $one_group)
                                {
                                    $this_group = decode_utf8_if_needed($one_group);
                                    $groups_array[] = $this_group;
                                    if (in_array(strtolower($this_group), $in_groups_array))
                                    {
                                        $in_a_group = TRUE;
                                    }
                                }
                            }

                            if ($ignore_in_group || $in_a_group)
                            {
                                $description = '';
                                if (isset($one_user['description'][0]))
                                {
                                    $description = trim($one_user['description'][0]);
                                }
                                if (('' == $description) && (isset($one_user['gecos'][0])))
                                {
                                    $description = trim($one_user['gecos'][0]);
                                }
                                if (('' == $description) && (isset($one_user['displayname'][0])))
                                {
                                    $description = trim($one_user['displayname'][0]);
                                }
                                if ('' == $description)
                                {
                                    $description = $user;
                                }

                                // $user;
                                $ldap_groups = $groups_array;
                                $ldap_email = trim(isset($one_user['mail'][0])?decode_utf8_if_needed($one_user['mail'][0]):"");
                                $ldap_description = decode_utf8_if_needed($description);
                                $ldap_sms = (isset($one_user['mobile'][0])?decode_utf8_if_needed($one_user['mobile'][0]):"");
                                $ldap_msnpallowdialin = ("TRUE" == (isset($one_user['msnpallowdialin'][0])?($one_user['msnpallowdialin'][0]):"FALSE"));
                                $ldap_enabled = ((!$accountdisable)?1:0);
                                $ldap_synchronized_dn = trim(isset($one_user['distinguishedname'][0])?decode_utf8_if_needed($one_user['distinguishedname'][0]):"");
                                
                                if (!$this->CheckUserExists($user, true, true)) // $no_server_check = TRUE; $no_error = TRUE
                                // User doesn't exist yet
                                {
                                    if ('' == $ldap_description)
                                    {
                                        $ldap_description = $user;
                                    }
                                    $result = $this->FastCreateUser($user,
                                                                    $ldap_email,
                                                                    $ldap_sms,
                                                                    -1, // Prefix pin needed
                                                                    "totp",
                                                                    $ldap_enabled,
                                                                    $ldap_description,
                                                                    $this->GetDefaultUserGroup(), // Group
                                                                    1,  // Synchronized
                                                                    '', // Pin
                                                                    true, // Automatically
                                                                    'LDAP', // Synchronized channel
                                                                    $this->GetLdapDomainControllers(), // Synchronized server
                                                                    $ldap_synchronized_dn,
                                                                    -1 // Set to default value if the user is created  automatically
                                                                   );
                                    if ($result) {
                                        $this->SyncUserModified(true, $user);
                                        $ldap_created_counter++;
                                    }
                                }
                                else
                                // User already exists
                                {
                                    $this->SetUser($user);
                                    if (1 == $this->GetUserSynchronized())
                                    {
                                        $description = $this->GetUserDescription();
                                        $email = $this->GetUserEmail();
                                        $enabled = $this->GetUserActivated();
                                        $sms = $this->GetUserSms();
                                        $synchronized_channel = $this->GetUserSynchronizedChannel();
                                        $synchronized_dn = $this->GetUserSynchronizedDn();
                                        $synchronized_server = $this->GetUserSynchronizedServer();
                                        $modified = FALSE;

                                        if (('' != $ldap_description) && ($description != $ldap_description))
                                        {
                                            $this->SetUserDescription($ldap_description);
                                            $modified = TRUE;
                                        }
                                        
                                        if (('' != $ldap_email) && ($email != $ldap_email))
                                        {
                                            $this->SetUserEmail($ldap_email);
                                            $modified = TRUE;
                                        }

                                        if ($enabled != $ldap_enabled)
                                        {
                                            $this->SetUserActivated($ldap_enabled);
                                            $modified = TRUE;
                                        }

                                        if (('' != $ldap_sms) && ($sms != $ldap_sms))
                                        {
                                            $this->SetUserSms($ldap_sms);
                                            $modified = TRUE;
                                        }

                                        if ($synchronized_channel != 'LDAP')
                                        {
                                            $this->SetUserSynchronizedChannel('LDAP');
                                            $modified = TRUE;
                                        }

                                        if ($synchronized_dn != $ldap_synchronized_dn)
                                        {
                                            $this->SetUserSynchronizedDn($ldap_synchronized_dn);
                                            $modified = TRUE;
                                        }

                                        if (('' != $this->GetLdapDomainControllers()) && ($synchronized_server != $this->GetLdapDomainControllers()))
                                        {
                                            $this->SetUserSynchronizedServer($this->GetLdapDomainControllers());
                                            $modified = TRUE;
                                        }

                                        // We set to the default value for LDAP password if the user is updated by synchronization
                                        $this->SetUserRequestLdapPassword($this->GetDefaultRequestLdapPwd());

                                        $this->SetUserSynchronizedTime();
                                        
                                        $this->WriteUserData(TRUE, $modified); // $automatically = TRUE, $update_last_change = $modified
                                        if ($modified) {
                                            $this->SyncUserModified(false, $user);
                                            $modified_counter++;
                                        }
                                    }
                                }
                            }
                        }
                    } // Loop of LDAP parsing and synchronization
                    while ($one_user = $ldap_connection->one_user_info(FALSE, NULL, NULL, TRUE)); // $group_cn_cache_only = TRUE

                    if (function_exists('ldap_control_paged_result_response'))
                    {
                        ldap_control_paged_result_response($ldap_connection->_conn, $ldap_connection->_oui_sr, $page_cookie);
                    }
                } // ldap pagination loop
                while (($page_cookie !== null) && ($page_cookie != ''));

                if (function_exists('ldap_control_paged_result'))
                {
                    // Reset LDAP paged result
                    ldap_control_paged_result($ldap_connection->_conn, 1000);
                }

                // Loop on all existing users to disable the "not-synchronized-yet" synchronized users
                $one_user = $this->GetNextUserArray(TRUE);
                do
                {
                    if (isset($one_user['user']))
                    {
                        $modified_user = $one_user['user'];
                        $modified_description = $one_user['description'];
                        $modified_email = $one_user['email'];
                        $modified_enabled = $one_user['enabled'];
                        $modified_locked = $one_user['locked'];
                        $modified_sms = $one_user['sms'];
                        $modified_synchronized = $one_user['synchronized'];
                        $modified_synchronized_channel = $one_user['synchronized_channel'];
                        $modified_synchronized_dn = $one_user['synchronized_dn'];
                        $modified_synchronized_server = $one_user['synchronized_server'];
                        $modified_synchronized_time = $one_user['synchronized_time'];
                        $modified_token_serial = $one_user['token'];
                        if (($modified_synchronized) && ($modified_synchronized_time < $start_sync_time))
                        // The existing user is enabled and marked as synchronized but is not in the external database/LDAP
                        {
                            if ($modified_enabled)
                            {
                                $this->SetUser($modified_user);
                                $this->SetUserActivated(0);
                                $this->WriteUserData(TRUE);
                                $modified_counter++;
                            }
                        }
                    }
                }
                while ($one_user = $this->GetNextUserArray());
                

                $time_info = gmdate("H:i:s", time()-$start_sync_time);
                $info_txt = '';
                
                if ($modified_counter > 0)
                {
                    $ldap_counter_suffix = ((1 < $modified_counter)?'s':'');
                    $info_txt.= $modified_counter." user$ldap_counter_suffix updated";
                }
                if ($ldap_created_counter > 0)
                {
                    if ('' != $info_txt)
                    {
                        $info_txt.= ', ';
                    }
                    $ldap_counter_suffix = ((1 < $ldap_created_counter)?'s':'');
                    $info_txt.= $ldap_created_counter." user$ldap_counter_suffix created";
                }
                if ('' == $info_txt)
                {
                    $info_txt = 'No modification about LDAP users';
                }
                $this->WriteLog("Info: $info_txt (processed in $time_info)", FALSE, FALSE, 19, 'LDAP', '');
            } // We have done this loop only if there was no error before
        } // End of successful LDAP parameters
        else
        {
            $this->EnableLdapError();
            $this->WriteLog("Error: no LDAP connection information", FALSE, FALSE, 30, 'LDAP', '');
        }
        return $result;
    }


    // It's possible to overload this stub in order to do something when the current user is modified (or created)
    function SyncUserModified($created = false, $user = '') {
        return true;
    }


    function CheckLdapAuthentication()
    /**
     * @brief   Write information in the log file/database, to the syslog server and on the screen
     *
     * @retval  boolean   Result of the test
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.2.4.2
     * @date    2014-04-13
     * @since   2014-02-07
     */
    {
        $result = FALSE;
        if (!function_exists('ldap_connect'))
        {
            $this->WriteLog("Error: PHP LDAP library is not installed", FALSE, FALSE, 299, 'System', '');
        }
        elseif (('' != $this->GetLdapDomainControllers()) && ('' != $this->GetLdapBindDn()) && ('' != $this->GetLdapServerPassword()))
        {
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            $ldap_options = array('account_suffix'     => $this->GetLdapAccountSuffix(),
                                  'ad_password'        => $this->GetLdapServerPassword(),
                                  'ad_username'        => $this->GetLdapBindDn(),
                                  'base_dn'            => $this->GetLdapBaseDn(),
                                  'cn_identifier'      => $this->GetLdapCnIdentifier(),
                                  'domain_controllers' => $domain_controllers,
                                  'group_attribute'    => $this->GetLdapGroupAttribute(),
                                  'group_cn_identifier'=> $this->GetLdapGroupCnIdentifier(),
                                  'ldap_server_type'   => $this->GetLdapServerType(),
                                  'network_timeout'    => $this->GetLdapNetworkTimeout(),
                                  'port'               => $this->GetLdapPort(),
                                  'recursive_groups'   => TRUE,
                                  'time_limit'         => $this->GetLdapTimeLimit(),
                                  'use_ssl'            => $this->IsLdapSsl()
                                 );

            define('LDAP_OPT_DIAGNOSTIC_MESSAGE', 0x0032);
            
            $domain_controllers = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$this->GetLdapDomainControllers()))));
            mt_srand(doubleval(microtime()) * 100000000); // for older php versions
            $domain_controller = ($domain_controllers[array_rand($domain_controllers)]);
            
            
            foreach($domain_controllers as $dc)
            {
                $port = $this->GetLdapPort();
                $controller = $dc;
                $protocol = "ldap://";
                if ($this->IsLdapSsl())
                {
                    $protocol = "ldaps://";
                }
                $pos = strpos($dc, "://");
                if ($pos !== FALSE)
                {
                    $protocol = substr($dc, 0, $pos+3);
                    $dc = substr($dc, $pos+3);
                }
                $pos = strpos($dc, ":");
                if ($pos !== FALSE)
                {
                    $port = substr($dc, $pos+1);
                    $dc = substr($dc, 0, $pos);
                }

                /* DEBUG
                echo "DEBUG PROTOCOL: ".$protocol.$dc.":".$port."\n";
                if ($this->GetVerboseFlag())
                {
                    ldap_set_option(NULL, LDAP_OPT_DEBUG_LEVEL, 7);
                }
                */
                
                if ($ldapconn = @ldap_connect($protocol.$dc.":".$port))
                {
                    ldap_set_option($ldapconn, LDAP_OPT_PROTOCOL_VERSION, 3);
                    ldap_set_option($ldapconn, LDAP_OPT_REFERRALS, 0);
                    if (@ldap_bind($ldapconn, ($this->GetLdapBindDn().$this->GetLdapAccountSuffix()), ($this->GetLdapServerPassword())))
                    {
                        /*
                        echo "DEBUG\n";
                        if (ldap_get_option($ldapconn, LDAP_OPT_DIAGNOSTIC_MESSAGE, $extended_error))
                        {
                            echo "Error Binding to LDAP: $extended_error";
                        }
                        else
                        {
                            echo "Error Binding to LDAP: No additional information is available.";
                        }
                        */
                        $result = TRUE;
                    }
                    else
                    {
                        // echo "DEBUG LDAP: ".ldap_error($ldapconn);
                    }
                    @ldap_unbind($ldapconn);
                }
                if ($result)
                {
                    break;
                }
            }
        }
        return $result;
    }


    function SetTokenDataReadFlag($flag)
    {
        $this->_token_data_read_flag = $flag;
    }


    function GetTokenDataReadFlag()
    {
        return $this->_token_data_read_flag;
    }


    function SetBaseDir($base_dir)
    {
        $this->_base_dir = $this->ConvertToUnixPath($base_dir);
    }


    function GetBaseDir()
    {
        return ($this->_base_dir);
    }


    function GetScriptFolder()
    /**
     * @brief   Get the folder of this script.
     *
     * @retval  string  Full path to the script folder.
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.0.7
     * @date    2013-08-28
     * @since   2010-06-07
     */
    {
        if ('' != $this->GetBaseDir())
        {
            $current_script_folder_detected = $this->ConvertToUnixPath($this->GetBaseDir());
        }
        else
        {
            $current_script_folder_detected = $this->ConvertToUnixPath(dirname(__FILE__));
        }

        if (substr($current_script_folder_detected,-1) != "/")
        {
            $current_script_folder_detected.="/";
        }
        return $this->ConvertToWindowsPathIfNeeded($current_script_folder_detected);
    }


    function ConvertToUnixPath($path)
    {
        return str_replace("\\","/",$path);
    }


    function ConvertToWindowsPathIfNeeded($path)
    {
        $result = $path;
        if (FALSE !== strpos($result,":"))
        {
            $result = str_replace("/","\\",$result);
        }
        return $result;
    }


    function GetReplyMessageForRadius()
    {
        return (isset($this->_reply_array_for_radius[0])?$this->_reply_array_for_radius[0]:'');
    }


    function SetReplyMessageForRadius($value)
    {
        $this->_reply_array_for_radius = array();
        $this->AddReplyArrayMessageForRadius($value);
    }


    function GetReplyArrayForRadius()
    {
        return $this->_reply_array_for_radius;
    }


    function AddReplyArrayForRadius($value)
    {
        $this->_reply_array_for_radius[] = $value;
    }


    // Adding extra information for the result (if any)
    Function AddExtraRadiusInfo()
    {
        $group = trim($this->GetUserGroup());
        if (('' != $group) && ('' != $this->GetGroupAttribute()))
        {
            $this->AddReplyArrayForRadius($this->GetGroupAttribute().$this->GetRadiusReplyAttributor().'"'.$group.'"');
        }
        if (('' != $this->GetLastClearOtpValue()) && ('' != $this->GetClearOtpAttribute()))
        {
            $this->AddReplyArrayForRadius($this->GetClearOtpAttribute().$this->GetRadiusReplyAttributor().'"'.$this->GetLastClearOtpValue().'"');
        }
    }


    function SetVerboseLogPrefix($value)
    {
        $this->_config_data['verbose_log_prefix'] = $value;
    }


    function GetVerboseLogPrefix()
    {
        return $this->_config_data['verbose_log_prefix'];
    }


    function SetAttributesToEncrypt($attributes_to_encrypt)
    {
        $attributes = trim($attributes_to_encrypt);
        if (('' != $attributes) && ('*' == substr($attributes,0,1)) && ('*' == substr($attributes,-1)))
        {
            $this->_attributes_to_encrypt = $attributes;
        }
    }


    function GetAttributesToEncrypt()
    {
        return $this->_attributes_to_encrypt;
    }



    function SetUsersFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_users_folder = $new_folder;
        if (!file_exists($new_folder))
        {
            if (!@mkdir($new_folder))
            {
                $this->WriteLog("Error: Unable to create the missing users folder ".$new_folder, FALSE, FALSE, 28, 'System', '');
            }
        }
    }


    function GetUsersFolder()
    {
        if ('' == $this->_users_folder)
        {
            $this->SetUsersFolder($this->GetScriptFolder()."users/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_users_folder);
    }


    function SetDevicesFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_devices_folder = $new_folder;
        if (!file_exists($new_folder))
        {
            if (!@mkdir($new_folder))
            {
                $this->WriteLog("Error: Unable to create the missing devices folder ".$new_folder, FALSE, FALSE, 28, 'System', '');
            }
        }
    }


    function GetDevicesFolder()
    {
        if ('' == $this->_devices_folder)
        {
            $this->SetDevicesFolder($this->GetScriptFolder()."devices/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_devices_folder);
    }


    function SetQrCodeFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_qrcode_folder = $new_folder;
    }


    function GetQrCodeFolder()
    {
        if ('' == $this->_qrcode_folder)
        {
            $this->SetQrCodeFolder($this->GetScriptFolder()."qrcode/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_qrcode_folder);
    }


    function SetTemplatesFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_templates_folder = $new_folder;
    }


    function GetTemplatesFolder()
    {
        if ('' == $this->_templates_folder)
        {
            $this->SetTemplatesFolder($this->GetScriptFolder()."templates/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_templates_folder);
    }


    function SetGroupsFolder($folder)
    {
        $new_folder = $this->ConvertToUnixPath($folder);
        if (substr($new_folder,-1) != "/")
        {
            $new_folder.="/";
        }
        $new_folder = $this->ConvertToWindowsPathIfNeeded($new_folder);
        $this->_groups_folder = $new_folder;
        if (!file_exists($new_folder))
        {
            if (!@mkdir($new_folder))
            {
                $this->WriteLog("Error: Unable to create the missing groups folder ".$new_folder, FALSE, FALSE, 28, 'System', '');
            }
        }
    }


    function GetGroupsFolder()
    {
        if ('' == $this->_groups_folder)
        {
            $this->SetGroupsFolder($this->GetScriptFolder()."groups/");
        }
        return $this->ConvertToWindowsPathIfNeeded($this->_groups_folder);
    }


    function SendSms($sms_recipient, $sms_message_to_send, $real_user = '', $originator = '', $provider = '', $userkey = '', $password = '', $api_id = '', $write_log = TRUE)
    {
        $sms_number = $this->CleanPhoneNumber($sms_recipient);

        $result = 62;
        
        $sms_originator = (('' != $originator)?$originator:$this->GetSmsOriginator());
        $sms_provider = strtolower((('' != $provider)?$provider:$this->GetSmsProvider()));
        $sms_userkey = (('' != $userkey)?$userkey:$this->GetSmsUserkey());
        $sms_password = (('' != $password)?$password:$this->GetSmsPassword());
        $sms_api_id = (('' != $api_id)?$api_id:$this->GetSmsApiId());
       
        if ("aspsms" == $sms_provider)
        {
            $sms_message = new MultiotpAspSms($sms_userkey, $sms_password);
            $sms_message->setOriginator($sms_originator);
            $sms_message->setRecipient($sms_number);
            $sms_message->setContent(decode_utf8_if_needed($sms_message_to_send));
            $sms_result = intval($sms_message->sendSMS());
            
            if (1 != $sms_result)
            {
                $result = 61; // ERROR: SMS code request received, but an error occurred during transmission
                if ($write_log)
                {
                    $this->WriteLog("Error: SMS code request received for ".$real_user.", but the ".$sms_provider." error ".$sms_result." occurred during transmission to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
            else
            {
                $result = 18; // INFO: SMS code request received
                if ($write_log)
                {
                    $this->WriteLog("Info: SMS code request received for ".$real_user." and sent via ".$sms_provider." to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
        }
        elseif ("clickatell" == $sms_provider)
        {
            $sms_message = new MultiotpClickatell($sms_userkey, $sms_password, $sms_api_id);
            $sms_message->useRegularServer();
            $sms_message->setOriginator($sms_originator);
            $sms_message->setRecipient($sms_number);
            $sms_message->setContent(encode_utf8_if_needed($sms_message_to_send));
            $sms_result = intval($sms_message->sendSMS());
            
            if (1 != $sms_result)
            {
                $result = 61; // ERROR: SMS code request received, but an error occurred during transmission
                if ($write_log)
                {
                    $this->WriteLog("Error: SMS code request received for ".$real_user.", but the ".$sms_provider." error ".$sms_result." occurred during transmission to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
            else
            {
                $result = 18; // INFO: SMS code request received
                if ($write_log)
                {
                    $this->WriteLog("Info: SMS code request received for ".$real_user." and sent via ".$sms_provider." to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
        }
        elseif ("intellisms" == $sms_provider)
        {
            $sms_message = new MultiotpIntelliSms($sms_userkey, $sms_password);
            $sms_message->useRegularServer();
            $sms_message->setOriginator($sms_originator);
            $sms_message->setRecipient($sms_number);
            $sms_message->setContent(encode_utf8_if_needed($sms_message_to_send));
            $sms_result = $sms_message->sendSMS();
            
            if ("ID" != substr($sms_result,0,2))
            {
                $result = 61; // ERROR: SMS code request received, but an error occurred during transmission
                if ($write_log)
                {
                    $this->WriteLog("Error: SMS code request received for ".$real_user.", but the ".$sms_provider." error ".$sms_result." occurred during transmission to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
            else
            {
                $result = 18; // INFO: SMS code request received
                if ($write_log)
                {
                    $this->WriteLog("Info: SMS code request received for ".$real_user." and sent via ".$sms_provider." to ".$sms_number, FALSE, FALSE, $result, 'SMS', $real_user);
                }
            }
        }
        elseif ("exec" == $sms_provider)
        {
            $exec_cmd = $sms_api_id;
            $exec_cmd = str_replace('%from', $sms_originator, $exec_cmd);
            $exec_cmd = str_replace('%to',  $sms_number,  $exec_cmd);
            $exec_cmd = str_replace('%msg',  encode_utf8_if_needed($sms_message_to_send),  $exec_cmd);
            exec($exec_cmd, $output);
            $result = 18; // INFO: SMS code request received
            if ($write_log)
            {
                $this->WriteLog("Info: SMS code request received for ".$real_user." and sent via ".$exec_cmd, FALSE, FALSE, $result, 'SMS', $real_user);
            }
        }
        else
        {
            $result = 62; // ERROR: SMS provider not supported
            if ($write_log)
            {
                $this->WriteLog("Error: SMS provider ".$sms_provider." not supported", FALSE, FALSE, $result, 'SMS', $real_user);
            }
        }
        return $result;
    }


    function GenerateSmsToken($user = '')
    {
        $now_epoch = time();
        if ('' != $user)
        {
            $this->SetUser($user);
        }
        else
        {
            $user = $this->GetUser();
        }
        $sms_number = $this->CleanPhoneNumber($this->GetUserSms());
        if ('' != $sms_number)
        {
            $sms_message_prefix = trim($this->GetSmsMessage());
            $sms_now_steps = $now_epoch;
            $sms_digits = $this->GetSmsDigits();
            $sms_seed_bin = hex2bin(md5('sMs'.$this->GetEncryptionKey().$this->GetUserTokenSeed().$user.$now_epoch));
            $sms_token = $this->GenerateOathHotp($sms_seed_bin,$sms_now_steps,$sms_digits);
            $this->SetUserSmsOtp($sms_token);
            $this->SetUserSmsValidity($now_epoch + $this->GetSmsTimeout());

            $sms_nice_token = $this->ConvertToNiceToken($sms_token);
            
            if (FALSE !== strpos($sms_message_prefix, '%s'))
            {
                $sms_message_to_send = sprintf($sms_message_prefix, $sms_nice_token);
            }
            else
            {
                $sms_message_to_send = $sms_message_prefix.' '.$sms_nice_token;
            }

            $result = $this->SendSms($sms_number, $sms_message_to_send, $user);
        }
        else
        {
            $result = 60; // ERROR: no information on where to send SMS code
            $this->WriteLog("Error: no information on where to send SMS code for ".$real_user, FALSE, FALSE, $result, 'SMS', $real_user);
        }
        $this->WriteUserData();
        return $result;
    }


    function ConvertToNiceToken($regular_token)
    {
        $token_length = strlen($regular_token);
        if (9 <= $token_length)
        {
            $sms_nice_token = substr($regular_token,0,3).'-'.substr($regular_token,3,3).'-'.substr($regular_token,6,($token_length-6));
        }
        elseif (6 < $token_length)
        {
            $sms_nice_token = substr($regular_token,0,intval($token_length/2)).'-'.substr($regular_token,intval($token_length/2),$token_length);
        }
        else
        {
            $sms_nice_token = $regular_token;
        }
        return $sms_nice_token;
    }


    /**
     * @brief   Resync the token of a user and return true or false
     *
     * @param   string  $user                  User to check
     * @param   string  $input                 Token to check
     * @param   string  $input_sync            Second token to check for resync
     * @param   string  $display_status        Display the status bar
     * @param   string  $ignore_lock           Ignore the fact that the user is locked
     * @param   string  $resync_enc_pass       Resynchronization with an encrypted password
     * @param   string  $no_server_check       Ignore any server(s) (if any)  to do the check
     * @param   string  $self_register_serial  Serial number of the self registered hardware token
     *                                          (if any, and not combined as a prefix of the input)
     * @param   string  $hardware_tokens_list  Comma separated list of hardware tokens also attributed
     * @return  boolean                        Resync was successful or not
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.3.0.0
     * @date    2014-11-04
     * @since   2014-10-17
     */
    function ResyncUserToken($user = '',
                             $input = '',
                             $input_sync = '',
                             $display_status = FALSE,
                             $ignore_lock = FALSE,
                             $resync_enc_pass = FALSE,
                             $no_server_check = FALSE,
                             $self_register_serial = '',
                             $hardware_tokens_list = '')
    {
        $the_hardware_tokens_list = $hardware_tokens_list;
        if ('' != $user)
        {
            $this->SetUser($user);
            $the_hardware_tokens_list = $this->GetUserTokenSerialNumber();
        }
        $result = $this->ResyncToken($input,
                                     $input_sync,
                                     $display_status,
                                     $ignore_lock,
                                     $resync_enc_pass,
                                     $no_server_check,
                                     $self_register_serial,
                                     $the_hardware_tokens_list);
        return $result;
    }


    /**
     * @brief   Resync the token of the current user and return true or false
     *
     * @param   string  $input                 Token to check
     * @param   string  $input_sync            Second token to check for resync
     * @param   string  $display_status        Display the status bar
     * @param   string  $ignore_lock           Ignore the fact that the user is locked
     * @param   string  $resync_enc_pass       Resynchronization with an encrypted password
     * @param   string  $no_server_check       Ignore any server(s) (if any)  to do the check
     * @param   string  $self_register_serial  Serial number of the self registered hardware token
     *                                          (if any, and not combined as a prefix of the input)
     * @param   string  $hardware_tokens_list  Comma separated list of hardware tokens also attributed
     * @return  boolean                        Resync was successful or not
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.3.0.0
     * @date    2014-11-04
     * @since   2014-10-17
     */
    function ResyncToken($input = '',
                         $input_sync = '',
                         $display_status = FALSE,
                         $ignore_lock = FALSE,
                         $resync_enc_pass = FALSE,
                         $no_server_check = FALSE,
                         $self_register_serial = '',
                         $hardware_tokens_list = '')
    {
        $result = $this->CheckToken($input,
                                    $input_sync,
                                    $display_status,
                                    $ignore_lock,
                                    $resync_enc_pass,
                                    $no_server_check,
                                    $self_register_serial,
                                    $hardware_tokens_list);

        // Both resynchronization and authentication are TRUE
        return (($result == 14) || ($result == 0));
    }


    /**
     * @brief   Check the token of a user and give the result, with resync options.
     *
     * @param   string  $user                  User to check
     * @param   string  $input                 Token to check
     * @param   string  $input_sync            Second token to check for resync
     * @param   string  $display_status        Display the status bar
     * @param   string  $ignore_lock           Ignore the fact that the user is locked
     * @param   string  $resync_enc_pass       Resynchronization with an encrypted password
     * @param   string  $no_server_check       Ignore any server(s) (if any)  to do the check
     * @param   string  $self_register_serial  Serial number of the self registered hardware token
     *                                          (if any, and not combined as a prefix of the input)
     * @param   string  $hardware_tokens_list  Comma separated list of hardware tokens also attributed
     * @return  int                            Error code (0: successful authentication, 1n: info, >=20: error)
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.1.1
     * @date    2014-01-15
     * @since   2010-08-12
     */
    function CheckUserToken($user = '',
                            $input = '',
                            $input_sync = '',
                            $display_status = FALSE,
                            $ignore_lock = FALSE,
                            $resync_enc_pass = FALSE,
                            $no_server_check = FALSE,
                            $self_register_serial = '',
                            $hardware_tokens_list = '')
    {
        $the_hardware_tokens_list = $hardware_tokens_list;
        if ('' != $user)
        {
            $this->SetUser($user);
            $the_hardware_tokens_list = $this->GetUserTokenSerialNumber();
        }
        return $this->CheckToken($input,
                                 $input_sync,
                                 $display_status,
                                 $ignore_lock,
                                 $resync_enc_pass,
                                 $no_server_check,
                                 $self_register_serial,
                                 $the_hardware_tokens_list);
    }


    /**
     * @brief   Check the token of the actual user and give the result, with resync options.
     *
     * @param   string  $input                 Token to check
     * @param   string  $input_sync_param      Second token to check for resync
     * @param   string  $display_status        Display the status bar
     * @param   string  $ignore_lock           Ignore the fact that the user is locked
     * @param   string  $resync_enc_pass       Resynchronization with an encrypted password
     * @param   string  $no_server_check       Ignore any server(s) (if any)  to do the check
     * @param   string  $self_register_serial  Serial number of the self registered hardware token
     *                                          (if any, and not combined as a prefix of the input)
     * @param   string  $hardware_tokens_list  Comma separated list of hardware tokens also attributed
     *
     * @return  int                            Error code (0: successful authentication, 1n: info, >=20: error)
     *
     * @author  Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
     * @version 4.3.2.2
     * @date    2015-06-09
     * @since   2010-06-07
     */
    function CheckToken(
        $input = '',
        $input_sync_param = '',
        $display_status = FALSE,
        $ignore_lock = FALSE,
        $resync_enc_pass = FALSE,
        $no_server_check = FALSE,
        $self_register_serial = '',
        $hardware_tokens_list = ''
        ) {

        $this->SetLastClearOtpValue();
        $calculated_token = '';

        $input_sync = $input_sync_param;
        
        // 4.3.2.2
        // As external passwords are now supported,
        // we cannot trim or remove the minus anymore.
        // We disabled trim(str_replace('-','',$input))
        $input_to_check = $input;
        $real_user = $this->GetUser();
        // We don't accept any input without at least 3 characters (like 'sms')
        if (strlen($input_to_check) < 3) {
            $input_to_check = "! <3 digits";
        }
        
        $server_result = -1;
        // Check on the external server(s) first
        if ((!$no_server_check) && ('' != $this->GetServerUrl())) {
            // For multi-account definition, we are also looking on the server(s) if any
            if ($this->ReadUserData($real_user)) {
                // multi account works only if authentication is done with PAP
                if (1 == intval($this->GetUserMultiAccount())) {
                    $pos = strrpos($input_to_check, " ");
                    if ($pos !== FALSE) {
                        $real_user = substr($input_to_check,0,$pos);
                        $input_to_check = trim(substr($input_to_check,$pos+1));
                        if (strlen($input_to_check) < 3) {
                            $input_to_check = "! <3 digits";
                        }
                    }
                }
            }
        
            if ('' != $this->GetChapPassword()) {
                if (32 < strlen($this->GetChapPassword())) {
                    $hex_id = substr($this->GetChapPassword(),0,2);
                } else {
                    $hex_id = $this->GetChapId();
                }
        
                $server_result = $this->CheckUserTokenOnServer($real_user, $this->GetChapPassword(), 'CHAP', $hex_id, $this->GetChapChallenge());
            } else {
                $server_result = $this->CheckUserTokenOnServer($real_user, $input_to_check);
            }

            if ($this->_xml_dump_in_log) {
                $this->WriteLog("Debug: CheckUserTokenOnServer returns ".$server_result, FALSE, FALSE, 8888, 'Debug', '');
            }
        }

        if ($this->GetVerboseFlag() && $this->IsKeepLocal()) {
            $this->WriteLog("Info: *Local users are kept locally", FALSE, FALSE, 8888, 'System', '');
        }
        if (0 == $server_result) {
            $result = 0;
            $this->WriteLog("Info: User ".$this->GetUser()." successfully logged in using an external server", FALSE, FALSE, $result, 'User');
        } elseif (18 == $server_result) {
            $result = 18; // ERROR: User doesn't exist. (on the server)
            $this->WriteLog("Info: SMS code request received and sent for ".$this->GetUser()." to ".$this->CleanPhoneNumber($this->GetUserSms()), FALSE, FALSE, $result, 'SMS', $this->GetUser());
        } elseif ((21 == $server_result) && (!$this->IsKeepLocal())) {
            $this->DeleteUser($real_user, TRUE); // $no_error_info = TRUE
            $result = 21; // ERROR: User doesn't exist. (on the server)
            $this->WriteLog("Error: User ".$this->GetUser()." doesn't exist", FALSE, FALSE, $result, 'User');
        } elseif ((($server_result >= 0) && (22 <= $server_result) && (70 > $server_result)) || (90 <= $server_result)) {
            // We want to stop only if it's an error (but not -1), except if the user doesn't exist (>= 22), if it's a 7x (server) or 8x (cache) error
            $result = $server_result;
            // Already logged using CheckUserTokenOnServer
            // $this->WriteLog("Error: server sent back the error ".$server_result, FALSE, FALSE, $result, 'Server', '');
        } elseif (!$this->ReadUserData($real_user, FALSE, TRUE)) {
            // LOCALLY ONLY
            $result = 21; // ERROR: User doesn't exist.
            $this->WriteLog("Error: User ".$this->GetUser()." doesn't exist", FALSE, FALSE, $result, 'User');
        } else {
            // *********************************************
            // Let's go for the whole authentication process
            // *********************************************
            $result = 99; // Unknown error

            // multi account works only if authentication is done with PAP
            if (1 == intval($this->GetUserMultiAccount())) {
                $pos = strrpos($input_to_check, " ");
                if ($pos !== FALSE) {
                    $real_user = substr($input_to_check,0,$pos);
                    $input_to_check = trim(substr($input_to_check,$pos+1));
                    if (strlen($input_to_check) < 3) {
                        $input_to_check = "! <3 digits";
                    }
                }
        
                // LOCALLY ONLY
                if (!$this->ReadUserData($real_user, FALSE, TRUE)) {
                    $result = 34; // ERROR: linked user doesn't exist.
                    $this->WriteLog("Error: linked user ".$real_user." doesn't exist", FALSE, FALSE, $result, 'User', $real_user);
                    return $result;
                }
            }

            // From here now, we know already which user we are testing exactly
            
                
            // First we check if the users is activated or not.
            if (1 != $this->GetUserActivated()) {
                $result = 38; // ERROR: User is desactivated.
                $this->WriteLog("Error: User ".$real_user." is desactivated", FALSE, FALSE, $result, 'User', $real_user);
                return $result;
            }

            $detected_serial_number = '';

            // Check if self-registration of tokens is enabled and try the autoregistration if needed
            if ($this->IsSelfRegistrationEnabled()) {
                // Self-registration serial number is directly given in the dedicated field
                if ('' != $self_register_serial) {
                    if ($this->CheckTokenExists($self_register_serial)) {
                        $detected_serial_number = $self_register_serial;
                    }
                }
            }
            
            if ('' == $detected_serial_number) {
                // Looking for an existing token with this serial number
                $token_serial_number_length = $this->GetTokenSerialNumberLength();
                $token_serial_number_length_array = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$token_serial_number_length))));
                foreach($token_serial_number_length_array as $one_serial_number_length) {
                    if (intval($one_serial_number_length) > 0) {
                        $token_otp_list_of_length = $this->GetTokenOtpListOfLength();
                        $token_otp_list_of_length_array = explode(" ",trim(str_replace(","," ",str_replace(";"," ",$token_otp_list_of_length))));
                        foreach($token_otp_list_of_length_array as $one_token_otp_length) {
                            if (intval($one_token_otp_length) > 0) {
                                if (strlen($input_to_check) >= (intval($one_serial_number_length) + intval($one_token_otp_length))) {
                                    $check_serial = substr($input_to_check,
                                                           -(intval($one_serial_number_length)+intval($one_token_otp_length)),
                                                           -intval($one_token_otp_length)
                                                          );
                                    if ($this->CheckTokenExists($check_serial)) {
                                        $detected_serial_number = $check_serial;
                                        /*
                                        $input_to_check = substr($input_to_check,
                                                                 0,
                                                                 -(intval($one_serial_number_length)+intval($one_token_otp_length))
                                                                ).
                                                          substr($input_to_check,
                                                                 -intval($one_token_otp_length)
                                                                );
                                        */
                                        // It can appears twice, so we do a replace
                                        $input_to_check = str_replace($detected_serial_number, '', $input_to_check);
                                        break(2);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            
            // If detected, we remove the serial number in the input_sync
            if ('' != $detected_serial_number) {
                $input_sync = str_replace($detected_serial_number, '', $input_sync);
            }


            if ($this->IsSelfRegistrationEnabled()) {
                // echo "DEBUG SelfRegisterHardwareToken: $detected_serial_number / $self_input_to_check\n";

                // TODO check if the serial number is in the list (instead of a single token)
                if (('' != $detected_serial_number) && ($detected_serial_number != $this->GetUserTokenSerialNumber())) {
                    $result = $this->SelfRegisterHardwareToken($real_user,$detected_serial_number, $input_to_check, $input);
                    if (0 == $result) {
                        return $result;
                    }
                }
            }

            // From here now, we know already which user we are testing exactly,
            // and also if a serial number is defined (and the input to check has been recalculated).
            // TODO: Without serial number we have to check with all tokens attributed to this user
            
            $now_epoch = time();
            
            if (($this->GetUserAutolockTime() > 0) && ($this->GetUserAutolockTime() < $now_epoch)) {
                $result = 81; // ERROR: Cache too old for this user, account autolocked
                $this->WriteLog("Error: cache too old for user ".$real_user.", account autolocked.", FALSE, FALSE, $result, 'User', $real_user);
                return $result;
            }

            if ('' != $this->GetChapPassword()) {
                $input_to_check = $this->GetChapPassword();
            } elseif ('' != $this->GetMsChapResponse()) {
                $input_to_check = $this->GetMsChapResponse();
            } elseif ('' != $this->GetMsChap2Response()) {
                $input_to_check = $this->GetMsChap2Response();
            }

            // Check if we have to validate an SMS code
            if ($this->GetUserSmsValidity() > $now_epoch) {
                $ldap_check_passed = FALSE;
                $ldap_to_check = 'LDAP_FALSE';
                
                // AD/LDAP case
                if ((1 == $this->GetUserPrefixPin()) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                    $code_confirmed = $this->GetUserSmsOtp();
                    $this->SetLastClearOtpValue($code_confirmed);
                    $code_to_check = substr($input_to_check, -strlen($code_confirmed));
                    $ldap_to_check = substr($input_to_check, 0, strlen($input_to_check) - strlen($code_to_check));
                    if ($code_to_check == $code_confirmed) {
                        if (('' != $ldap_to_check) && ($this->CheckUserLdapPassword($this->GetUserSynchronizedDn(), $ldap_to_check))) {
                            $ldap_check_passed = TRUE;
                            if ($this->IsCacheLdapHash()) {
                                // The LDAP password is stored in a cache
                                $this->SetUserLdapHashCache(bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check))));
                            }
                        } elseif ($this->IsCacheLdapHash()) {
                            if (!$this->IsLdapServerReachable()) {
                                if ($this->GetVerboseFlag()) {
                                    $this->WriteLog("Debug: user LDAP password checked in the cache", FALSE, FALSE, 8888, 'Debug', '');
                                }
                                if ($this->GetUserLdapHashCache() == bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check)))) {
                                    $ldap_check_passed = TRUE;
                                    // TODO Write a specific message in the log
                                }
                            } else {
                                $ldap_check_passed = FALSE;
                                $ldap_to_check = 'LDAP_FALSE';
                                $this->ResetUserLdapHashCache();
                                if ($this->GetVerboseFlag()) {
                                    $this->WriteLog("Debug: user LDAP password false, hash cache cleared", FALSE, FALSE, 8888, 'Debug', '');
                                }
                            }
                        }
                    }
                } else {
                    // It is a real prefix pin, not an LDAP/AD prefix
                    $code_confirmed = ((1 == $this->GetUserPrefixPin())?$this->GetUserPin():'').$this->GetUserSmsOtp();
                    $this->SetLastClearOtpValue($code_confirmed);
                    if ('' != $this->GetChapPassword()) {
                        $code_confirmed = $this->CalculateChapPassword($code_confirmed);
                    } elseif ('' != $this->GetMsChapResponse()) {
                        $code_confirmed = $this->CalculateMsChapResponse($code_confirmed);
                    } elseif ('' != $this->GetMsChap2Response()) {
                        $code_confirmed = $this->CalculateMsChap2Response($real_user, $code_confirmed);
                    }
                }

                if ($ldap_check_passed || ($input_to_check == $code_confirmed)) {
                    $this->SetUserSmsOtp(md5($this->GetEncryptionKey().mt_rand(100000,999999).$this->GetUserTokenSeed().$now_epoch)); // Now SMS code is no more available, and the next one is difficult to guess ;-)
                    $this->SetUserSmsValidity($now_epoch); // And the validity time is set to the successful login time

                    // We are unlocking the user if needed
                    $this->SetUserErrorCounter(0);
                    $this->SetUserLocked(0);
                    // Finally, we update the last login of the user
                    $this->SetUserTokenLastLogin($now_epoch);
                    $result = 0; // OK: This is the correct token
                    if (!$this->WriteUserData()) {
                        $result = 28; // ERROR: Unable to write the changes in the file
                        $this->WriteLog("Error: Unable to write the changes in the file for the user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                    } else {
                        $this->WriteLog("Ok: User ".$this->GetUser()." successfully logged in with SMS token", FALSE, FALSE, $result, 'User');
                    }
                    
                    if (0 == $result) {
                        $this->AddExtraRadiusInfo();
                    }
                    return $result;
                }
            }
            
            // Check if we have to validate a scratch password
            foreach ($this->GetUserScratchPasswordsArray() as $one_password) {
                // AD/LDAP case
                if ((1 == $this->GetUserPrefixPin()) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                    $ldap_check_passed = FALSE;
                    $ldap_to_check = 'LDAP_FALSE';

                    $code_confirmed = $one_password;
                    $this->SetLastClearOtpValue($code_confirmed);
                    $code_to_check = substr($input_to_check, -strlen($code_confirmed));
                    $ldap_to_check = substr($input_to_check, 0, strlen($input_to_check) - strlen($code_to_check));
                    
                    if ($code_to_check == $code_confirmed) {
                        if (('' != $ldap_to_check) && ($this->CheckUserLdapPassword($this->GetUserSynchronizedDn(), $ldap_to_check))) {
                            $ldap_check_passed = TRUE;
                            if ($this->IsCacheLdapHash()) {
                                // The LDAP password is stored in a cache
                                $this->SetUserLdapHashCache(bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check))));
                            }
                        }
                        elseif ($this->IsCacheLdapHash()) {
                            if (!$this->IsLdapServerReachable()) {
                                if ($this->GetVerboseFlag()) {
                                    $this->WriteLog("Debug: user LDAP password checked in the cache", FALSE, FALSE, 8888, 'Debug', '');
                                }
                                if ($this->GetUserLdapHashCache() == bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check)))) {
                                    $ldap_check_passed = TRUE;
                                    // TODO Write a specific message in the log
                                }
                            } else {
                                $ldap_check_passed = FALSE;
                                $ldap_to_check = 'LDAP_FALSE';
                                $this->ResetUserLdapHashCache();
                                if ($this->GetVerboseFlag()) {
                                    $this->WriteLog("Debug: user LDAP password false, hash cache cleared", FALSE, FALSE, 8888, 'Debug', '');
                                }
                            }
                        }
                    }
                } else {
                    // It is a real prefix pin, not an LDAP/AD prefix
                    $code_confirmed = ((1 == $this->GetUserPrefixPin())?$this->GetUserPin():'').$one_password;
                    $this->SetLastClearOtpValue($code_confirmed);
                    if ('' != $this->GetChapPassword()) {
                        $code_confirmed = $this->CalculateChapPassword($code_confirmed);
                    } elseif ('' != $this->GetMsChapResponse()) {
                        $code_confirmed = $this->CalculateMsChapResponse($code_confirmed);
                    } elseif ('' != $this->GetMsChap2Response()) {
                        $code_confirmed = $this->CalculateMsChap2Response($real_user, $code_confirmed);
                    }
                }
                
                if ($ldap_check_passed || ($input_to_check == $code_confirmed)) {
                    // We are unlocking the regular token if needed
                    $this->SetUserErrorCounter(0);
                    $this->SetUserLocked(0);
                    // Finally, we update the last login of the user
                    $this->SetUserTokenLastLogin($now_epoch);
                    $this->RemoveUserUsedScratchPassword($one_password);
                    $result = 0; // OK: This is the correct token
                    if (!$this->WriteUserData()) {
                        $result = 28; // ERROR: Unable to write the changes in the file
                        $this->WriteLog("Error: Unable to write the changes in the file for the user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                    } else {
                        $this->WriteLog("Ok: User ".$this->GetUser()." successfully logged in with a scratch password", FALSE, FALSE, $result, 'User');
                    }
                    
                    if (0 == $result) {
                        $this->AddExtraRadiusInfo();
                    }
                    return $result;
                }
            }
            // Check if a code request per SMS is done
            $code_confirmed = 'sms';
            $code_confirmed_upper = 'SMS';
            $code_confirmed_camel = 'Sms';
            $this->SetLastClearOtpValue($code_confirmed);
            if ('' != $this->GetChapPassword()) {
                $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                $code_confirmed_upper = strtoupper($this->CalculateChapPassword($code_confirmed_upper));
                $code_confirmed_camel = strtoupper($this->CalculateChapPassword($code_confirmed_camel));
            } elseif ('' != $this->GetMsChapResponse()) {
                $code_confirmed = strtolower($this->CalculateMsChapResponse($code_confirmed));
                $code_confirmed_upper = strtoupper($this->CalculateMsChapResponse($code_confirmed_upper));
                $code_confirmed_camel = strtoupper($this->CalculateMsChapResponse($code_confirmed_camel));
            } elseif ('' != $this->GetMsChap2Response()) {
                $code_confirmed = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed));
                $code_confirmed_upper = strtoupper($this->CalculateMsChap2Response($real_user, $code_confirmed_upper));
                $code_confirmed_camel = strtoupper($this->CalculateMsChap2Response($real_user, $code_confirmed_camel));
            }
            
            // If something like 'sms' or 'SMS' is detected, we generate an SMS token
            if ((strtolower($input_to_check) == $code_confirmed) || (strtoupper($input_to_check) == $code_confirmed_upper) || (strtoupper($input_to_check) == $code_confirmed_camel)) {
                return $this->GenerateSmsToken();
            }

            // TODO check multiple tokens (loop)

            $pin               = $this->GetUserPin();
            $need_prefix       = (1 == $this->GetUserPrefixPin());
            $last_event        = $this->GetUserTokenLastEvent();
            $last_login        = $this->GetUserTokenLastLogin();
            $digits            = $this->GetUserTokenNumberOfDigits();
            $error_counter     = $this->GetUserErrorCounter();
            $time_window       = $this->GetMaxTimeWindow();
            $event_window      = $this->GetMaxEventWindow();
            $time_sync_window  = $this->GetMaxTimeResyncWindow();
            $event_sync_window = $this->GetMaxEventResyncWindow();

            $seed              = $this->GetUserTokenSeed();
            $seed_bin          = hex2bin($seed);
            $delta_time        = $this->GetUserTokenDeltaTime();
            $interval          = $this->GetUserTokenTimeInterval();
            $token_algo_suite  = $this->GetUserTokenAlgoSuite();
            if (0 >= $interval) {
                $interval = 1;
            }

            $now_steps         = intval($now_epoch / $interval);
            $step_window       = intval($time_window / $interval);
            $step_sync_window  = intval($time_sync_window / $interval);
            $last_login_step   = intval($last_login / $interval);
            $delta_step        = $delta_time / $interval;
            
            $prefix_pin = ($need_prefix?$pin:'');


            // 4.3.2.2
            // Check if resynchronisation can be done automatically
            $needed_space_pos = (strlen($input_to_check)-$digits-1);
            if (('' == $input_sync) && ($needed_space_pos >= $digits) && (($needed_space_pos === strrpos($input_to_check, ' ')) || (($needed_space_pos-strlen($prefix_pin)) === strrpos($input_to_check, ' '))) && ($this->IsAutoResync())) {
                if (($need_prefix) && ($this->IsUserRequestLdapPasswordEnabled())) {
                    $ldap_to_check = substr($input_to_check, 0, - ($digits + 1 + $digits));
                    if ('' != $ldap_to_check) {
                        if ($this->CheckUserLdapPassword($this->GetUserSynchronizedDn(), $ldap_to_check)) {
                            $input_sync = substr($input_to_check, -$digits);
                            $input_to_check = substr($input_to_check, 0, - ($digits + 1));
                        }
                    }
                } elseif ($prefix_pin == substr($input_to_check, 0, strlen($prefix_pin))) {
                        $separator_pos = strrpos($input_to_check, ' ');
                        $input_sync = str_replace($prefix_pin, '', substr($input_to_check, $separator_pos+1));
                        $input_to_check = substr($input_to_check, 0, $separator_pos);
                }
            }


            if ((1 == $this->GetUserLocked()) && ('' == $input_sync) && (!$resync_enc_pass) && (!$ignore_lock)) {
                $result = 24; // ERROR: User locked;
                $this->WriteLog("Error: User ".$this->GetUser()." locked after ".$this->GetUserErrorCounter()." failed authentications", FALSE, FALSE, $result, 'User');
            } elseif(($this->GetUserErrorCounter() >= $this->GetMaxDelayedFailures()) && ('' == $input_sync) && ($now_epoch < ($this->GetUserTokenLastError() + $this->GetMaxDelayedTime())) && (!$ignore_lock)) {
                $result = 25; // ERROR: User delayed;
                $this->WriteLog("Error: User ".$this->GetUser()." delayed for ".$this->GetMaxDelayedTime()." seconds after ".$this->GetUserErrorCounter()." failed authentications", FALSE, FALSE, $result, 'User');
            } else {
                $ldap_check_passed = FALSE;
                $ldap_to_check = 'LDAP_FALSE';
                if (($need_prefix) && ($this->IsUserRequestLdapPasswordEnabled())) {
                    if ($input_to_check != '') {
                        $ldap_to_check = substr($input_to_check, 0, strlen($input_to_check) - $digits);
                        if ('' != $ldap_to_check) {
                            if ($this->CheckUserLdapPassword($this->GetUserSynchronizedDn(), $ldap_to_check)) {
                                $ldap_check_passed = TRUE;
                                // TODO Write a specific message in the log
                                if ($this->IsCacheLdapHash()) {
                                    $this->SetUserLdapHashCache(bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check))));
                                }
                            } elseif ($this->IsCacheLdapHash()) {
                                if (!$this->IsLdapServerReachable()) {
                                    if ($this->GetVerboseFlag()) {
                                        $this->WriteLog("Debug: user LDAP password checked in the cache", FALSE, FALSE, 8888, 'Debug', '');
                                    }
                                    if ($this->GetUserLdapHashCache() == bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check)))) {
                                        $ldap_check_passed = TRUE;
                                        // TODO Write a specific message in the log
                                    }
                                } else {
                                    $ldap_check_passed = FALSE;
                                    $ldap_to_check = 'LDAP_FALSE';
                                    $this->ResetUserLdapHashCache();
                                    if ($this->GetVerboseFlag()) {
                                        $this->WriteLog("Debug: user LDAP password false, hash cache cleared", FALSE, FALSE, 8888, 'Debug', '');
                                    }
                                }
                            }
                        }
                    }
                    if (!$ldap_check_passed) {
                        $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                        $input_to_check = "LDAP_FAILED";
                        $result = 99;
                    }
                }
                
                switch (strtolower($this->GetUserAlgorithm())) {
                    case 'motp':
                        if (('' == $input_sync) && (!$resync_enc_pass)) {
                            $max_steps = 2 * $step_window;
                        } else {
                            $max_steps = 2 * $step_sync_window;
                        }
                        $check_step = 1;

                        do {
                            $additional_step = (1 - (2 * ($check_step % 2))) * intval($check_step/2);
                            $pure_calculated_token = $this->ComputeMotp($seed.$pin, $now_steps+$additional_step+$delta_step, $digits);
                            $calculated_token = $pure_calculated_token;
                            
                            if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                $code_confirmed_without_pin = $calculated_token;
                                $code_confirmed = $calculated_token;
                                $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                $this->SetLastClearOtpValue($code_confirmed);
                            } else {
                                if ($need_prefix) {
                                    $calculated_token = $pin.$calculated_token;
                                }

                                $code_confirmed_without_pin = $pure_calculated_token;
                                $code_confirmed = $calculated_token;
                                $this->SetLastClearOtpValue($code_confirmed);
                                if ('' != $this->GetChapPassword()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateChapPassword($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                } elseif ('' != $this->GetMsChapResponse()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChapResponse($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChapResponse($code_confirmed));
                                } elseif ('' != $this->GetMsChap2Response()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed));
                                }
                            }
                            
                            if (('' == $input_sync) && (!$resync_enc_pass)) {
                                // With mOTP, the code should not be prefixed, so we accept of course always input without prefix!
                                if (($input_to_check == $code_confirmed) || ($input_to_check == $code_confirmed_without_pin)) {
                                    if ($input_to_check == $code_confirmed_without_pin) {
                                        $code_confirmed = $code_confirmed_without_pin;
                                    }
                                    if (($now_steps+$additional_step+$delta_step) > $last_login_step) {
                                        $this->SetUserTokenLastLogin(($now_steps+$additional_step+$delta_step) * $interval);
                                        $this->SetUserTokenDeltaTime(($additional_step+$delta_step) * $interval);
                                        $this->SetUserErrorCounter(0);
                                        $result = 0; // OK: This is the correct token
                                        $this->WriteLog("Ok: User ".$this->GetUser()." successfully logged in", FALSE, FALSE, $result, 'User');
                                    } else {
                                        $this->SetUserErrorCounter($error_counter+1);
                                        $this->SetUserTokenLastError($now_epoch);
                                        $result = 26; // ERROR: this token has already been used
                                        $this->WriteLog("Error: token of user ".$this->GetUser()." already used", FALSE, FALSE, $result, 'User');
                                    }
                                } else {
                                    $check_step++;
                                }
                            } elseif (($input_to_check == $code_confirmed) || ($input_to_check == $code_confirmed_without_pin)) {
                                $pure_sync_calculated_token = $this->ComputeMotp($seed.$pin, $now_steps+$additional_step+$delta_step+1, $digits);
                                $sync_calculated_token = $pure_sync_calculated_token;
                                
                                if (($need_prefix) && ($input_sync != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                    $input_sync = substr($input_sync, -strlen($code_confirmed));                            
                                } elseif ($need_prefix) {
                                    $sync_calculated_token = $pin.$sync_calculated_token;
                                }
                                if ((($input_sync == $sync_calculated_token) || ($input_sync == $pure_sync_calculated_token)) && (($now_steps+$additional_step+$delta_step+1) > $last_login_step)) {
                                    $this->SetUserTokenLastLogin(($now_steps+$additional_step+$delta_step+1) * $interval);
                                    $this->SetUserTokenDeltaTime(($additional_step+$delta_step+1) * $interval);
                                    $this->SetUserErrorCounter(0);
                                    $this->SetUserLocked(0);
                                    $result = 14; // INFO: token is now synchronized
                                    $this->WriteLog("Info: token for user ".$this->GetUser()." is now resynchronized with a delta of ".(($additional_step+$delta_step+1) * $interval). " seconds", FALSE, FALSE, $result, 'User');
                                    $result = 0; // INFO: authentication is successful, regardless of the PIN code if needed, as the PIN code is already used to generate the token
                                } else {
                                    $result = 27; // ERROR: resync failed
                                    $this->WriteLog("Error: resync for user ".$this->GetUser()." has failed", FALSE, FALSE, $result, 'User');
                                }
                            } else {
                                $check_step++;
                                if ($display_status) {
                                    MultiotpShowStatus($check_step, $max_steps);
                                }
                            }
                        } while (($check_step < $max_steps) && (90 <= $result));
                        if ($display_status) {
                            echo "\r\n";
                        }
                        if (90 <= $result) {
                            $this->SetUserErrorCounter($error_counter+1);
                            $this->SetUserTokenLastError($now_epoch);
                            $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                        }
                        break;
                    case 'hotp';
                        if (('' == $input_sync)&& (!$resync_enc_pass)) {
                            $max_steps = 2 * $event_window;
                        } else {
                            $max_steps = 2 * $event_sync_window;
                        }
                        $check_step = 1;
                        do {
                            $additional_step = (1 - (2 * ($check_step % 2))) * intval($check_step/2);
                            $pure_calculated_token = $this->GenerateOathHotp($seed_bin,$last_event+$additional_step,$digits,$token_algo_suite);
                            $calculated_token = $pure_calculated_token;
                            if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                $code_confirmed_without_pin = $calculated_token;
                                $code_confirmed = $calculated_token;
                                $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                $this->SetLastClearOtpValue($code_confirmed);
                            } else {
                                if ($need_prefix) {
                                    $calculated_token = $pin.$calculated_token;
                                }
                                
                                $code_confirmed_without_pin = $pure_calculated_token;
                                $code_confirmed = $calculated_token;
                                $this->SetLastClearOtpValue($code_confirmed);
                                if ('' != $this->GetChapPassword()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateChapPassword($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                } elseif ('' != $this->GetMsChapResponse()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChapResponse($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChapResponse($code_confirmed));
                                } elseif ('' != $this->GetMsChap2Response()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed));
                                }
                            }
                            
                            if (('' == $input_sync) && (!$resync_enc_pass)) {
                                if ($input_to_check == $code_confirmed) {
                                    if ($additional_step >= 1) {
                                        $this->SetUserTokenLastLogin($now_epoch);
                                        $this->SetUserTokenLastEvent($last_event+$additional_step);
                                        $this->SetUserErrorCounter(0);
                                        $result = 0; // OK: This is the correct token
                                        $this->WriteLog("OK: User ".$this->GetUser()." successfully logged in", FALSE, FALSE, $result, 'User');
                                    } else {
                                        $this->SetUserErrorCounter($error_counter+1);
                                        $this->SetUserTokenLastError($now_epoch);
                                        $result = 26; // ERROR: this token has already been used
                                        $this->WriteLog("Error: token of user ".$this->GetUser()." already used", FALSE, FALSE, $result, 'User');
                                    }
                                } else {
                                    $check_step++;
                                }
                            } elseif (($input_to_check == $code_confirmed) || ($input_to_check == $code_confirmed_without_pin)) {
                                $pure_sync_calculated_token = $this->GenerateOathHotp($seed_bin, $last_event+$additional_step+1,$digits,$token_algo_suite);
                                $sync_calculated_token = $pure_sync_calculated_token;
                                
                                if (($need_prefix) && ($input_sync != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                    $input_sync = substr($input_sync, -strlen($code_confirmed));                            
                                } elseif ($need_prefix) {
                                    $sync_calculated_token = $pin.$sync_calculated_token;
                                }
                                if ((($input_sync == $sync_calculated_token) || ($input_sync == $pure_sync_calculated_token)) && ($additional_step >= 1)) {
                                    $this->SetUserTokenLastLogin($now_epoch);
                                    $this->SetUserTokenLastEvent($last_event+$additional_step+1);
                                    $this->SetUserErrorCounter(0);
                                    $this->SetUserLocked(0);
                                    $result = 14; // INFO: token is now synchronized
                                    $this->WriteLog("Info: token for user ".$this->GetUser()." is now resynchronized with the last event ".($last_event+$additional_step+1), FALSE, FALSE, $result, 'User');
                                    if ($input_to_check == $code_confirmed) {
                                        $result = 0; // INFO: authentication is successful, as the prefix has also been typed (if any)
                                    }
                                } else {
                                    $result = 27; // ERROR: resync failed
                                    $this->WriteLog("Error: resync for user ".$this->GetUser()." has failed", FALSE, FALSE, $result, 'User');
                                }
                            } else {
                                $check_step++;
                                if ($display_status) {
                                    MultiotpShowStatus($check_step, $max_steps);
                                }
                            }
                        } while (($check_step < $max_steps) && ((90 <= $result)));
                        if ($display_status) {
                            echo "\r\n";
                        }
                        if (90 <= $result) {
                            $this->SetUserErrorCounter($error_counter+1);
                            $this->SetUserTokenLastError($now_epoch);
                            $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                        }
                        break;
                    case 'yubicootp';
                        $yubikey_class = new MultiotpYubikey();
                        $bad_precheck = FALSE;
                        if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                            if (!$ldap_check_passed) {
                                $input_to_check.= '_BAD_LDAP_CHECK';
                                $bad_precheck = TRUE;
                            }
                            $this->SetLastClearOtpValue($input_to_check);
                        } else {
                            if ($need_prefix) {
                                if ($pin != substr($input_to_check, 0, strlen($pin))) {
                                    $this->SetLastClearOtpValue($input_to_check);
                                    $input_to_check.= '_BAD_PREFIX';
                                    $bad_precheck = TRUE;
                                }
                            }
                        }

                        if (!$bad_precheck) {
                            // Check only the last 32 digits, the first 12 are the serial number
                            $result = $yubikey_class->CheckYubicoOtp(substr($input_to_check, -32),
                                                                     $seed,
                                                                     $last_event);
                        }

                        if (0 == $result) {
                            $calculated_token = $input_to_check;
                            $this->SetUserTokenLastLogin($now_epoch);
                            $this->SetUserTokenLastEvent($yubikey_class->GetYubicoOtpLastCount());
                            $this->SetUserErrorCounter(0);
                            $result = 0; // OK: This is the correct token
                            $this->WriteLog("OK: User ".$this->GetUser()." successfully logged in", FALSE, FALSE, $result, 'User');
                        } elseif (26 == $result) {
                            $this->SetUserErrorCounter(1); // TODO $error_counter+1, includes resync
                            $this->SetUserTokenLastError($now_epoch);
                            $result = 26; // ERROR: this token has already been used
                            $this->WriteLog("Error: token of user ".$this->GetUser()." already used", FALSE, FALSE, $result, 'User');
                        } else {
                            $this->SetUserErrorCounter($error_counter+1);
                            $this->SetUserTokenLastError($now_epoch);
                            $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                        }
                        break;
                    case 'totp';
                        if (('' == $input_sync) && (!$resync_enc_pass)) {
                            $max_steps = 2 * $step_window;
                        } else {
                            $max_steps = 2 * $step_sync_window;
                        }
                        $check_step = 1;
                        do {
                            $additional_step = (1 - (2 * ($check_step % 2))) * intval($check_step/2);
                            $pure_calculated_token = $this->GenerateOathHotp($seed_bin,$now_steps+$additional_step+$delta_step,$digits,$token_algo_suite);
                            $calculated_token = $pure_calculated_token;
                            
                            if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                $code_confirmed_without_pin =  $calculated_token;
                                $code_confirmed = $calculated_token;
                                $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                $this->SetLastClearOtpValue($code_confirmed);
                            } else {
                                if ($need_prefix) {
                                    $calculated_token = $pin.$calculated_token;
                                }

                                $code_confirmed_without_pin = $pure_calculated_token;
                                $code_confirmed = $calculated_token;
                                $this->SetLastClearOtpValue($code_confirmed);
                                if ('' != $this->GetChapPassword()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateChapPassword($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                } elseif ('' != $this->GetMsChapResponse()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChapResponse($code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChapResponse($code_confirmed));
                                } elseif ('' != $this->GetMsChap2Response()) {
                                    $code_confirmed_without_pin = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed_without_pin));
                                    $code_confirmed = strtolower($this->CalculateMsChap2Response($real_user, $code_confirmed));
                                }
                            }
                            
                            if (('' == $input_sync) && (!$resync_enc_pass)) {
                                if ($input_to_check == $code_confirmed) {
                                    if (($now_steps+$additional_step+$delta_step) > $last_login_step) {
                                        $this->SetUserTokenLastLogin(($now_steps+$additional_step+$delta_step) * $interval);
                                        $this->SetUserTokenDeltaTime(($additional_step+$delta_step) * $interval);
                                        $this->SetUserErrorCounter(0);
                                        $result = 0; // OK: This is the correct token
                                        $this->WriteLog("OK: User ".$this->GetUser()." successfully logged in", FALSE, FALSE, $result, 'User');
                                    } else {
                                        $this->SetUserErrorCounter($error_counter+1);
                                        $this->SetUserTokenLastError($now_epoch);
                                        $result = 26; // ERROR: this token has already been used
                                        $this->WriteLog("Error: token of user ".$this->GetUser()." already used", FALSE, FALSE, $result, 'User');
                                    }
                                } else {
                                    $check_step++;
                                }
                            } elseif (($input_to_check == $code_confirmed) || ($input_to_check == $code_confirmed_without_pin)) {
                                $pure_sync_calculated_token = $this->GenerateOathHotp($seed_bin,$now_steps+$additional_step+$delta_step+1,$digits,$token_algo_suite);
                                $sync_calculated_token = $pure_sync_calculated_token;
                                
                                if (($need_prefix) && ($input_sync != '') && ($this->IsUserRequestLdapPasswordEnabled())) {
                                    $input_sync = substr($input_sync, -strlen($code_confirmed));                            
                                } elseif ($need_prefix) {
                                    $sync_calculated_token = $pin.$sync_calculated_token;
                                }
                                if ((($input_sync == $sync_calculated_token) || ($input_sync == $pure_sync_calculated_token)) && (($now_steps+$additional_step+$delta_step) > $last_login_step)) {
                                    $this->SetUserTokenLastLogin(($now_steps+$additional_step+$delta_step+1) * $interval);
                                    $this->SetUserTokenDeltaTime(($additional_step+$delta_step+1) * $interval);
                                    $this->SetUserErrorCounter(0);
                                    $this->SetUserLocked(0);
                                    $result = 14; // INFO: token is now synchronized
                                    $this->WriteLog("Info: token for user ".$this->GetUser()." is now resynchronized with a delta of ".(($additional_step+$delta_step+1) * $interval). " seconds", FALSE, FALSE, $result, 'User');
                                    if ($input_to_check == $code_confirmed) {
                                        $result = 0; // INFO: authentication is successful, as the prefix has also been typed (if any)
                                    }
                                } else {
                                    $result = 27; // ERROR: resync failed
                                    $this->WriteLog("Error: resync for user ".$this->GetUser()." has failed", FALSE, FALSE, $result, 'User');
                                }
                            } else {
                                $check_step++;
                                if ($display_status) {
                                    MultiotpShowStatus($check_step, $max_steps);
                                }
                            }
                        } while (($check_step < $max_steps) && (90 <= $result));
                        if ($display_status) {
                            echo "\r\n";
                        }
                        if (90 <= $result) {
                            $this->SetUserErrorCounter($error_counter+1);
                            $this->SetUserTokenLastError($now_epoch);
                            $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                        }
                        break;
                    default:
                        $result = 23;
                        $this->WriteLog("Error: ".$this->GetUserAlgorithm()." algorithm is unknown", FALSE, FALSE, $result, 'User');
                }
            }

            if (0 == $result) {
                $this->SetUserLocked(0);
            }
            
            if (90 <= $result) {
                if ($this->GetVerboseFlag()) {
                    if ('' != $this->GetChapPassword()) {
                        $this->WriteLog("*(authentication typed by the user is CHAP encrypted)", FALSE, FALSE, $result, 'User');
                    } elseif ('' != $this->GetMsChapResponse()) {
                        $this->WriteLog("*(authentication typed by the user is MS-CHAP encrypted)", FALSE, FALSE, $result, 'User');
                    } elseif ('' != $this->GetMsChap2Response()) {
                        $this->WriteLog("*(authentication typed by the user is MS-CHAP V2 encrypted)", FALSE, FALSE, $result, 'User');
                    } elseif ((strlen($input_to_check) == strlen($calculated_token))) {
                        $this->WriteLog("*(authentication typed by the user: ".$input_to_check.")", FALSE, FALSE, $result, 'User');
                    } else {
                        $result = 98;
                        $this->WriteLog("*(authentication typed by the user is ".strlen($input_to_check)." chars long instead of ".strlen($calculated_token)." chars)", FALSE, FALSE, $result, 'User');
                    }
                } elseif (('' == $this->GetChapPassword()) &&
                          ('' == $this->GetMsChapResponse()) &&
                          ('' == $this->GetMsChap2Response()) &&
                          ((strlen($input_to_check) != strlen($calculated_token)))
                         ) {
                    $result = 98;
                    $this->WriteLog("Error: authentication typed by the user is ".strlen($input_to_check)." chars long instead of ".strlen($calculated_token)." chars", FALSE, FALSE, $result, 'User');
                }
            }
            
            if ($this->GetUserErrorCounter() >= $this->GetMaxBlockFailures()) {
                $this->SetUserLocked(1);
            }
            if (!$this->WriteUserData()) {
                $result = 28; // ERROR: Unable to write the changes in the file
                $this->WriteLog("Error: Unable to write the changes in the file for the user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
            }
        } // end of the else block of the test: if (!$this->ReadUserData($real_user))

        if (0 == $result) {
            $this->AddExtraRadiusInfo();
        }
        return $result;
    }


    function SelfRegisterHardwareToken($user, $serial, $input, $original_input = '')
    {
        // TODO the whole process has to be changed to support multi tokens
        $result = 99; // Unknown error
        $calculated_token = '';
        if ('' == $original_input)
        {
            $original_input = $input;
        }
        $serial_number = strtolower($serial);
        if ($this->ReadUserData($user))
        {
            $pin = $this->GetUserPin();
            $need_prefix = (1 == $this->GetUserPrefixPin());

            if ($this->ReadTokenData($serial_number))
            {
                $attributed_users = trim($this->GetTokenAttributedUsers());
                if ('' != trim($attributed_users))
                {
                    if (FALSE === strpos(','.$attributed_users.',', ','.$user.','))
                    {
                        $result = 37; // ERROR: Token already attributed
                        $this->WriteLog("Error: Token ".$this->GetToken()." already attributed", FALSE, FALSE, $result, 'Token', $user);
                    }
                    // else $result = 99; // The token is already attributed to this user, stay neutral with the error
                }
                else
                {
                    $algorithm = $this->GetTokenAlgorithm();
                    $token_algo_suite = $this->GetTokenAlgoSuite();
                    $seed = $this->GetTokenSeed();
                    $digits = $this->GetTokenNumberOfDigits();
                    $time_interval = $this->GetTokenTimeInterval();
                    $last_event = $this->GetTokenLastEvent();
                    $delta_time = $this->GetTokenDeltaTime();
                    $last_login = $this->GetTokenLastLogin();
                    $error_counter = $this->GetTokenErrorCounter();

                    $now_epoch = time();

                    $input_to_check = $input;
                    $interval = (0 >= $time_interval)?1:$time_interval;
                    $seed_bin = hex2bin($seed);

                    if (strlen($input_to_check) < 3)
                    {
                        $input_to_check = "! <3 digits";
                    }

                    $now_steps         = intval($now_epoch / $interval);
                    $time_window       = $this->GetMaxTimeWindow();
                    $step_window       = intval($time_window / $interval);
                    $event_window      = $this->GetMaxEventWindow();
                    $time_sync_window  = $this->GetMaxTimeResyncWindow();
                    $step_sync_window  = intval($time_sync_window / $interval);
                    $event_sync_window = $this->GetMaxEventResyncWindow();
                    $last_login_step   = intval($last_login / $interval);
                    $delta_step        = $delta_time / $interval;
                        
                    $ldap_check_passed = FALSE;
                    $ldap_to_check = 'LDAP_FALSE';
                    if (($need_prefix) && ($this->IsUserRequestLdapPasswordEnabled()))
                    {
                        if ($input_to_check != '')
                        {
                            $ldap_to_check = substr($input_to_check, 0, strlen($input_to_check) - $digits);
                            if ('' != $ldap_to_check)
                            {
                                if ($this->CheckUserLdapPassword($this->GetUserSynchronizedDn(), $ldap_to_check))
                                {
                                    $ldap_check_passed = TRUE;
                                    // TODO Write a specific message in the log
                                    if ($this->IsCacheLdapHash())
                                    {
                                        $this->SetUserLdapHashCache(bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check))));
                                    }
                                }
                                elseif ($this->IsCacheLdapHash())
                                {
                                    if (!$this->IsLdapServerReachable())
                                    {
                                        if ($this->GetVerboseFlag())
                                        {
                                            $this->WriteLog("Debug: user LDAP password checked in the cache", FALSE, FALSE, 8888, 'Debug', '');
                                        }
                                        if ($this->GetUserLdapHashCache() == bin2hex($this->NtPasswordHashHash($this->NtPasswordHash($ldap_to_check))))
                                        {
                                            $ldap_check_passed = TRUE;
                                            // TODO Write a specific message in the log
                                        }
                                    }
                                    else
                                    {
                                        $ldap_check_passed = FALSE;
                                        $ldap_to_check = 'LDAP_FALSE';
                                        $this->ResetUserLdapHashCache();
                                        if ($this->GetVerboseFlag())
                                        {
                                            $this->WriteLog("Debug: user LDAP password false, hash cache cleared", FALSE, FALSE, 8888, 'Debug', '');
                                        }
                                    }
                                }
                            }
                        }
                        if (!$ldap_check_passed)
                        {
                            $this->WriteLog("Error: authentication failed for user ".$this->GetUser(), FALSE, FALSE, $result, 'User');
                            $input_to_check = "LDAP_FAILED";
                            $result = 99;
                        }
                    }

                    switch (strtolower($algorithm))
                    {
                        case 'motp':
                            $max_steps = 2 * $step_sync_window;
                            $check_step = 1;
                            do
                            {
                                $additional_step = (1 - (2 * ($check_step % 2))) * intval($check_step/2);
                                $pure_calculated_token = $this->ComputeMotp($seed.$pin, $now_steps+$additional_step+$delta_step, $digits);
                                $calculated_token = $pure_calculated_token;
                                
                                if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled()))
                                {
                                    $code_confirmed_without_pin = $calculated_token;
                                    $code_confirmed = $calculated_token;
                                    $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                    if (!$ldap_check_passed)
                                    {
                                        $input_to_check.= '_BAD_LDAP_CHECK';
                                    }
                                    $this->SetLastClearOtpValue($original_input);
                                }
                                else
                                {
                                    if ($need_prefix)
                                    {
                                        $calculated_token = $pin.$calculated_token;
                                    }
                                    
                                    $code_confirmed_without_pin = $pure_calculated_token;
                                    $code_confirmed = $calculated_token;
                                    $this->SetLastClearOtpValue($original_input);
                                    if ('' != $this->GetChapPassword())
                                    {
                                        $code_confirmed_without_pin = strtolower($this->CalculateChapPassword($code_confirmed_without_pin));
                                        $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChapResponse())
                                    {
                                        $code_confirmed_without_pin = strtolower($this->CalculateMsChapResponse($code_confirmed_without_pin));
                                        $code_confirmed = strtolower($this->CalculateMsChapResponse($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChap2Response())
                                    {
                                        $code_confirmed_without_pin = strtolower($this->CalculateMsChap2Response($user, $code_confirmed_without_pin));
                                        $code_confirmed = strtolower($this->CalculateMsChap2Response($user, $code_confirmed));
                                    }
                                }

                                if (($input_to_check == $code_confirmed) || ($input_to_check == $code_confirmed_without_pin))
                                {
                                    if (($now_steps+$additional_step+$delta_step) > $last_login_step)
                                    {
                                        $this->SetTokenLastLogin(($now_steps+$additional_step+$delta_step) * $interval);
                                        $this->SetTokenDeltaTime(($additional_step+$delta_step) * $interval);
                                        $this->SetTokenErrorCounter(0);
                                        $result = 0; // OK: This is the correct token
                                    }
                                    else
                                    {
                                        $result = 26; // ERROR: this token has already been used
                                    }
                                }
                                else
                                {
                                    $check_step++;
                                }
                            }
                            while (($check_step < $max_steps) && (90 <= $result));
                            break;
                        case 'hotp';
                            $max_steps = $event_sync_window;
                            $check_step = 1;
                            do
                            {
                                $pure_calculated_token = $this->GenerateOathHotp($seed_bin,$last_event+$check_step,$digits,$token_algo_suite);
                                $calculated_token = $pure_calculated_token;
                                
                                if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled()))
                                {
                                    $code_confirmed_without_pin = $calculated_token;
                                    $code_confirmed = $calculated_token;
                                    $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                    if (!$ldap_check_passed)
                                    {
                                        $input_to_check.= '_BAD_LDAP_CHECK';
                                    }
                                    $this->SetLastClearOtpValue($original_input);
                                }
                                else
                                {
                                    if ($need_prefix)
                                    {
                                        $calculated_token = $pin.$calculated_token;
                                    }
                                    
                                    $code_confirmed = $calculated_token;
                                    $this->SetLastClearOtpValue($original_input);
                                    if ('' != $this->GetChapPassword())
                                    {
                                        $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChapResponse())
                                    {
                                        $code_confirmed = strtolower($this->CalculateMsChapPassword($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChap2Response())
                                    {
                                        $code_confirmed = strtolower($this->CalculateMsChap2Password($user, $code_confirmed));
                                    }
                                }

                                if ($input_to_check == $code_confirmed)
                                {
                                    $this->SetTokenLastLogin($now_epoch);
                                    $this->SetTokenLastEvent($last_event+$check_step);
                                    $this->SetTokenErrorCounter(0);
                                    $result = 0; // OK: This is the correct token
                                }
                                else
                                {
                                    $check_step++;
                                }
                            }
                            while (($check_step < $max_steps) && (90 <= $result));
                            break;
                        case 'yubicootp':
                            $yubikey_class = new MultiotpYubikey();
                            $bad_precheck = FALSE;
                            if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled()))
                            {
                                if (!$ldap_check_passed)
                                {
                                    $input_to_check.= '_BAD_LDAP_CHECK';
                                    $bad_precheck = TRUE;
                                }
                                $this->SetLastClearOtpValue($original_input);
                            }
                            else
                            {
                                if ($need_prefix)
                                {
                                    if ($pin != substr($input_to_check, 0, strlen($pin)))
                                    {
                                        $this->SetLastClearOtpValue($original_input);
                                        $input_to_check.= '_BAD_PREFIX';
                                        $bad_precheck = TRUE;
                                    }
                                }
                            }

                            if (!$bad_precheck)
                            {
                                // Check only the last 32 digits, the first 12 are the serial number
                                $result = $yubikey_class->CheckYubicoOtp(substr($input_to_check, -32),
                                                                         $seed,
                                                                         $last_event);
                            }
                            if (0 == $result)
                            {
                                $calculated_token = $input_to_check;
                                $this->SetTokenLastLogin($now_epoch);
                                $this->SetTokenLastEvent($yubikey_class->GetYubicoOtpLastCount());
                                $this->SetTokenErrorCounter(0);
                                $result = 0; // OK: This is the correct token
                            }
                            break;
                        case 'totp';
                            $max_steps = 2 * $step_sync_window;
                            $check_step = 1;
                            do
                            {
                                $additional_step = (1 - (2 * ($check_step % 2))) * intval($check_step/2);
                                $pure_calculated_token = $this->GenerateOathHotp($seed_bin,$now_steps+$additional_step+$delta_step,$digits,$token_algo_suite);
                                $calculated_token = $pure_calculated_token;
                                
                                if (($need_prefix) && ($input_to_check != '') && ($this->IsUserRequestLdapPasswordEnabled()))
                                {
                                    $code_confirmed_without_pin = $calculated_token;
                                    $code_confirmed = $calculated_token;
                                    $input_to_check = substr($input_to_check, -strlen($code_confirmed));                            
                                    if (!$ldap_check_passed)
                                    {
                                        $input_to_check.= '_BAD_LDAP_CHECK';
                                    }
                                    $this->SetLastClearOtpValue($original_input);
                                }
                                else
                                {
                                    if ($need_prefix)
                                    {
                                        $calculated_token = $pin.$calculated_token;
                                    }

                                    $code_confirmed = $calculated_token;
                                    $this->SetLastClearOtpValue($original_input);
                                    if ('' != $this->GetChapPassword())
                                    {
                                        $code_confirmed = strtolower($this->CalculateChapPassword($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChapResponse())
                                    {
                                        $code_confirmed = strtolower($this->CalculateMsChapPassword($code_confirmed));
                                    }
                                    elseif ('' != $this->GetMsChap2Response())
                                    {
                                        $code_confirmed = strtolower($this->CalculateMsChap2Password($user, $code_confirmed));
                                    }
                                }

                                if ($input_to_check == $code_confirmed)
                                {
                                    if (($now_steps+$additional_step+$delta_step) > $last_login_step)
                                    {
                                        $this->SetTokenLastLogin(($now_steps+$additional_step+$delta_step) * $interval);
                                        $this->SetTokenDeltaTime(($additional_step+$delta_step) * $interval);
                                        $this->SetTokenErrorCounter(0);
                                        $result = 0; // OK: This is the correct token
                                    }
                                    else
                                    {
                                        $result = 26; // ERROR: this token has already been used
                                    }
                                }
                                else
                                {
                                    $check_step++;
                                }
                            }
                            while (($check_step < $max_steps) && (90 <= $result));
                            break;
                        default:
                            $result = 23; // ERROR: Invalid algorithm
                    }

                    if (90 <= $result)
                    {
                        if ($this->GetVerboseFlag())
                        {
                            if ((strlen($input_to_check) == strlen($calculated_token)))
                            {
                                $this->WriteLog("*(authentication typed by the user: ".$input_to_check.")", FALSE, FALSE, $result, 'User', $user);
                            }
                            else
                            {
                                $result = 98;
                                $this->WriteLog("*(authentication typed by the user is ".strlen($input_to_check)." chars long instead of ".strlen($calculated_token)." chars", FALSE, FALSE, $result, 'User', $user);
                            }
                        }
                    }
                    
                    if (0 == $result)
                    {
                        $this->AddTokenAttributedUsers($user);
                        if (!$this->WriteTokenData())
                        {
                            $result = 28; // ERROR: Unable to write the changes in the file
                            $this->WriteLog("Error: Unable to write the changes in the file for the token ".$this->GetToken(), FALSE, FALSE, $result, 'Token', $user);
                        }
                        else
                        {
                            $this->SetUserTokenSerialNumber($serial_number);
                            $this->SetUserAlgorithm($this->GetTokenAlgorithm());
                            $this->SetUserTokenAlgoSuite($this->GetTokenAlgoSuite());
                            $this->SetUserTokenSeed($this->GetTokenSeed());
                            $this->SetUserTokenNumberOfDigits($this->GetTokenNumberOfDigits());
                            $this->SetUserTokenTimeInterval($this->GetTokenTimeInterval());
                            $this->SetUserTokenLastEvent($this->GetTokenLastEvent());
                            $this->SetUserTokenDeltaTime($this->GetTokenDeltaTime());
                            $this->SetUserTokenLastLogin($this->GetTokenLastLogin());
                            $this->SetUserErrorCounter(0);
                            if (!$this->WriteUserData())
                            {
                                $result = 28; // ERROR: Unable to write the changes in the file
                                $this->WriteLog("Error: Unable to write the changes in the file for the user ".$this->GetUser(), FALSE, FALSE, $result, 'System', '');
                            }
                            else
                            {
                                $this->WriteLog("OK: token ".$this->GetToken()." successfully attributed to user ".$this->GetUser(), FALSE, FALSE, 19, 'User');
                            }
                        }
                    }
                }
            }
            else
            {
                $result = 29; // ERROR: Token doesn't exist
                $this->WriteLog("Error: Token ".$this->GetToken()." does not exist", FALSE, FALSE, $result, 'Token');
            }
        }
        else
        {
            $result = 29; // ERROR: User doesn't exist
            $this->WriteLog("Error: User ".$this->GetUser()." does not exist", FALSE, FALSE, $result, 'User');
        }
        return $result;
    } // End of SelfRegisterHardwareToken


    function ImportTokensFile($file, $original_name = '', $cipher_password = '', $key_mac = "")
    {
        if (!file_exists($file))
        {
            $result = FALSE;
        }
        else
        {
            $data1000 = @file_get_contents($file, FALSE, NULL, -1, 1000);
            $file_name = ('' != $original_name)?$original_name:$file;
            if (FALSE !== strpos(strtolower($data1000), strtolower('"urn:ietf:params:xml:ns:keyprov:pskc"')))
            {
                $result = $this->ImportTokensFromPskc($file, $cipher_password, $key_mac);
            }
            elseif (FALSE !== strpos(strtolower($data1000), strtolower('LOGGING START')))
            {
                $result = $this->ImportYubikeyTraditional($file);
            }
            elseif ((FALSE !== strpos(strtolower($data1000), strtolower('AUTHENEXDB'))) && ('.sql' == strtolower(substr($file_name, -4))))
            {
                $result = $this->ImportTokensFromAuthenexSql($file);
            }
            elseif ((FALSE !== strpos(strtolower($data1000), strtolower('SafeWord Authenticator Records'))) && ('.dat' == strtolower(substr($file_name, -4))))
            {
                $result = $this->ImportTokensFromAlpineDat($file);
            }
            elseif (FALSE !== strpos(strtolower($data1000), strtolower('<ProductName>eTPass')))
            // elseif (('.xml' == strtolower(substr($file_name, -4))) && (FALSE !== strpos(strtolower($file_name), 'alpine')))
            {
                $result = $this->ImportTokensFromAlpineXml($file);
            }
            elseif ('.xml' == strtolower(substr($file_name, -4)))
            {
                $result = $this->ImportTokensFromXml($file);
            }
            else
            {
                $result = $this->ImportTokensFromCsv($file);
            }
        }
        return $result;
    }


    function DecodeCipherValue($encrypted_tree, $cipher_array, $integer_value = FALSE)
    {
        $Secret = '';
        $cipher_aes = new Crypt_AES();

        $encryption_method_tag = (isset($encrypted_tree->{$cipher_array['xenc_ns'].'encryptionmethod'})?$cipher_array['xenc_ns']:'').'encryptionmethod';
        $encryption_method_algorithm_url = isset($encrypted_tree->{$encryption_method_tag}[0]->tagAttrs["algorithm"])?($encrypted_tree->{$encryption_method_tag}[0]->tagAttrs["algorithm"]):'';
        $encryption_method_algorithm = (FALSE !== strpos($encryption_method_algorithm_url,'#aes128-cbc'))?'aes128':((FALSE !== strpos($encryption_method_algorithm_url,'#kw-aes128'))?'kw-ases128':'');
        $cipher_data_tag = (isset($encrypted_tree->{$cipher_array['xenc_ns'].'cipherdata'})?$cipher_array['xenc_ns']:'').'cipherdata';
        $cipher_value_tag = (isset($encrypted_tree->{$cipher_data_tag}[0]->{$cipher_array['xenc_ns'].'ciphervalue'})?$cipher_array['xenc_ns']:'').'ciphervalue';
        $cipher_value = isset($encrypted_tree->{$cipher_data_tag}[0]->{$cipher_value_tag}[0]->tagData)?($encrypted_tree->{$cipher_data_tag}[0]->{$cipher_value_tag}[0]->tagData):'';

        if ('' != $cipher_array['Password'])
        {
            if ('' == $cipher_array['KeyDerivationMethodAlgorithm'])
            {
                $cipher_aes->setKey($cipher_array['Password']);
                $Secret = (substr($cipher_aes->decrypt(base64_decode($cipher_value)),16));
                if ('' == $Secret)
                {
                    $cipher_aes->setKey(hex2bin(preg_replace("/[^A-Fa-f0-9]/", '', $cipher_array['Password'])));
                    $Secret = (substr($cipher_aes->decrypt(base64_decode($cipher_value)),16));
                }
            }
            elseif ('pkcs5' == $cipher_array['KeyDerivationMethodAlgorithm'])
            {
                $cipher_aes->setPassword($cipher_array['Password'], 'pbkdf2', 'sha1', $cipher_array['Salt'], $cipher_array['IterationCount'], $cipher_array['KeyLength']);
                $Secret = (substr($cipher_aes->decrypt(base64_decode($cipher_value)),16));
            }
        }
        if (('' != $Secret) && ($integer_value))
        {
            $value = 0;
            for( $i = 0; $i < strlen($Secret); $i++ )
            {
                $value = ($value << 8) | ord($Secret[$i]);
            }
            $Secret = $value;
        }
        return $Secret;
    }

    
    function ImportTokensFromPskc($pskc_file, $cipher_password = '', $keymac = '')
    {
        $this->ResetLastImportedTokensArray();
        $result = TRUE;
        if (!file_exists($pskc_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$pskc_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            //Get the XML document loaded into a variable
            $sXmlData = @file_get_contents($pskc_file);
                    
            //Set up the parser object
            $xml = new MultiotpXmlParser($sXmlData, TRUE);

            //Parse it !
            $xml->Parse();

            $ds_ns = '';
            $pkcs5_ns = '';
            $pskc_ns = '';
            $xenc_ns = '';
            $xenc11_ns = '';

            if (isset($xml->document))
            {
                $keycontainer = $xml->document;
                reset($keycontainer->tagAttrs);
                while(list($attribute_key, $attribute_value) = each($keycontainer->tagAttrs))
                {
                    if ('http://www.w3.org/2000/09/xmldsig#' == $attribute_value)
                    {
                        $ds_ns = substr($attribute_key,strpos($attribute_key,':')+1);
                        $ds_ns.= ('' != $ds_ns)?':':'';
                    }
                    if ('http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#' == $attribute_value)
                    {
                        $pkcs5_ns = substr($attribute_key,strpos($attribute_key,':')+1);
                        $pkcs5_ns.= ('' != $pkcs5_ns)?'_':'';
                    }
                    if ('urn:ietf:params:xml:ns:keyprov:pskc' == $attribute_value)
                    {
                        $pskc_ns = substr($attribute_key,strpos($attribute_key,':')+1);
                        $pskc_ns.= ('' != $pskc_ns)?'_':'';
                    }
                    if ('http://www.w3.org/2001/04/xmlenc#' == $attribute_value)
                    {
                        $xenc_ns = substr($attribute_key,strpos($attribute_key,':')+1);
                        $xenc_ns.= ('' != $xenc_ns)?'_':'';
                    }
                    if ('http://www.w3.org/2009/xmlenc11#' == $attribute_value)
                    {
                        $xenc11_ns = substr($attribute_key,strpos($attribute_key,':')+1);
                        $xenc11_ns.= ('' != $xenc11_ns)?'_':'';
                    }
                }

                $CipherArray = array();
                $CipherArray['Password'] = $cipher_password;
                $CipherArray['xenc_ns'] = $xenc_ns;

                $EncryptionKey_tag = (isset($keycontainer->{$pskc_ns.'encryptionkey'})?$pskc_ns:'').'encryptionkey';
                $DerivedKey_tag = (isset($keycontainer->{$EncryptionKey_tag}[0]->{$xenc11_ns.'derivedkey'})?$xenc11_ns:'').'derivedkey';
                $KeyDerivationMethod_tag = (isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$xenc11_ns.'keyderivationmethod'})?$xenc11_ns:'').'keyderivationmethod';
                $KeyDerivationMethodAlgorithmUrl = isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->tagAttrs["algorithm"])?($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->tagAttrs["algorithm"]):'';
                $CipherArray['KeyDerivationMethodAlgorithm'] = ((FALSE !== strpos($KeyDerivationMethodAlgorithmUrl,'#pbkdf2'))?'pkcs5':'');
                // http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#pbkdf2
                // http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2
                $CipherArray['Salt'] = '';
                $CipherArray['IterationCount'] = 0;
                $CipherArray['KeyLength'] = 0;
                if ('pkcs5' == $CipherArray['KeyDerivationMethodAlgorithm'])
                {
                    $pkcs5_PBKDF2_params_tag = (isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_ns.'pbkdf2_params'})?$pkcs5_ns:'').'pbkdf2_params';
                    $pkcs5_Salt_tag = 'salt';
                    $pkcs5_Salt_Specified_tag = 'specified';
                    $CipherArray['Salt'] = base64_decode(isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_Salt_tag}[0]->{$pkcs5_Salt_Specified_tag}[0]->tagData)?($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_Salt_tag}[0]->{$pkcs5_Salt_Specified_tag}[0]->tagData):'');
                    $pkcs5_IterationCount_tag = 'iterationcount';
                    $CipherArray['IterationCount'] = intval(isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_IterationCount_tag}[0]->tagData)?($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_IterationCount_tag}[0]->tagData):0);
                    $pkcs5_KeyLength_tag = 'keylength';
                    $CipherArray['KeyLength'] = intval(isset($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_KeyLength_tag}[0]->tagData)?($keycontainer->{$EncryptionKey_tag}[0]->{$DerivedKey_tag}[0]->{$KeyDerivationMethod_tag}[0]->{$pkcs5_PBKDF2_params_tag}[0]->{$pkcs5_KeyLength_tag}[0]->tagData):0);
                }
                
                $KeyPackage_tag = (isset($keycontainer->{$pskc_ns.'keypackage'})?$pskc_ns:'').'keypackage';
                // Extract each key
                // foreach($keycontainer[0][$KeyPackage_tag] as $keypackage) // this is not working well in PHP4
                reset($keycontainer->{$KeyPackage_tag});
                while(list($keypackage_key, $keypackage) = each($keycontainer->{$KeyPackage_tag}))
                {
                    $DeviceInfo_tag = (isset($keypackage->{$pskc_ns.'deviceinfo'})?$pskc_ns:'').'deviceinfo';
                    
                    $Manufacturer_tag = (isset($keypackage->{$pskc_ns.'deviceinfo'}[0]->{$pskc_ns.'manufacturer'})?$pskc_ns:'').'manufacturer';
                    $Manufacturer = (isset($keypackage->{$pskc_ns.'deviceinfo'}[0]->{$Manufacturer_tag}[0]->tagData)?($keypackage->{$pskc_ns.'deviceinfo'}[0]->{$Manufacturer_tag}[0]->tagData):'');
                    
                    $SerialNo_tag = (isset($keypackage->{$DeviceInfo_tag}[0]->{$pskc_ns.'serialno'})?$pskc_ns:'').'serialno';
                    $SerialNo = (isset($keypackage->{$DeviceInfo_tag}[0]->{$SerialNo_tag}[0]->tagData)?($keypackage->{$DeviceInfo_tag}[0]->{$SerialNo_tag}[0]->tagData):'');

                    $CryptoModuleInfo_tag = (isset($keypackage->{$pskc_ns.'cryptomoduleinfo'})?$pskc_ns:'').'cryptomoduleinfo';
                    
                    $CryptoId_tag = (isset($keypackage->{$CryptoModuleInfo_tag}[0]->{$pskc_ns.'id'})?$pskc_ns:'').'id';
                    $CryptoId = (isset($keypackage->{$CryptoModuleInfo_tag}[0]->{$CryptoId_tag}[0]->tagData)?($keypackage->{$CryptoModuleInfo_tag}[0]->{$CryptoId_tag}[0]->tagData):'');

                    $Key_tag = (isset($keypackage->{$pskc_ns.'key'})?$pskc_ns:'').'key';
                    
                    $AlgorithmUrl = isset($keypackage->{$Key_tag}[0]->tagAttrs["algorithm"])?($keypackage->{$Key_tag}[0]->tagAttrs["algorithm"]):'';
                    $Algorithm = (FALSE !== strpos($AlgorithmUrl,'hotp'))?'hotp':((FALSE !== strpos($AlgorithmUrl,'totp'))?'totp':'');
                    // $Algorithm = (FALSE !== strpos($AlgorithmUrl,'hotp'))?'hotp':((FALSE !== strpos($AlgorithmUrl,'totp'))?'totp':((FALSE !== strpos($AlgorithmUrl,'ocra'))?'ocra':''));

                    $KeyId = isset($keypackage->{$Key_tag}[0]->tagAttrs["id"])?($keypackage->{$Key_tag}[0]->tagAttrs["id"]):'';
                    
                    $Issuer_tag = (isset($keypackage->{$Key_tag}[0]->{$pskc_ns.'issuer'})?$pskc_ns:'').'issuer';
                    $Issuer = (isset($keypackage->{$Key_tag}[0]->{$Issuer_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$Issuer_tag}[0]->tagData):'');
                    
                    $AlgorithmParameters_tag = (isset($keypackage->{$Key_tag}[0]->{$pskc_ns.'algorithmparameters'})?$pskc_ns:'').'algorithmparameters';
                    
                    $Suite_tag = (isset($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$pskc_ns.'suite'})?$pskc_ns:'').'suite';
                    $Suite = (isset($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$Suite_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$Suite_tag}[0]->tagData):'HMAC-SHA1');
                    $ResponseFormat_tag = (isset($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$pskc_ns.'responseformat'})?$pskc_ns:'').'responseformat';
                    $Length = isset($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$ResponseFormat_tag}[0]->tagAttrs["length"])?($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$ResponseFormat_tag}[0]->tagAttrs["length"]):0;
                    $Encoding = isset($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$ResponseFormat_tag}[0]->tagAttrs["encoding"])?($keypackage->{$Key_tag}[0]->{$AlgorithmParameters_tag}[0]->{$ResponseFormat_tag}[0]->tagAttrs["encoding"]):'DECIMAL';
                    
                    $Data_tag = (isset($keypackage->{$Key_tag}[0]->{$pskc_ns.'data'})?$pskc_ns:'').'data';
                    
                    $Secret_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$pskc_ns.'secret'})?$pskc_ns:'').'secret';
                    $SecretPlainValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$pskc_ns.'plainvalue'})?$pskc_ns:'').'plainvalue';
                    $Secret = base64_decode(isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$SecretPlainValue_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$SecretPlainValue_tag}[0]->tagData):'');
                    $EncryptedValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$pskc_ns.'encryptedvalue'})?$pskc_ns:'').'encryptedvalue';
                    if (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$EncryptedValue_tag}[0]))
                    {
                        $SecretEncryptedPath = $keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Secret_tag}[0]->{$EncryptedValue_tag}[0];
                        $Secret = $this->DecodeCipherValue($SecretEncryptedPath, $CipherArray);
                    }

                    
                    $Counter_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$pskc_ns.'counter'})?$pskc_ns:'').'counter';
                    $CounterPlainValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$pskc_ns.'plainvalue'})?$pskc_ns:'').'plainvalue';
                    $Counter = intval(isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$CounterPlainValue_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$CounterPlainValue_tag}[0]->tagData):0);
                    $EncryptedValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$pskc_ns.'encryptedvalue'})?$pskc_ns:'').'encryptedvalue';
                    if (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$EncryptedValue_tag}[0]))
                    {
                        $CounterEncryptedPath = $keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Counter_tag}[0]->{$EncryptedValue_tag}[0];
                        $Counter = $this->DecodeCipherValue($CounterEncryptedPath, $CipherArray, TRUE);
                    }

                    $Time_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$pskc_ns.'time'})?$pskc_ns:'').'time';
                    $TimePlainValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$pskc_ns.'plainvalue'})?$pskc_ns:'').'plainvalue';
                    $Time = intval(isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$TimePlainValue_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$TimePlainValue_tag}[0]->tagData):'');
                    $EncryptedValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$pskc_ns.'encryptedvalue'})?$pskc_ns:'').'encryptedvalue';
                    if (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$EncryptedValue_tag}[0]))
                    {
                        $TimeEncryptedPath = $keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$Time_tag}[0]->{$EncryptedValue_tag}[0];
                        $Time = $this->DecodeCipherValue($TimeEncryptedPath, $CipherArray, TRUE);
                    }
                    
                    $TimeInterval_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$pskc_ns.'timeinterval'})?$pskc_ns:'').'timeinterval';
                    $TimeIntervalPlainValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$pskc_ns.'plainvalue'})?$pskc_ns:'').'plainvalue';
                    $TimeInterval = intval(isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$TimeIntervalPlainValue_tag}[0]->tagData)?($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$TimeIntervalPlainValue_tag}[0]->tagData):30);
                    $EncryptedValue_tag = (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$pskc_ns.'encryptedvalue'})?$pskc_ns:'').'encryptedvalue';
                    if (isset($keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$EncryptedValue_tag}[0]))
                    {
                        $TimeIntervalEncryptedPath = $keypackage->{$Key_tag}[0]->{$Data_tag}[0]->{$TimeInterval_tag}[0]->{$EncryptedValue_tag}[0];
                        $TimeInterval = $this->DecodeCipherValue($TimeIntervalEncryptedPath, $CipherArray, TRUE);
                    }

                    $Policy_tag = (isset($keypackage->{$Key_tag}[0]->{$pskc_ns.'policy'})?$pskc_ns:'').'policy';
                    $PINPolicy_tag = (isset($keypackage->{$Key_tag}[0]->{$Policy_tag}[0]->{$pskc_ns.'pinpolicy'})?$pskc_ns:'').'pinpolicy';
                    $PINPolicyAttributes = isset($keypackage->{$Key_tag}[0]->{$Policy_tag}[0]->{$PINPolicy_tag}[0]->tagAttrs[0])?($keypackage->{$Key_tag}[0]->{$Policy_tag}[0]->{$PINPolicy_tag}[0]->tagAttrs):'';
                    $SerialNo = (('' == $SerialNo)?$KeyId:$SerialNo);

                    if (('' != $Algorithm) && ('' != $SerialNo) && ('' != $Secret))
                    {
                        $this->SetToken($SerialNo);
                        $this->SetTokenDescription(trim($Manufacturer.' '.$SerialNo));
                        $this->SetTokenManufacturer($Manufacturer);
                        $this->SetTokenIssuer($Issuer);
                        $this->SetTokenSerialNumber($SerialNo);
                        $this->SetTokenKeyAlgorithm($AlgorithmUrl);
                        $this->SetTokenAlgorithm($Algorithm);
                        $this->SetTokenAlgoSuite($Suite);
                        $this->SetTokenOtp("TRUE");
                        $this->SetTokenFormat($Encoding);
                        $this->SetTokenNumberOfDigits($Length);
                        if ($Counter >= 0)
                        {
                            $this->SetTokenLastEvent($Counter-1);
                        }
                        else
                        {
                            $this->SetTokenLastEvent(0);
                        }
                        $this->SetTokenDeltaTime($Time);
                        $this->SetTokenTimeInterval($TimeInterval);
                        $this->SetTokenSeed(bin2hex($Secret));
                        
                        if ($this->CheckTokenExists())
                        {
                            $this->WriteLog("Info: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                        }
                        else
                        {
                            $result = $this->WriteTokenData() && $result;
                            $this->AddLastImportedToken($this->GetToken());
                            $this->WriteLog("Info: Token with SerialNo ".$SerialNo." successfully imported", FALSE, FALSE, 15, 'Token', '');
                        }
                        if ($this->GetVerboseFlag())
                        {
                            $full_token_data = '';
                            reset($this->_token_data);
                            while(list($key, $value) = each($this->_token_data))
                            {
                                if ('' != $value)
                                {
                                    $full_token_data = $full_token_data."  Token ".$SerialNo." - ".$key.": ".$value."\n";
                                }
                            }
                            $this->WriteLog("Debug: *".$full_token_data, FALSE, FALSE, 8888, 'Debug', '');
                        }
                    }
                    else
                    {
                        $result = FALSE;
                        $this->WriteLog("Info: Token with SerialNo ".$SerialNo." failed during importation", FALSE, FALSE, 32, 'Token', '');
                    }
                }
            }
        }
        return $result;
    }


    function ImportYubikeyTraditional($yubikey_file)
    /*
     * YubiKey traditional format log file (csv)
     *  0 eventType: "Yubico OTP"|"OATH-HOTP"|"Static Password: Scan Code"|"Static Password"|"Challenge-Response: Yubico OTP"|"Challenge-Response: HMAC-SHA1"
     *  1 timestampLocal: "dd.mm.yyyy hh:ii"
     *  2 configSlot: 1|2
     *  3 pubIdTxt: cbdefghijkln
     *  4 pvtIdTxt: 1234567890ab
     *  5 secretKeyTxt: 1234567890abcdef1234567890abcdef
     *  6 currentAccessCodeTxt: ""|"xxxxxxxxxxxx"
     *  7 newAccessCodeTxt: ""|"xxxxxxxxxxxx"
     *  8 oathFixedModhex1: 0|1 (First byte in fixed part sent as modhex, OATH only)
     *  9 oathFixedModhex2: 0|1 (First two bytes in fixed part sent as modhex, OATH only)
     * 10 oathFixedModhex: 0|1 (Fixed part sent as modhex, OATH only)
     * 11 hotpDigits: 0|6|8
     * 12 oathMovingFactorSeed: 0|nnnn
     * 13 strongPw1: 0|1 (Static Password - Upper and lower case)
     * 14 strongPw2: 0|1 (Static Password - Alphanumeric)
     * 15 sendRef: 0|1 (Static Password - Send ! as prefix)
     * 16 chalBtnTrig: 0|1 (Challenge-Response - challenge requires button trigger)
     * 17 hmacLT64 1|0 (Challenge-Response: HMAC-SHA1 - 1: variable input, 0: fixed 64 byte input)
    */
    {
        $result = TRUE;
        $imported_tokens = 0;
        $this->ResetTokenArray();
        $this->ResetLastImportedTokensArray();
        if (!file_exists($yubikey_file))
        {
            $this->WriteLog("Error: YubiKeys log file ".$yubikey_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            //Get the document loaded into a variable
            $file_handler = fopen($yubikey_file, "rt");

            $yubikey_class = new MultiotpYubikey();
            
            while (!feof($file_handler))
            {
                $line = trim(fgets($file_handler));

                $line = str_replace(';',"\t", $line);
                $line = str_replace(',',"\t", $line);

                $line_array = explode("\t", $line);

                if (count($line_array) >= 18)
                {
                    $token_algo_suite = 'AES-128';
                    $manufacturer = "Yubico";
                    switch (trim($line_array[0]))
                    {
                        case 'Yubico OTP':
                            $algorithm = 'yubicootp';
                            break;
                        case 'OATH-HOTP':
                            $algorithm = 'hotp';
                            break;
                        default:
                            $algorithm = "";
                    }
                    $esn = trim($line_array[3]); // modhex
                    if (('hotp' == $algorithm) && (0 == intval($line_array[10])))
                    {
                        if (1 == intval($line_array[8]))
                        {
                            $esn = substr(trim($line_array[3]),0,2).$yubikey_class->ModHexToHex(substr(trim($line_array[3]),2));
                        }
                        elseif (1 == intval($line_array[9]))
                        {
                            $esn = substr(trim($line_array[3]),0,4).$yubikey_class->ModHexToHex(substr(trim($line_array[3]),4));
                        }
                        else
                        {
                            $esn = $yubikey_class->ModHexToHex(trim($line_array[3]));
                        }
                    }
                    $seed = trim($line_array[5]);
                    $interval_or_event = intval($line_array[12]);

                    if ('hotp' == $algorithm)
                    {
                        $digits = intval($line_array[11]);
                        $next_event = $interval_or_event;
                        $time_interval = 0;
                    }
                    elseif ("yubicootp" == $algorithm)
                    {
                        $digits = 32;
                        $next_event = 0;
                        $time_interval = 0;
                    }
                    
                    if ('' != $algorithm)
                    {
                        $this->SetToken($esn);
                        $this->SetTokenDescription(trim($manufacturer.' '.$esn));
                        $this->SetTokenManufacturer($manufacturer);
                        $this->SetTokenSerialNumber($esn);
                        $this->SetTokenSeed($seed);
                        $this->SetTokenAlgorithm($algorithm);
                        $this->SetUserTokenAlgoSuite($token_algo_suite);
                        $this->SetTokenNumberOfDigits($digits);
                        $this->SetTokenLastEvent($next_event - 1);
                        $this->SetTokenTimeInterval($time_interval);

                        $imported_tokens++;
                        
                        if ('' == $esn)
                        {
                            $this->WriteLog("Error: A token doesn't have any serial number", FALSE, FALSE, 32, 'Token', '');
                        }
                        elseif (!$this->IsValidAlgorithm($algorithm))
                        {
                            $this->WriteLog("Error: The algorithm ".$algorithm." is not recognized", FALSE, FALSE, 32, 'Token', '');
                        }
                        elseif ($this->CheckTokenExists())
                        {
                            $this->WriteLog("Info: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                        }
                        else
                        {
                            $result = $this->WriteTokenData() && $result;
                            $this->AddLastImportedToken($this->GetToken());
                            $this->WriteLog("Info: Token ".$this->GetToken()." successfully imported", FALSE, FALSE, 15, 'Token', '');
                        }
                        $this->ResetTokenArray();
                    }
                }
            }
            fclose($file_handler);
        }
        if (0 == $imported_tokens)
        {
            $result = FALSE;
        }
        return $result;
    }


    function ImportTokensFromCsv($csv_file)
    {
        $result = TRUE;
        $imported_tokens = 0;
        $this->ResetTokenArray();
        $this->ResetLastImportedTokensArray();
        if (!file_exists($csv_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$csv_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            //Get the document loaded into a variable
            $file_handler = fopen($csv_file, "rt");
            
            while (!feof($file_handler))
            {
                $line = trim(fgets($file_handler));

                $line = str_replace(';',"\t", $line);
                $line = str_replace(',',"\t", $line);

                $line_array = explode("\t", $line);

                if (count($line_array) >= 6)
                {
                    $esn               = trim($line_array[0]);
                    $manufacturer      = $line_array[1];
                    $algorithm         = strtolower($line_array[2]);
                    $seed              = $line_array[3];
                    $digits            = $line_array[4];
                    $interval_or_event = intval($line_array[5]);
                    
                    if ('hotp' == $algorithm)
                    {
                        $next_event = $interval_or_event;
                        $time_interval = 0;
                    }
                    else
                    {
                        $next_event = 0;
                        $time_interval = $interval_or_event;
                        if ("motp" == $algorithm)
                        {
                            $time_interval = 10;
                        }
                    }

                    $this->SetToken($esn);
                    $this->SetTokenDescription(trim($manufacturer.' '.$esn));
                    $this->SetTokenManufacturer($manufacturer);
                    $this->SetTokenSerialNumber($esn);
                    $this->SetTokenSeed($seed);
                    $this->SetTokenAlgorithm($algorithm);
                    $this->SetTokenNumberOfDigits($digits);
                    $this->SetTokenLastEvent($next_event - 1);
                    $this->SetTokenTimeInterval($time_interval);

                    $imported_tokens++;
                    
                    if ('' == $esn)
                    {
                        $this->WriteLog("Error: A token doesn't have any serial number", FALSE, FALSE, 32, 'Token', '');
                    }
                    elseif (!$this->IsValidAlgorithm($algorithm))
                    {
                        $this->WriteLog("Error: The algorithm ".$algorithm." is not recognized", FALSE, FALSE, 32, 'Token', '');
                    }
                    elseif ($this->CheckTokenExists())
                    {
                        $this->WriteLog("Info: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                    }
                    else
                    {
                        $result = $this->WriteTokenData() && $result;
                        $this->AddLastImportedToken($this->GetToken());
                        $this->WriteLog("Info: Token ".$this->GetToken()." successfully imported", FALSE, FALSE, 15, 'Token', '');
                    }
                    $this->ResetTokenArray();
                }
            }
            fclose($file_handler);
        }
        if (0 == $imported_tokens)
        {
            $result = FALSE;
        }
        return $result;
    }


    function ImportTokensFromXml($xml_file)
    {
        $this->ResetLastImportedTokensArray();
        $result = TRUE;
        if (!file_exists($xml_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$xml_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            // http://tools.ietf.org/html/draft-hoyer-keyprov-pskc-algorithm-profiles-00
            
            //Get the XML document loaded into a variable
            $sXmlData = @file_get_contents($xml_file);

            //Set up the parser object
            $xml = new MultiotpXmlParser($sXmlData);

            //Parse it !
            $xml->Parse();

            // Array of key types
            $key_types = array();
            
            if (isset($xml->document->keyproperties))
            {
                foreach ($xml->document->keyproperties as $keyproperty)
                {
                    $id = (isset($keyproperty->tagAttrs['xml:id'])?$keyproperty->tagAttrs['xml:id']:'');
                    
                    if ('' != $id)
                    {
                        $key_types[$id]['id'] = $id;
                        $key_types[$id]['issuer'] = (isset($keyproperty->issuer[0]->tagData)?$keyproperty->issuer[0]->tagData:'');
                        $key_types[$id]['keyalgorithm'] = (isset($keyproperty->tagAttrs['keyalgorithm'])?$keyproperty->tagAttrs['keyalgorithm']:'');
                        $pos = strrpos($key_types[$id]['keyalgorithm'], "#");
                        $key_types[$id]['algorithm'] = (($pos === false)?'':strtolower(substr($key_types[$id]['keyalgorithm'], $pos+1)));
                        $key_types[$id]['otp'] = (isset($keyproperty->usage[0]->tagAttrs['otp'])?$keyproperty->usage[0]->tagAttrs['otp']:'');
                        $key_types[$id]['format'] = (isset($keyproperty->usage[0]->responseformat[0]->tagAttrs['format'])?$keyproperty->usage[0]->responseformat[0]->tagAttrs['format']:'');
                        $key_types[$id]['length'] = (isset($keyproperty->usage[0]->responseformat[0]->tagAttrs['length'])?$keyproperty->usage[0]->responseformat[0]->tagAttrs['length']:-1);
                        $key_types[$id]['counter'] = (isset($keyproperty->data[0]->counter[0]->plainvalue[0]->tagData)?$keyproperty->data[0]->counter[0]->plainvalue[0]->tagData:-1);
                        $key_types[$id]['time'] = (isset($keyproperty->data[0]->time[0]->plainvalue[0]->tagData)?$keyproperty->data[0]->time[0]->plainvalue[0]->tagData:-1);
                        $key_types[$id]['timeinterval'] = (isset($keyproperty->data[0]->timeinterval[0]->plainvalue[0]->tagData)?$keyproperty->data[0]->timeinterval[0]->plainvalue[0]->tagData:-1);
                        $key_types[$id]['suite'] = (isset($keyproperty->data[0]->suite[0]->plainvalue[0]->tagData)?$keyproperty->data[0]->suite[0]->plainvalue[0]->tagData:'');
                    }
                }
            }
            
            if (isset($xml->document->device))
            {
                foreach ($xml->document->device as $device)
                {
                    $keyid = (isset($device->key[0]->tagAttrs['keyid'])?$device->key[0]->tagAttrs['keyid']:'');
                    if ('' != $keyid)
                    {
                        $this->ResetTokenArray();                        
                        $keyproperties = '';
                        $manufacturer = '';
                        $serialno = '';
                        $issuer = '';
                        $keyalgorithm = '';
                        $algorithm = '';
                        $otp = '';
                        $format = '';
                        $length = 0;
                        $counter = -1;
                        $time = 0;
                        $timeinterval = 0;
                        $secret = '';
                        $suite = '';
                        
                        if (isset($device->key[0]->tagAttrs['keyproperties']))
                        {
                            $keyproperties = $device->key[0]->tagAttrs['keyproperties'];
                            if (isset($key_types[$keyproperties]))
                            {
                                reset($key_types[$keyproperties]);
                                while(list($key, $value) = each($key_types[$keyproperties]))
                                {
                                    $$key = $value;
                                }
                            }
                        }
                        
                        $manufacturer = (isset($device->deviceinfo[0]->manufacturer[0]->tagData)?$device->deviceinfo[0]->manufacturer[0]->tagData:$manufacturer);
                        $serialno = (isset($device->deviceinfo[0]->serialno[0]->tagData)?$device->deviceinfo[0]->serialno[0]->tagData:$serialno);

                        $issuer = (isset($device->key[0]->issuer[0]->tagData)?$device->key[0]->issuer[0]->tagData:$issuer);
                        
                        if (isset($device->key[0]->tagAttrs['keyalgorithm']))
                        {
                            $keyalgorithm = $device->key[0]->tagAttrs['keyalgorithm'];
                            $pos = strrpos($keyalgorithm, "#");
                            $algorithm = (($pos === false)?$algorithm:strtolower(substr($keyalgorithm, $pos+1)));
                        }
                        
                        $otp = (isset($device->key[0]->usage[0]->tagAttrs['otp'])?$device->key[0]->usage[0]->tagAttrs['otp']:$otp);
                        $format = (isset($device->key[0]->usage[0]->responseformat[0]->tagAttrs['format'])?$device->key[0]->usage[0]->responseformat[0]->tagAttrs['format']:$format);
                        $length = (isset($device->key[0]->usage[0]->responseformat[0]->tagAttrs['length'])?$device->key[0]->usage[0]->responseformat[0]->tagAttrs['length']:$length);
                        $counter = (isset($device->key[0]->data[0]->counter[0])?$device->key[0]->data[0]->counter[0]->plainvalue[0]->tagData:$counter);
                        $time = (isset($device->key[0]->data[0]->time[0])?$device->key[0]->data[0]->time[0]->plainvalue[0]->tagData:$time);
                        $timeinterval = (isset($device->key[0]->data[0]->timeinterval[0])?$device->key[0]->data[0]->timeinterval[0]->plainvalue[0]->tagData:$timeinterval);
                        $suite = (isset($device->key[0]->data[0]->suite[0])?$device->key[0]->data[0]->suite[0]->plainvalue[0]->tagData:$suite);
                        
                        if (isset($device->key[0]->data[0]->secret[0]->plainvalue[0]->tagData))
                        {
                            $secret = bin2hex(base64_decode($device->key[0]->data[0]->secret[0]->plainvalue[0]->tagData));
                        }

                        if ('' == trim($serialno))
                        {
                            $serialno = trim($keyid);
                        }
                        $this->SetToken($serialno);
                        $this->SetTokenDescription(trim($manufacturer.' '.$keyid));
                        $this->SetTokenManufacturer($manufacturer);
                        $this->SetTokenIssuer($issuer);
                        $this->SetTokenSerialNumber($serialno);
                        $this->SetTokenKeyAlgorithm($keyalgorithm);
                        $this->SetTokenAlgorithm($algorithm);
                        $this->SetTokenAlgoSuite($suite);
                        $this->SetTokenOtp($otp);
                        $this->SetTokenFormat($format);
                        $this->SetTokenNumberOfDigits($length);
                        if ($counter >= 0)
                        {
                            $this->SetTokenLastEvent($counter-1);
                        }
                        else
                        {
                            $this->SetTokenLastEvent(0);
                        }
                        $this->SetTokenDeltaTime($time);
                        $this->SetTokenTimeInterval($timeinterval);
                        $this->SetTokenSeed($secret);
                        
                        if ($this->CheckTokenExists())
                        {
                            $this->WriteLog("Error: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                        }
                        else
                        {
                            $result = $this->WriteTokenData() && $result;
                            $this->AddLastImportedToken($this->GetToken());
                            $this->WriteLog("Info: Token with keyid ".$keyid." successfully imported", FALSE, FALSE, 15, 'Token', '');
                        }
                        if ($this->GetVerboseFlag())
                        {
                            $full_token_data = '';
                            reset($this->_token_data);
                            while(list($key, $value) = each($this->_token_data))
                            {
                                if ('' != $value)
                                {
                                    $full_token_data = $full_token_data."  Token ".$keyid." - ".$key.": ".$value."\n";
                                }
                            }
                            $this->WriteLog("Debug: *".$full_token_data, FALSE, FALSE, 8888, 'Debug', '');
                        }
                    }
                }
            }
        }
        return $result;
    }    


    function ImportTokensFromAlpineXml($xml_file)
    {
        $this->ResetLastImportedTokensArray();
        $result = TRUE;
        if (!file_exists($xml_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$xml_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            $sXmlData = @file_get_contents($xml_file);

            //Set up the parser object
            $xml = new MultiotpXmlParser($sXmlData);

            //Parse it !
            $xml->Parse();

            // Array of key types
            $key_types = array();
            if (isset($xml->document->token))
            {
                foreach ($xml->document->token as $token)
                {
                    $serial = (isset($token->tagAttrs['serial'])?$token->tagAttrs['serial']:'');
                    if ('' != $serial)
                    {
                        $this->ResetTokenArray();                        
                        $manufacturer = 'SafeWord';
                        $serialno = $serial;
                        $issuer = 'SafeWord';
                        $algorithm = 'HOTP';
                        $length = 6;
                        $counter = 0;
                        $time = 0;
                        $timeinterval = 0;
                        $secret = '';
                        
                        if (isset($token->applications[0]->application[0]->seed[0]->tagData))
                        {
                            $secret = $token->applications[0]->application[0]->seed[0]->tagData;
                        }
                        $this->SetToken($serialno);
                        $this->SetTokenDescription(trim($manufacturer.' '.$serialno));
                        $this->SetTokenManufacturer($manufacturer);
                        $this->SetTokenSerialNumber($serialno);
                        $this->SetTokenIssuer($issuer);
                        $this->SetTokenAlgorithm($algorithm);
                        $this->SetTokenNumberOfDigits($length);
                        $this->SetTokenLastEvent($counter-1);
                        $this->SetTokenDeltaTime($time);
                        $this->SetTokenTimeInterval($timeinterval);
                        $this->SetTokenSeed($secret);
                        
                        if ($this->CheckTokenExists())
                        {
                            $this->WriteLog("Error: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                        }
                        else
                        {
                            $result = $this->WriteTokenData() && $result;
                            $this->AddLastImportedToken($this->GetToken());
                            
                            $this->WriteLog("Info: Token with serial number ".$serialno." successfully imported", FALSE, FALSE, 15, 'Token', '');
                        }
                    }
                }
            }
        }
        return $result;
    }    


    function ImportTokensFromAlpineDat($data_file)
    {
        $ProductName = "";
        $this->ResetTokenArray();
        $this->ResetLastImportedTokensArray();
        $result = TRUE;
        if (!file_exists($data_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$data_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            // SafeWord Authenticator Records
            
            //Get the document loaded into a variable
            $file_handler = fopen($data_file, "rt");

            $line = trim(fgets($file_handler));
            
            $reference_header       = "SafeWord Authenticator Records";
            $reference_manufacturer = "SafeWord";
            
            if (FALSE !== strpos(strtolower($line), strtolower($reference_header)))
            {
                $manufacturer = $reference_manufacturer;
            
                while (!feof($file_handler))
                {
                    $line = trim(fgets($file_handler));
                    $line_array = explode(":",$line,2);
                    $line_array[0] = trim($line_array[0]);
                    $line_array[1] = trim((isset($line_array[1])?$line_array[1]:''));

                    switch (strtolower($line_array[0]))
                    {
                        case '# ===== safeword authenticator records $version':
                        case 'dn':
                            break;
                        case 'objectclass':
                            break;
                        case 'sccauthenticatorid':
                            $sccAuthenticatorId = $line_array[1];
                            $this->SetToken($sccAuthenticatorId);
                            $this->SetTokenDescription(trim($manufacturer.' '.$sccAuthenticatorId));
                            $this->SetTokenSerialNumber($sccAuthenticatorId);
                            break;
                        case 'scctokentype':
                            $sccTokenType = $line_array[1];
                            break;
                        case 'scctokendata':
                            $sccTokenData = $line_array[1];
                            $data_array = explode(";",$sccTokenData);
                            foreach ($data_array as $data_one)
                            {
                                $attribute_array = explode("=",$data_one,2);
                                $attribute_array[0] = trim($attribute_array[0]);
                                $attribute_array[1] = trim((isset($attribute_array[1])?$attribute_array[1]:''));
                                switch (strtolower($attribute_array[0]))
                                {
                                    case 'scckey':
                                        $sccKey = $attribute_array[1];
                                        $this->SetTokenSeed($sccKey); // 9C29B16121DB61E9D7216CB90016C45677B39009BBF825B5
                                        break;
                                    case 'sccMode':
                                        $sccMode = $attribute_array[1]; // E
                                        break;
                                    case 'sccpwlen':
                                        $sccPwLen = $attribute_array[1]; // 6
                                        $this->SetTokenNumberOfDigits($sccPwLen);
                                        break;
                                    case 'sccver':
                                        $sccVer = $attribute_array[1]; // 00000205
                                        break;
                                    case 'sccseq':
                                        $sccSeq = $attribute_array[1];
                                        $this->SetTokenLastEvent($sccSeq-1); // 0001
                                        break;
                                    case 'casemodel':
                                        $CaseModel = $attribute_array[1]; // 00000005
                                        break;
                                    case 'productiondate':
                                        $ProductionDate = $attribute_array[1]; // 07/28/2010
                                        break;
                                    case 'prtoductname':
                                    case 'productname':
                                        $ProductName = $attribute_array[1]; // eTPass 6.10
                                        break;
                                }
                            }
                            break;
                        case 'sccsignature':
                            if ($this->CheckTokenExists())
                            {
                                $this->WriteLog("Error: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                            }
                            else
                            {
                                $this->SetTokenManufacturer($manufacturer);
                                $this->SetTokenIssuer($manufacturer);
                                $this->SetTokenAlgorithm('HOTP');
                                $result = $this->WriteTokenData() && $result;
                                $this->AddLastImportedToken($this->GetToken());
                                $this->WriteLog("Info: Token ".$this->GetToken()." successfully imported", FALSE, FALSE, 15, 'Token', '');
                            }
                            $this->ResetTokenArray();
                            break;
                    }
                }
            }
            fclose($file_handler);
        }
        return $result;
    }


    function ImportTokensFromAuthenexSql($data_file)
    {
        $ProductName = "";
        $this->ResetTokenArray();
        $this->ResetLastImportedTokensArray();
        $result = TRUE;
        if (!file_exists($data_file))
        {
            $this->WriteLog("Error: Tokens definition file ".$data_file." doesn't exist", FALSE, FALSE, 29, 'Token', '');
            $result = FALSE;
        }
        else
        {
            // Authenex Authenticator Records
            
            //Get the document loaded into a variable
            $file_handler = fopen($data_file, "rt");
            
            $line = trim(fgets($file_handler));
            
            $reference_header       = "AUTHENEXDB";
            $reference_manufacturer = "Authenex";
            
            if (FALSE !== strpos(strtolower($line), strtolower($reference_header)))
            {
                $manufacturer = $reference_manufacturer;
                
                while (!feof($file_handler))
                {
                    $line = trim(fgets($file_handler));

                    if (FALSE !== strpos(strtoupper($line), 'INSERT INTO OTP'))
                    {
                        $token_array = array();
                        $line_array = explode("(",$line,3);
                        $token_line = str_replace(")",",",$line_array[2]);
                        $token_array = explode(",",$token_line);
                        if (isset($token_array[1]))
                        {
                            $esn  = preg_replace('#\W#', '', $token_array[0]);
                            $seed = preg_replace('#\W#', '', $token_array[1]);
                            $this->SetToken($esn);
                            $this->SetTokenDescription(trim($manufacturer.' '.$esn));
                            $this->SetTokenManufacturer($manufacturer);
                            $this->SetTokenSerialNumber($esn);
                            $this->SetTokenSeed($seed);
                            $this->SetTokenAlgorithm('HOTP');
                            $this->SetTokenNumberOfDigits(6);
                            $this->SetTokenLastEvent(-1);
                        }
                        if ($this->CheckTokenExists())
                        {
                            $this->WriteLog("Error: Token ".$this->GetToken()." already exists", FALSE, FALSE, 32, 'Token', '');
                        }
                        else
                        {
                            $result = $this->WriteTokenData() && $result;
                            $this->AddLastImportedToken($this->GetToken());
                            $this->WriteLog("Info: Token ".$this->GetToken()." successfully imported", FALSE, FALSE, 15, 'Token', '');
                        }
                        $this->ResetTokenArray();
                    }
                }
            }
            fclose($file_handler);
        }
        return $result;
    }


    /****************************
     ****************************
     ****************************
     ***   DEVICES HANDLING   ***
     ****************************
     ****************************
     ****************************/
     
    function CreateDevice($id = 0,
                          $description = '',
                          $device_secret = '',
                          $ip_or_fqdn = '',
                          $subnet = '',
                          $shortname = '',
                          $with_radius_update = TRUE,
                          $challenge_response_enabled = 0,
                          $text_token_challenge = '',
                          $sms_challenge_enabled = 0,
                          $text_sms_challenge = ''
                         )
    {
        $result = FALSE;
        $device_id = $id;
        if ((0 == $device_id) || ('' == $device_id))
        {
            $device_id = bigdec2hex((time()-mktime(1,1,1,1,1,2000)).mt_rand(10000,99999));
        }
        if (!$this->ReadDeviceData($device_id, TRUE))
        {
            $this->SetDevice($device_id);
            $this->SetDeviceDescription($description);
            $this->SetDeviceSecret($device_secret);
            $this->SetDeviceIpOrFqdn($ip_or_fqdn);
            $this->SetDeviceSubnet($subnet);
            $this->SetDeviceShortname($shortname);
            $this->SetDeviceChallengeEnabled($challenge_response_enabled);
            $this->SetDeviceTextTokenChallenge($text_token_challenge);
            $this->SetDeviceSmsChallengeEnabled($sms_challenge_enabled);
            $this->SetDeviceTextSmsChallenge($text_sms_challenge);
            $result = $this->WriteDeviceData($with_radius_update);
        }
        return $result;
    }    


    function ReadDeviceData($device_id = '', $create = FALSE)
    {
        if ('' != $device_id)
        {
            $this->SetDevice($device_id);
        }
        $result = FALSE;
        
        // We initialize the encryption hash to empty
        $this->_device_data['encryption_hash'] = '';
        
        // First, we read the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $device_filename = strtolower($this->GetDevice()).'.db';
            if (!file_exists($this->GetDevicesFolder().$device_filename))
            {
                if (!$create)
                {
                    $this->WriteLog("Error: database file ".$this->GetDevicesFolder().$device_filename." for device ".$this->_device." does not exist", FALSE, FALSE, 299, 'System', '');
                }
            }
            else
            {
                $file_handler = fopen($this->GetDevicesFolder().$device_filename, "rt");
                $first_line = trim(fgets($file_handler));
                
                while (!feof($file_handler))
                {
                    $line = trim(fgets($file_handler));
                    $line_array = explode("=",$line,2);
                    if (":" == substr($line_array[0], -1))
                    {
                        $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                        $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                    }
                    if ('' != trim($line_array[0]))
                    {
                        $this->_device_data[strtolower($line_array[0])] = $line_array[1];
                    }
                }
                
                fclose($file_handler);
                $result = TRUE;

                if ('' != $this->_device_data['encryption_hash'])
                {
                    if ($this->_device_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                    {
                        $this->_device_data['encryption_hash'] = "ERROR";
                        $this->WriteLog("Error: the device information encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                        $result = FALSE;
                    }
                }
            }
        }

        // And now, we override the values if another backend type is defined
        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_devices_table'])
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_devices_table']."` WHERE `device_id` = '".$this->_device."'";
                            $aRow = NULL;
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".trim($this->_mysqli->error).' ', TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = $rResult->fetch_assoc();
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = mysql_fetch_assoc($rResult);
                                }
                            }

                            if (NULL != $aRow)
                            {
                                $result = FALSE;
                                while(list($key, $value) = @each($aRow))
                                {
                                    $in_the_schema = FALSE;
                                    reset($this->_sql_tables_schema['devices']);
                                    while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['devices']))
                                    {
                                        if ($valid_key == $key)
                                        {
                                            $in_the_schema = TRUE;
                                        }
                                    }
                                    if (($in_the_schema) && ($key != 'device_id'))
                                    {
                                        if (('ENC:' == substr($value,0,4)) && (':ENC' == substr($value,-4)))
                                        {
                                            $value = substr($value,4);
                                            $value = substr($value,0,strlen($value)-4);
                                            $this->_device_data[$key] = $this->Decrypt($key,$value,$this->GetEncryptionKey());
                                        }
                                        else
                                        {
                                            $this->_device_data[$key] = $value;
                                        }
                                    }                                    
                                    elseif ((!$in_the_schema) && ('unique_id' != $key)  && $this->GetVerboseFlag())
                                    {
                                        $this->WriteLog("Warning: *The key ".$key." is not in the devices database schema", FALSE, FALSE, 98, 'System', '');
                                    }
                                    $result = TRUE;
                                }
                                if(0 == count($aRow) && !$create)
                                {
                                    $this->WriteLog("Error: SQL database entry for device ".$this->_device." does not exist", FALSE, FALSE, 299, 'System', '');
                                }
                            }
                        }
                        if ('' != $this->_device_data['encryption_hash'])
                        {
                            if ($this->_device_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                            {
                                $this->_device_data['encryption_hash'] = "ERROR";
                                $this->WriteLog("Error: the devices mysql encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }
        }
        return $result;
    }


    function WriteDeviceData(
        $with_radius_update = true // $with_radius_update (for future use)
    ) {
        if ('' == trim($this->GetDevice())) {
            $result = false;
        } else {
            $result = $this->WriteData('Device',
                                       'devices',
                                       $this->GetDevicesFolder(),
                                       $this->_device_data,
                                       false,
                                       'device_id',
                                       $this->GetDevice()
                                      );
        }
        return $result;
    }


    function SetDevice($device)
    {
        $this->ResetDeviceArray();
        $this->_device = strtolower($device);
        $this->ReadDeviceData('', TRUE); // First parameter empty, otherwise it will loop with SetDevice !
    }


    function GetDevice()
    {
        return $this->_device;
    }


    function SetDeviceDescription($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $result = $second_param;
        }
        $this->_device_data['description'] = $result;

        return $result;
    }


    function GetDeviceDescription($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['description'];
    }


    function SetDeviceShortname($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $result = $second_param;
        }
        $this->_device_data['shortname'] = $result;

        return $result;
    }


    function GetDeviceShortname($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['shortname'];
    }


    function SetDeviceIpOrFqdn($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $result = $second_param;
        }
        $this->_device_data['ip_or_fqdn'] = $result;

        return $result;
    }


    function GetDeviceIpOrFqdn($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['ip_or_fqdn'];
    }


    function SetDeviceSubnet($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $result = $second_param;
        }
        $this->_device_data['subnet'] = $result;

        return $result;
    }


    function GetDeviceSubnet($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['subnet'];
    }


    function SetDeviceSecret($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $result = $second_param;
        }
        $this->_device_data['device_secret'] = $result;

        return $result;
    }


    function GetDeviceSecret($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['device_secret'];
    }


    function SetDeviceChallengeEnabled($first_param, $second_param = "*-*")
    {
        $value = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $value = $second_param;
        }
        $this->_device_data['challenge_response_enabled'] = intval($value);

        return $value;
    }


    function GetDeviceChallengeEnabled($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return intval($this->_device_data['challenge_response_enabled']);
    }


    function SetDeviceTextTokenChallenge($first_param, $second_param = "*-*")
    {
        $value = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $value = $second_param;
        }
        $this->_device_data['text_token_challenge'] = $value;

        return $value;
    }


    function GetDeviceTextTokenChallenge($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['text_token_challenge'];
    }


    function SetDeviceSmsChallengeEnabled($first_param, $second_param = "*-*")
    {
        $value = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $value = $second_param;
        }
        $this->_device_data['sms_challenge_enabled'] = intval($value);

        return $value;
    }


    function GetDeviceSmsChallengeEnabled($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return intval($this->_device_data['sms_challenge_enabled']);
    }


    function SetDeviceTextSmsChallenge($first_param, $second_param = "*-*")
    {
        $value = "";
        if ($second_param == "*-*")
        {
            $value = $first_param;
        }
        else
        {
            $this->SetDevice($first_param);
            $value = $second_param;
        }
        $this->_device_data['text_sms_challenge'] = $value;

        return $value;
    }


    function GetDeviceTextSmsChallenge($device = '')
    {
        if($device != '')
        {
            $this->SetDevice($device);
        }
        return $this->_device_data['text_sms_challenge'];
    }


    function DeleteDevice($device = '', $no_error_info = FALSE)
    {
        if ('' != $device)
        {
            $this->SetDevice($device);
        }
        
        $result = FALSE;
        
        // First, we delete the device file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $device_filename = strtolower($this->_device).'.db';
            if (!file_exists($this->GetDevicesFolder().$device_filename))
            {
                if (!$no_error_info)
                {
                    $this->WriteLog("Error: Unable to delete device ".$this->_device.", database file ".$this->GetDevicesFolder().$device_filename." does not exist", FALSE, FALSE, 28, 'System', '');
                }
            }
            else
            {
                $result = unlink($this->GetDevicesFolder().$device_filename);
                if ($result)
                {
                    if ($this->GetVerboseFlag())
                    {
                        $this->WriteLog("Info: *Device ".$this->_device." successfully deleted", FALSE, FALSE, 19, 'Device', '');
                    }
                }
                else
                {
                    if (!$no_error_info)
                    {
                        $this->WriteLog("Error: Unable to delete device ".$this->_device, FALSE, FALSE, 28, 'Device', '');
                    }
                }
            }
        }

        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_devices_table'])
                        {
                            $sQuery  = "DELETE FROM `".$this->_config_data['sql_devices_table']."` WHERE `device_id` = '".$this->_device."'";
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    if (!$no_error_info)
                                    {
                                        $this->WriteLog("Error: Could not delete device ".$this->_device.": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'System', '');
                                    }
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete device ".$this->_device.": ".mysql_error(), FALSE, FALSE, 28, 'System', '');
                                }
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete device ".$this->_device.". Device does not exist", FALSE, FALSE, 28, 'System', '');
                                }
                            }
                            else
                            {
                                if ($this->GetVerboseFlag())
                                {
                                    $this->WriteLog("Info: *Device ".$this->_device." successfully deleted", FALSE, FALSE, 19, 'Device', '');
                                }
                                $result = TRUE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }                        
        }
        return $result;
    }


    function GetDevicesList()
    {
        return $this->GetList('device_id', 'sql_devices_table', $this->GetDevicesFolder());
    }


    /***************************
     ***************************
     ***************************
     ***   GROUPS HANDLING   ***
     ***************************
     ***************************
     ***************************/

    function CreateGroup($id = '', $name = '', $description = '')
    {
        $group_id = $id;
        if (('' == $group_id) || ('0' == $group_id))
        {
            $group_id = bigdec2hex((time()-mktime(1,1,1,1,1,2000)).mt_rand(10000,99999));
        }
        if ($this->CheckGroupExists($group_id))
        {
            return FALSE; // ERROR: group already exists.
        }
        else
        {
            $this->SetGroup($group_id);
            $this->SetGroupName($name);
            $this->SetGroupDescription($description);
            return $this->WriteGroupData();
        }
    }    


    function ReadGroupData($group_id = '', $create = FALSE)
    {
        if ('' != $group_id)
        {
            $this->SetGroup($group_id);
        }
        $result = FALSE;
        
        // We initialize the encryption hash to empty
        $this->_group_data['encryption_hash'] = '';
        
        // First, we read the user file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $group_filename = strtolower($this->GetGroup()).'.db';
            if (!file_exists($this->GetGroupsFolder().$group_filename))
            {
                if (!$create)
                {
                    $this->WriteLog("Error: database file ".$this->GetGroupsFolder().$group_filename." for group ".$this->_group." does not exist", FALSE, FALSE, 299, 'System', '');
                }
            }
            else
            {
                $file_handler = fopen($this->GetGroupsFolder().$group_filename, "rt");
                $first_line = trim(fgets($file_handler));
                
                while (!feof($file_handler))
                {
                    $line = trim(fgets($file_handler));
                    $line_array = explode("=",$line,2);
                    if (":" == substr($line_array[0], -1))
                    {
                        $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                        $line_array[1] = $this->Decrypt($line_array[0],$line_array[1],$this->GetEncryptionKey());
                    }
                    if ('' != trim($line_array[0]))
                    {
                        $this->_group_data[strtolower($line_array[0])] = $line_array[1];
                    }
                }
                
                fclose($file_handler);
                $result = TRUE;

                if ('' != $this->_group_data['encryption_hash'])
                {
                    if ($this->_group_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                    {
                        $this->_group_data['encryption_hash'] = "ERROR";
                        $this->WriteLog("Error: the group information encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                        $result = FALSE;
                    }
                }
            }
        }

        // And now, we override the values if another backend type is defined
        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_groups_table'])
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_groups_table']."` WHERE `group_id` = '".$this->_group."'";
                            $aRow = NULL;
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".trim($this->_mysqli->error).' ', TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = $rResult->fetch_assoc();
                                }
                            }
                            else
                            {
                                if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                                {
                                    $this->WriteLog("Error: SQL database query error ($sQuery) : ".mysql_error(), TRUE, FALSE, 199, 'System', '');
                                    $result = FALSE;
                                }
                                else
                                {
                                    $aRow = mysql_fetch_assoc($rResult);
                                }
                            }

                            if (NULL != $aRow)
                            {
                                $result = FALSE;
                                while(list($key, $value) = @each($aRow))
                                {
                                    $in_the_schema = FALSE;
                                    reset($this->_sql_tables_schema['groups']);
                                    while(list($valid_key, $valid_format) = @each($this->_sql_tables_schema['groups']))
                                    {
                                        if ($valid_key == $key)
                                        {
                                            $in_the_schema = TRUE;
                                        }
                                    }
                                    if (($in_the_schema) && ($key != 'group_id'))
                                    {
                                        if (('ENC:' == substr($value,0,4)) && (':ENC' == substr($value,-4)))
                                        {
                                            $value = substr($value,4);
                                            $value = substr($value,0,strlen($value)-4);
                                            $this->_group_data[$key] = $this->Decrypt($key,$value,$this->GetEncryptionKey());
                                        }
                                        else
                                        {
                                            $this->_group_data[$key] = $value;
                                        }
                                    }                                    
                                    elseif ((!$in_the_schema) && ('unique_id' != $key)  && $this->GetVerboseFlag())
                                    {
                                        $this->WriteLog("Warning: *The key ".$key." is not in the groups database schema", FALSE, FALSE, 98, 'System', '');
                                    }
                                    $result = TRUE;
                                }
                                if(0 == count($aRow) && !$create)
                                {
                                    $this->WriteLog("Error: SQL database entry for group ".$this->_group." does not exist", FALSE, FALSE, 299, 'System', '');
                                }
                            }
                        }
                        if ('' != $this->_group_data['encryption_hash'])
                        {
                            if ($this->_group_data['encryption_hash'] != $this->CalculateControlHash($this->GetEncryptionKey()))
                            {
                                $this->_group_data['encryption_hash'] = "ERROR";
                                $this->WriteLog("Error: the groups mysql encryption key is not matching", FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }
        }
        return $result;
    }


    function WriteGroupData()
    {
        if ('' == trim($this->GetGroup())) {
            $result = false;
        } else {
            $result = $this->WriteData('Group',
                                       'groups',
                                       $this->GetGroupsFolder(),
                                       $this->_group_data,
                                       false,
                                       'group_id',
                                       $this->GetGroup()
                                      );
        }
        return $result;
    }


    function SetGroup($group)
    {
        $this->ResetGroupArray();
        $this->_group = strtolower($group);
        $this->ReadGroupData('', TRUE); // First parameter empty, otherwise it will loop with SetGroup !
    }


    function GetGroup()
    {
        return $this->_group;
    }


    function SetGroupDescription($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetGroup($first_param);
            $result = $second_param;
        }
        $this->_group_data['description'] = $result;

        return $result;
    }


    function SetGroupName($first_param, $second_param = "*-*")
    {
        $result = "";
        if ($second_param == "*-*")
        {
            $result = $first_param;
        }
        else
        {
            $this->SetGroup($first_param);
            $result = $second_param;
        }
        $this->_group_data['name'] = $result;

        return $result;
    }


    function GetGroupDescription($group = '')
    {
        if($group != '')
        {
            $this->SetGroup($group);
        }
        return $this->_group_data['description'];
    }


    function GetGroupName($group = '')
    {
        if($group != '')
        {
            $this->SetGroup($group);
        }
        return $this->_group_data['name'];
    }


    function DeleteGroup($group = '', $no_error_info = FALSE)
    {
        if ('' != $group)
        {
            $this->SetGroup($group);
        }
        
        $result = FALSE;
        
        // First, we delete the group file if the backend is files or when migration is enabled
        if (('files' == $this->GetBackendType()) || ($this->GetMigrationFromFile()))
        {
            $group_filename = strtolower($this->_group).'.db';
            if (!file_exists($this->GetGroupsFolder().$group_filename))
            {
                if (!$no_error_info)
                {
                    $this->WriteLog("Error: Unable to delete group ".$this->_group.", database file ".$this->GetGroupsFolder().$group_filename." does not exist", FALSE, FALSE, 28, 'System', '');
                }
            }
            else
            {
                $result = unlink($this->GetGroupsFolder().$group_filename);
                if ($result)
                {
                    if ($this->GetVerboseFlag())
                    {
                        $this->WriteLog("Info: *Group ".$this->_group." successfully deleted", FALSE, FALSE, 19, 'Group', '');
                    }
                }
                else
                {
                    if (!$no_error_info)
                    {
                        $this->WriteLog("Error: Unable to delete group ".$this->_group, FALSE, FALSE, 28, 'Group', '');
                    }
                }
            }
        }

        if ($this->GetBackendTypeValidated())
        {
            switch ($this->_config_data['backend_type'])
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        if ('' != $this->_config_data['sql_groups_table'])
                        {
                            $sQuery  = "DELETE FROM `".$this->_config_data['sql_groups_table']."` WHERE `group_id` = '".$this->_group."'";
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    if (!$no_error_info)
                                    {
                                        $this->WriteLog("Error: Could not delete group ".$this->_group.": ".trim($this->_mysqli->error), FALSE, FALSE, 28, 'System', '');
                                    }
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete group ".$this->_group.": ".mysql_error(), FALSE, FALSE, 28, 'System', '');
                                }
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                if (!$no_error_info)
                                {
                                    $this->WriteLog("Error: Could not delete group ".$this->_group.". Group does not exist", FALSE, FALSE, 28, 'Group', '');
                                }
                            }
                            else
                            {
                                if ($this->GetVerboseFlag())
                                {
                                    $this->WriteLog("Info: *Group ".$this->_group." successfully deleted", FALSE, FALSE, 19, 'Group', '');
                                }
                                $result = TRUE;
                            }
                        }
                    }
                    break;
                default:
                // Nothing to do if the backend type is unknown
                    break;
            }                        
        }
        return $result;
    }


    // Check if group exists
    function CheckGroupExists($group = '')
    {
        $check_group = ('' != $group)?$group:$this->GetGroup();
        $result = FALSE;

        if ('' != trim($check_group))
        {
            if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data['sql_groups_table'])) || ('files' == $this->GetBackendType()))
            {
                switch ($this->GetBackendType())
                {
                    case 'mysql':
                        if ($this->OpenMysqlDatabase())
                        {
                            $sQuery  = "SELECT * FROM `".$this->_config_data['sql_groups_table']."` WHERE `group_id` = '{$check_group}'";
                            
                            if (is_object($this->_mysqli))
                            {
                                if (!($rResult = $this->_mysqli->query($sQuery)))
                                {
                                    $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                }
                                else
                                {
                                    $num_rows = $this->_mysqli->affected_rows;
                                }
                            }
                            elseif (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                $num_rows = mysql_affected_rows($this->_mysql_database_link);
                            }
                            
                            if (0 == $num_rows)
                            {
                                $this->WriteLog("Error: Group ".$group.". does not exist", FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                            else
                            {
                                $result = TRUE;
                            }
                        }
                        break;
                    case 'files':
                    default:
                        $group_filename = strtolower($check_group).'.db';
                        $result = file_exists($this->GetGroupsFolder().$group_filename);
                        break;
                }
            }
        }
        return $result;
    }


    function GetGroupsList()
    {
        return $this->GetList('group_id', 'sql_groups_table', $this->GetGroupsFolder());
    }


    function GetList($raw_id, $table_name, $folder)
    {
        $list = '';
        if ((($this->GetBackendTypeValidated()) && ('' != $this->_config_data[$table_name])) || ('files' == $this->GetBackendType()))
        {
            switch ($this->GetBackendType())
            {
                case 'mysql':
                    if ($this->OpenMysqlDatabase())
                    {
                        $sQuery = "SELECT `".$raw_id."` FROM `".$this->_config_data[$table_name]."`";
                        if (is_object($this->_mysqli))
                        {
                            if (!($result = $this->_mysqli->query($sQuery)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".trim($this->_mysqli->error), FALSE, FALSE, 299, 'System', '');
                                $result = FALSE;
                            }
                            else
                            {
                                while ($aRow = $result->fetch_assoc())
                                {
                                    if ('' != $aRow[$raw_id])
                                    {
                                        $list.= (('' != $list)?"\t":'').$aRow[$raw_id];
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (!($rResult = mysql_query($sQuery, $this->_mysql_database_link)))
                            {
                                $this->WriteLog("Error: Unable to access the database: ".mysql_error(), FALSE, FALSE, 299, 'System', '');
                            }
                            else
                            {
                                while ($aRow = mysql_fetch_assoc($rResult))
                                {
                                    if ('' != $aRow[$raw_id])
                                    {
                                        $list.= (('' != $list)?"\t":'').$aRow[$raw_id];
                                    }
                                }                         
                            }
                        }
                    }
                    break;
                case 'files':
                default:
                    if ($file_handle = @opendir($folder))
                    {
                        while ($file = readdir($file_handle))
                        {
                            if ((substr($file, -3) == ".db") && ($file != '.db'))
                            {
                                $list.= (('' != $list)?"\t":'').substr($file,0,-3);
                            }
                        }
                        closedir($file_handle);
                    }
            }
        }
        return $list;
    }


    function GetHardwareType()
    {
        $type = "unknown";
        $os_running = php_uname();
        // Is it potentially a nanocomputer (BeagleBone Black or Raspberry Pi 2) ?
        if (FALSE !== strpos(strtolower($os_running), 'armv7l'))
        {
			$hardware = '';
			exec("cat /proc/cpuinfo", $output);
			foreach($output as $line)
			{
				$line = $line."  ";
				if (preg_match("/^Hardware\s*:\s*(.*)/", $line))
				{
					preg_match_all("/^Hardware\s*:\s*(.*)/", $line, $result_array, PREG_SET_ORDER);
					if (isset($result_array[0][1]))
					{
						$hardware = strtoupper(trim($result_array[0][1]));
						break;
					}
				}
			}
			if (FALSE !== strpos(strtolower($os_running), 'bcm27')) {
				$type = 'RP2'; // Raspberry Pi 2 (BCM2709)
			} else {
				$type = 'BBB'; // Beaglebone Black (Generic AM33XX and others)
			}
        }
        // Is it potentially a Raspberry Pi B/B+ ?
        elseif (FALSE !== strpos(strtolower($os_running), 'armv6l'))
        {
            $type = 'RPI';
		}
        // Is it potentially a Windows development platform ?
        elseif (strtolower(substr(PHP_OS, 0, 3)) === 'win')
        {
            $type = "DVP";
        }
        // Is it a virtual appliance and/or a Linux Debian edition
        elseif (FALSE !== strpos(strtolower($os_running), 'debian'))
        {
            $type = 'VAP';
        }
        return $type;
    }


    function GetRaspberryPiSerialNumber()
    {
        $serial = '';
        exec("cat /proc/cpuinfo", $output);
        foreach($output as $line)
        {
            $line = $line."  ";
            if (preg_match("/^Serial\s*:\s*(.*)/", $line))
            {
                preg_match_all("/^Serial\s*:\s*(.*)/", $line, $result_array, PREG_SET_ORDER);
                if (isset($result_array[0][1]))
                {
                    $serial = strtoupper(trim($result_array[0][1]));
                    break;
                }
            }
        }
        return $serial;
    }


    function ReadUserDataOnServer($user)
    {
        $result = 72;

        /* This option is too long
        if (function_exists('openssl_random_pseudo_bytes')) {
            $server_challenge = 'MOSH'.bin2hex(openssl_random_pseudo_bytes(16));
        } else {
        */
            $server_challenge = 'MOSH'.md5($this->GetEncryptionKey().time().mt_rand(100000,999999));
        /* } */
        $this->SetServerChallenge($server_challenge);

        $xml_data = <<<EOL
*XmlVersion*
<multiOTP version="4.0" xmlns="http://www.sysco.ch/namespaces/multiotp">
<ServerChallenge>*ServerChallenge*</ServerChallenge>
<ReadUserData>
    <UserId>*UserId*</UserId>
</ReadUserData>
</multiOTP>
EOL;
        $xml_data = str_replace('*XmlVersion*', '<?xml version="1.0" encoding="UTF-8"?>', $xml_data);
        $xml_data = str_replace('*ServerChallenge*', $this->Encrypt('ServerChallenge', $server_challenge, $this->GetServerSecret()), $xml_data);
        $xml_data = str_replace('*UserId*', $user, $xml_data);
        
        $xml_urls = $this->GetServerUrl();
        $xml_timeout = $this->GetServerTimeout();
        $xml_data_encoded = urlencode($xml_data);
        
        $response = $this->PostHttpDataXmlRequest($xml_data_encoded, $xml_urls, $xml_timeout);

        if (FALSE !== $response)
        {
            if ($this->_xml_dump_in_log)
            {
                $this->WriteLog("Info: Host returned the following answer: $response", FALSE, FALSE, 8888, 'Debug', '');
            }
            
            if (FALSE !== strpos($response,'<multiOTP'))
            {
                $error_code = 99;
                
                //Set up the parser object
                $xml = new MultiotpXmlParser($response);

                //Parse it !
                $xml->Parse();

                if (isset($xml->document->errorcode[0]))
                {
                    $server_password = (isset($xml->document->serverpassword[0])?($xml->document->serverpassword[0]->tagData):'');
                    
                    if ($server_password != md5('ReadUserData'.$this->GetServerSecret().$this->GetServerChallenge()))
                    {
                        $error_code = 70;
                    }
                    else
                    {
                        $error_code = (isset($xml->document->errorcode[0])?intval($xml->document->errorcode[0]->tagData):99);
                    }
                    $error_description = (isset($xml->document->errordescription[0])?($xml->document->errordescription[0]->tagData):$this->GetErrorText($error_code));

                    if ($this->_xml_dump_in_log)
                    {
                        $this->WriteLog("Info: Host returned the following result: $error_code ($error_description)", FALSE, FALSE, $error_code, 'Debug', '');
                    }
                }
                if ((19 == $error_code) && (isset($xml->document->user[0])))
                {
                    $result = (isset($xml->document->user[0]->userdata[0])?($xml->document->user[0]->userdata[0]->tagData):'');
                }
                else
                {
                    $this->WriteLog("Error: Host answers with the following error code: $error_code ($error_description)", FALSE, FALSE, 299, 'Client-Server', '');
                    $result = $error_code;
                }
            }
            else
            {
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Error: *Host sent an incorrect answer: $response", FALSE, FALSE, 299, 'Client-Server', '');
                }
            }
        }
        return $result;
    }


    function CheckUserExistsOnServer($user = '')
    {
        $result = 72;
        
        /* This option is too long
        if (function_exists('openssl_random_pseudo_bytes')) {
            $server_challenge = 'MOSH'.bin2hex(openssl_random_pseudo_bytes(16));
        } else {
        */
            $server_challenge = 'MOSH'.md5($this->GetEncryptionKey().time().mt_rand(100000,999999));
        /* } */
        $this->SetServerChallenge($server_challenge);

        $xml_data = <<<EOL
*XmlVersion*
<multiOTP version="4.0" xmlns="http://www.sysco.ch/namespaces/multiotp">
<ServerChallenge>*ServerChallenge*</ServerChallenge>
<CheckUserExists>
    <UserId>*UserId*</UserId>
</CheckUserExists>
</multiOTP>
EOL;
        $xml_data = str_replace('*XmlVersion*', '<?xml version="1.0" encoding="UTF-8"?>', $xml_data);
        $xml_data = str_replace('*ServerChallenge*', $this->Encrypt('ServerChallenge', $server_challenge, $this->GetServerSecret()), $xml_data);
        $xml_data = str_replace('*UserId*', $user, $xml_data);
        
        $xml_urls = $this->GetServerUrl();
        $xml_timeout = $this->GetServerTimeout();
        $xml_data_encoded = urlencode($xml_data);
        
        $response = $this->PostHttpDataXmlRequest($xml_data_encoded, $xml_urls, $xml_timeout);

        if (FALSE !== $response)
        {
            if ($this->_xml_dump_in_log)
            {
                $this->WriteLog("Info: Host returned the following answer: $response", FALSE, FALSE, 8888, 'Debug', '');
            }
            
            if (FALSE !== strpos($response,'<multiOTP'))
            {
                $error_code = 99;
                
                //Set up the parser object
                $xml = new MultiotpXmlParser($response);

                //Parse it !
                $xml->Parse();

                if (isset($xml->document->errorcode[0]))
                {
                    $server_password = (isset($xml->document->serverpassword[0])?($xml->document->serverpassword[0]->tagData):'');
                    
                    if ($server_password != md5('CheckUserExists'.$this->GetServerSecret().$this->GetServerChallenge()))
                    {
                        $error_code = 70;
                    }
                    else
                    {
                        $error_code = (isset($xml->document->errorcode[0])?intval($xml->document->errorcode[0]->tagData):99);
                    }
                    $error_description = (isset($xml->document->errordescription[0])?($xml->document->errordescription[0]->tagData):$this->GetErrorText($error_code));

                    if ($this->_xml_dump_in_log)
                    {
                        $this->WriteLog("Info: Host returned the following result: $error_code ($error_description).", FALSE, FALSE, $error_code, 'Debug', '');
                    }
                }
                // User doesnt exist: 21 - User exists = 22
                $result = $error_code;
            }
            else
            {
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Error: *Host sent an incorrect answer: $response", FALSE, FALSE, 8888, 'Client-Server', '');
                }
            }
        }
        return $result;
    }


    function CheckUserTokenOnServer($user, $password, $auth_method="PAP", $id= '', $challenge = '', $response2 = '')
    {
        $result = 72;
        
        /* This option is too long
        if (function_exists('openssl_random_pseudo_bytes')) {
            $server_challenge = 'MOSH'.bin2hex(openssl_random_pseudo_bytes(16));
        } else {
        */
            $server_challenge = 'MOSH'.md5($this->GetEncryptionKey().time().mt_rand(100000,999999));
        /* } */
        $this->SetServerChallenge($server_challenge);

        switch (strtoupper($auth_method))
        {
            case 'CHAP':
                $chap_id        = $id;
                $chap_challenge = $challenge;
                $chap_password  = $password;
                $chap_hash      = '';
                break;
            case 'MS-CHAP':
                $ms_chap_id        = $id;
                $ms_chap_challenge = $challenge;
                $ms_chap_response  = $password;
                $chap_hash      = '';
                break;
            case ' MS-CHAPV2':
                $ms_chap_id        = $id;
                $ms_chap_challenge = $challenge;
                $ms_chap_response  = $password;
                $ms_chap2_response = $response2;
                $chap_hash      = '';
                break;
            case 'PAP':
            default:
                /*
                $chap_id        = '';
                $chap_challenge = md5(time());
                $chap_password  = $password;
                */
                $chap_id        = bin2hex(chr(mt_rand(0, 255)));
                $chap_challenge = md5(time());
                $chap_password  = $this->CalculateChapPassword($password, $chap_id, $chap_challenge);
                $chap_hash      = $this->Encrypt('ChapHash', $password, $chap_id.$server_challenge.$chap_id);
                break;
        }

        $xml_data = <<<EOL
*XmlVersion*
<multiOTP version="4.0" xmlns="http://www.sysco.ch/namespaces/multiotp">
<ServerChallenge>*ServerChallenge*</ServerChallenge>
<CheckUserToken>
    <UserId>*UserId*</UserId>
    <Chap>
        <ChapId>*ChapId*</ChapId>
        <ChapChallenge>*ChapChallenge*</ChapChallenge>
        <ChapPassword>*ChapPassword*</ChapPassword>
        <ChapHash>*ChapHash*</ChapHash>
    </Chap>
    <CacheLevel>*CacheLevel*</CacheLevel>
</CheckUserToken>
</multiOTP>
EOL;
        $xml_data = str_replace('*XmlVersion*', '<?xml version="1.0" encoding="UTF-8"?>', $xml_data);
        $xml_data = str_replace('*ServerChallenge*', $this->Encrypt('ServerChallenge', $server_challenge, $this->GetServerSecret()), $xml_data);
        $xml_data = str_replace('*UserId*', $user, $xml_data);
        $xml_data = str_replace('*ChapId*', $chap_id, $xml_data);
        $xml_data = str_replace('*ChapChallenge*', $chap_challenge, $xml_data);
        $xml_data = str_replace('*ChapPassword*', $chap_password, $xml_data);
        $xml_data = str_replace('*ChapHash*', $chap_hash, $xml_data);
        $xml_data = str_replace('*CacheLevel*', $this->GetServerCacheLevel(), $xml_data);
        
        $xml_urls = $this->GetServerUrl();
        $xml_timeout = $this->GetServerTimeout();
        $xml_data_encoded = urlencode($xml_data);

        // $this->WriteLog("Debug: Host received the following request: $xml_data", FALSE, FALSE, 8888, 'Debug', '');
        
        $response = $this->PostHttpDataXmlRequest($xml_data_encoded, $xml_urls, $xml_timeout);

        if (FALSE !== $response)
        {
            if ($this->_xml_dump_in_log)
            {
                $this->WriteLog("Debug: Host returned the following answer: $response", FALSE, FALSE, 8888, 'Debug', '');
            }

            if (FALSE !== strpos($response,'<multiOTP'))
            {
                $result = 99;
                $error_code = 99;
                
                //Set up the parser object
                $xml = new MultiotpXmlParser($response);

                //Parse it !
                $xml->Parse();

                if (isset($xml->document->errorcode[0]))
                {
                    $server_password = (isset($xml->document->serverpassword[0])?($xml->document->serverpassword[0]->tagData):'');
                    
                    if ($server_password != md5('CheckUserToken'.$this->GetServerSecret().$this->GetServerChallenge()))
                    {
                        $error_code = 70;
                    }
                    else
                    {
                        $error_code = (isset($xml->document->errorcode[0])?intval($xml->document->errorcode[0]->tagData):99);
                    }
                    $error_description = (isset($xml->document->errordescription[0])?($xml->document->errordescription[0]->tagData):$this->GetErrorText($error_code));
                    $result = $error_code;

                    if ($this->_xml_dump_in_log)
                    {
                        $this->WriteLog("Info: Host returned the following result: $result ($error_description).", FALSE, FALSE, $result, 'Debug', '');
                    }
                }

                if ((0 == $error_code) && (isset($xml->document->cache[0])))
                {
                    if (isset($xml->document->cache[0]->user[0]))
                    {
                        foreach ($xml->document->cache[0]->user as $one_user)
                        {
                            $current_user = isset($one_user->tagAttrs['userid'])?$one_user->tagAttrs['userid']:'';
                            if ('' != $current_user)
                            {
                                $current_user_data = isset($one_user->userdata[0])?$one_user->userdata[0]->tagData:'';
                                if ('' != $current_user_data)
                                {
                                    $this->SetUser($current_user);
                                    $this->_user_data['encryption_hash'] = $this->CalculateControlHash($this->GetEncryptionKey());
                                    $current_user_array = explode("\n",$current_user_data);

                                    foreach ($current_user_array as $one_line)
                                    {
                                        $line = trim($one_line);
                                        $line_array = explode("=",$line,2);
                                        if (":" == substr($line_array[0], -1))
                                        {
                                            $line_array[0] = substr($line_array[0], 0, strlen($line_array[0]) -1);
                                            $line_array[1] = $this->Decrypt($line_array[0], $line_array[1], $this->GetServerSecret());
                                        }
                                        if ('' != trim($line_array[0]))
                                        {
                                            if ('encryption_hash' != strtolower($line_array[0]))
                                            {
                                                $this->_user_data[strtolower($line_array[0])] = $line_array[1];
                                            }
                                        }
                                    }
                                    $this->WriteUserData();
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Error: *Host sent an incorrect answer: $response", FALSE, FALSE, 8888, 'Client-Server', '');
                }
            }
        }
        $this->SetUser($user);
        return $result;
    }


    function PostHttpDataXmlRequest($xml_data, $xml_urls, $xml_timeout = 1)
    {
        $result = FALSE;
        $content_to_post = 'data='.$xml_data;
        $xml_url = explode(";",$xml_urls);
        
        foreach ($xml_url as $xml_url_one)
        {
            $server_to_ban = $xml_url_one;
            $skip = FALSE;
            foreach ($this->GetTemporaryBadServer() as $temp_bad_server)
            {
                if ($temp_bad_server == $server_to_ban)
                {
                    $skip = TRUE;
                }
            }
            
            if (!$skip)
            {
                $port = 80;

                $pos = strpos($xml_url_one, '://');
                if (FALSE === $pos)
                {
                    $protocol = '';
                }
                else
                {
                    switch (strtolower(substr($xml_url_one,0,$pos)))
                    {
                        case 'https':
                        case 'ssl':
                            $protocol = 'ssl://';
                            $port = 443;
                            break;
                        case 'tls':
                            $protocol = 'tls://';
                            $port = 443;
                            break;
                        default:
                            $protocol = '';
                            break;
                    }
                    
                    $xml_url_one = substr($xml_url_one,$pos+3);
                }
                
                $pos = strpos($xml_url_one, '/');
                if (FALSE === $pos)
                {
                    $host = $xml_url_one;
                    $url = '/';
                }
                else
                {
                    $host = substr($xml_url_one,0,$pos);
                    $url = substr($xml_url_one,$pos); // And not +1 as we want the / at the beginning
                }
                
                $pos = strpos($host, ':');
                if (FALSE !== $pos)
                {
                    $port = substr($host,$pos+1);
                    $host = substr($host,0,$pos);
                }
                
                $errno = 0;
                $errdesc = 0;
                $fp = @fsockopen($protocol.$host, $port, $errno, $errdesc, $xml_timeout);
                if (FALSE !== $fp)
                {
                    $info['timed_out'] = FALSE;
                    fputs($fp, "POST ".$url." HTTP/1.0\r\n");
                    fputs($fp, "Content-Type: application/x-www-form-urlencoded\r\n");
                    fputs($fp, "Content-Length: ".strlen($content_to_post)."\r\n");
                    fputs($fp, "User-Agent: multiOTP\r\n");
                    fputs($fp, "Host: ".$host."\r\n");
                    fputs($fp, "\r\n");
                    fputs($fp, $content_to_post);
                    fputs($fp, "\r\n");

                    stream_set_blocking($fp, TRUE);
                    stream_set_timeout($fp, $xml_timeout);
                    $info = stream_get_meta_data($fp); 
            
                    $reply = '';
                    $last_length = 0;
                    while ((!feof($fp)) && ((!$info['timed_out']) || ($last_length != strlen($reply))))
                    {
                        $last_length = strlen($reply);
                        $reply.= fgets($fp, 1024);
                        $info = stream_get_meta_data($fp);
                        @ob_flush(); // Avoid notice if any (if the buffer is empty and therefore cannot be flushed)
                        flush(); 
                    }
                    fclose($fp);

                    if ($info['timed_out'])
                    {
                        $this->WriteLog("Warning: timeout after $xml_timeout seconds for $protocol$host:$port$url with a result code of $errno ($errdesc).", FALSE, FALSE, 8888, 'Client-Server', '');
                    }
                    else
                    {
                        $pos = strpos(strtolower($reply), "\r\n\r\n");
                        $header = substr($reply, 0, $pos);
                        $answer = substr($reply, $pos + 4);
                        
                        $result = $answer;
                        if ($errno > 0)
                        {
                            $this->WriteLog("Info: $protocol$host:$port$url returns a resultcode of $errno ($errdesc).", FALSE, FALSE, 8888, 'Client-Server', '');
                        }
                        if (FALSE !== strpos($result,'<multiOTP'))
                        {
                            break;
                        }
                    }
                    // If we are here, something was bad with the actual server
                    $this->AddTemporaryBadServer($server_to_ban);
                    $log_info = "Info: temporary adding $server_to_ban to the list of banned servers, content not recognized";
                    if ($this->_xml_dump_in_log)
                    {
                        $log_info.= ": ".$result;
                    }

                    $this->WriteLog($log_info, FALSE, FALSE, 8888, 'Client-Server', '');
                }
                else
                {
                    $this->AddTemporaryBadServer($server_to_ban);
                    $this->WriteLog("Warning: Host $protocol$host on port $port not reached before a timeout of $xml_timeout seconds.", FALSE, FALSE, 8888, 'Client-Server', '');
                }
            }
            else
            {
                // This server has been skipped
                $this->WriteLog("Info: temporary skipping $xml_url_one due to timeout or inconsistent response.", FALSE, FALSE, 8888, 'Client-Server', '');
                $result = "";
            }
        }

        if (FALSE === strpos($result,'<multiOTP'))
        {
            $this->_servers_last_timeout = time();

            if ($this->_xml_dump_in_log)
            {
                $this->WriteLog("Debug: timeout detected.", FALSE, FALSE, 8888, 'Debug', '');
            }
        }
        return $result;
    }


    function XmlServer($data)
    {
        // $this->WriteLog("Info: Host received the following request: $data", FALSE, FALSE, 8888, 'Debug', '');

        $cache_data      = '';
        $command_name    = '';
        $error_code      = 71;
        $server_password = '';
        $user_data       = '';
        $user_info       = '';
        $user_password   = '';

        $cache_data_template = <<<EOL
        <Cache>
        *UserInCache*</Cache>
EOL;

        $user_template = <<<EOL
            <User UserId="*UserId*">
                <UserData>*UserData*</UserData>
            </User>
EOL;

        $xml_data = <<<EOL
*XmlVersion*
<multiOTP version="4.0" xmlns="http://www.sysco.ch/namespaces/multiotp">
<DebugCode>*Command*</DebugCode>
<ServerPassword>*ServerPassword*</ServerPassword>
<ErrorCode>*ErrorCode*</ErrorCode>
<ErrorDescription>*ErrorDescription*</ErrorDescription>
*UserInfo**Cache*</multiOTP>
EOL;
        $xml_data = str_replace('*XmlVersion*', '<?xml version="1.0" encoding="UTF-8"?>', $xml_data);
        
        if (FALSE !== strpos($data,'<multiOTP'))
        {
            if ($this->_xml_dump_in_log)
            {
                $this->WriteLog("Info: Host answer is correctly formatted.", FALSE, FALSE, 8888, 'Debug', '');
                $this->WriteLog("Info: Host received the following request: $data", FALSE, FALSE, 8888, 'Debug', '');
            }
            
            //Set up the parser object
            $xml = new MultiotpXmlParser($data);

            //Parse it !
            $xml->Parse();

            $server_challenge = $this->Decrypt('ServerChallenge', (isset($xml->document->serverchallenge[0])?($xml->document->serverchallenge[0]->tagData):''),$this->GetServerSecret());

            if (isset($xml->document->checkusertoken[0]))
            {
                $command_name = 'CheckUserToken';
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Info: *CheckUserToken server request.", FALSE, FALSE, 8888, 'Server-Client', '');
                }
                $user_id = (isset($xml->document->checkusertoken[0]->userid[0])?($xml->document->checkusertoken[0]->userid[0]->tagData):'');
                $chap_id = (isset($xml->document->checkusertoken[0]->chap[0]->chapid[0])?($xml->document->checkusertoken[0]->chap[0]->chapid[0]->tagData):'00');
                $chap_challenge = (isset($xml->document->checkusertoken[0]->chap[0]->chapchallenge[0])?($xml->document->checkusertoken[0]->chap[0]->chapchallenge[0]->tagData):'');
                $chap_password = (isset($xml->document->checkusertoken[0]->chap[0]->chappassword[0])?($xml->document->checkusertoken[0]->chap[0]->chappassword[0]->tagData):'');

                $chap_hash = (isset($xml->document->checkusertoken[0]->chap[0]->chaphash[0])?($xml->document->checkusertoken[0]->chap[0]->chaphash[0]->tagData):'');
                if ('' != $chap_hash) {
                    $chap_hash = $this->Decrypt('ChapHash', $chap_hash, $chap_id.$server_challenge.$chap_id);
                }
                
                $cache_level = (isset($xml->document->checkusertoken[0]->cachelevel[0])?($xml->document->checkusertoken[0]->cachelevel[0]->tagData):0);
                if ($cache_level > $this->GetServerCacheLevel())
                {
                    $cache_level = $this->GetServerCacheLevel();
                }
                
                $error_code = 70;

                if ('MOSH' == substr($server_challenge, 0, 4)) // Ok, the challenge is encoded with the correct server secret
                {
                    if ('' != $chap_hash) {
                        $this->SetChapId('');
                        $this->SetChapChallenge('');
                        $this->SetChapPassword('');
                        $user_password = $chap_hash;
                    } elseif ('' == $chap_id) {
                        $this->SetChapId('');
                        $this->SetChapChallenge('');
                        $this->SetChapPassword('');
                        $user_password = $chap_password;
                    } else {
                        $this->SetChapId($chap_id);
                        $this->SetChapChallenge($chap_challenge);
                        $this->SetChapPassword($chap_password);
                    }
                    
                    if (!$this->CheckUserExists($user_id))
                    {
                        $error_code = 21; // ERROR: User doesn't exist
                    }                    
                    else
                    {
                        $error_code = $this->CheckUserToken($user_id, $user_password, '', FALSE, FALSE, FALSE, TRUE); // do_not_check_on_server = TRUE;
                        
                        $now_epoch = time();
                        $cache_lifetime = $this->GetServerCacheLifetime();

                        if ((0 < $cache_level) && (0 == $error_code))
                        {
                            if ($this->GetVerboseFlag())
                            {
                                $this->WriteLog("Info: *Cache level is set to $cache_level", FALSE, FALSE, 8888, 'Server-Client', '');
                            }
                            
                            reset($this->_user_data);
                            while(list($key, $value) = each($this->_user_data))
                            {
                                if ('' != trim($key))
                                {
                                    if ('encryption_hash' != $key)
                                    {
                                        $user_data.= strtolower($key);
                                        if ('autolock_time' == $key)
                                        {
                                            if (0 < $cache_lifetime)
                                            {
                                                if (($value == 0) || ($value > ($now_epoch + $cache_lifetime)))
                                                {
                                                    $value = ($now_epoch + $cache_lifetime);
                                                }
                                            }
                                        }
                                        $value = $this->Encrypt($key, $value, $this->GetServerSecret());
                                        $user_data = $user_data.":";
                                        $user_data = $user_data."=".$value;
                                        $user_data.= "\n";
                                    }
                                }
                            }

                            $cache_user = '';
                            $one_cache_user = str_replace('*UserId*', $user_id, $user_template);
                            $one_cache_user = str_replace('*UserData*', $user_data, $one_cache_user);
                            $cache_user .= $one_cache_user;
                            
                            $cache_data = str_replace('*UserInCache*', $cache_user, $cache_data_template);
                        }
                    }
                }
            } // End of CheckUserToken
            elseif (isset($xml->document->readuserdata[0]))
            {
                $command_name = 'ReadUserData';
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Info: *ReadUserData server request.", FALSE, FALSE, 8888, 'Server-Client', '');
                }
                $user_id = (isset($xml->document->readuserdata[0]->userid[0])?($xml->document->readuserdata[0]->userid[0]->tagData):'NO_USER_DETECTED!');

                $error_code = 70;

                if ('MOSH' == substr($server_challenge, 0, 4)) // Ok, the challenge is encoded with the correct server secret
                {
                    $error_code = 21; // ERROR: User doesn't exist

                    if ($this->ReadUserData($user_id, FALSE, TRUE)) // $no_server_check = TRUE;
                    {
                        $error_code = 19;
                        reset($this->_user_data);
                        while(list($key, $value) = each($this->_user_data))
                        {
                            if ('' != trim($key))
                            {
                                if ('encryption_hash' != $key)
                                {
                                    $user_data.= strtolower($key);
                                    $value = $this->Encrypt($key, $value, $this->GetServerSecret());
                                    $user_data = $user_data.":";
                                    $user_data = $user_data."=".$value;
                                    $user_data.= "\n";
                                }
                            }
                        }

                        $user_info = str_replace('*UserId*', $user_id, $user_template);
                        $user_info = str_replace('*UserData*', $user_data, $user_info);
                    }
                }
            } // End of ReadUserData
            elseif (isset($xml->document->checkuserexists[0]))
            {
                $command_name = 'CheckUserExists';
                if ($this->GetVerboseFlag())
                {
                    $this->WriteLog("Info: *CheckUserExists server request.", FALSE, FALSE, 8888, 'Server-Client', '');
                }
                $user_id = (isset($xml->document->checkuserexists[0]->userid[0])?($xml->document->checkuserexists[0]->userid[0]->tagData):'NO_USER_DETECTED!');

                $error_code = 70;

                if ('MOSH' == substr($server_challenge, 0, 4)) // Ok, the challenge is encoded with the correct server secret
                {
                    $error_code = 21; // ERROR: User doesn't exist

                    if ($this->CheckUserExists($user_id, TRUE)) // $no_server_check = TRUE;
                    {
                        $error_code = 22;
                    }
                }
            } // End of CheckUserExists
            
            $server_password = md5($command_name.$this->GetServerSecret().$server_challenge);
        }
        else
        if ($this->GetVerboseFlag())
        {
            $this->WriteLog("Info: *Server received the following request: $data", FALSE, FALSE, 8888, 'Server-Client', '');
        }
        

        $error_description = $this->GetErrorText($error_code);
        
        $xml_data = str_replace('*Command*', $command_name, $xml_data);
        $xml_data = str_replace('*ServerPassword*', $server_password, $xml_data);
        $xml_data = str_replace('*ErrorCode*', $error_code, $xml_data);
        $xml_data = str_replace('*ErrorDescription*', $error_description, $xml_data);
        $xml_data = str_replace('*UserInfo*', $user_info, $xml_data);
        $xml_data = str_replace('*Cache*', $cache_data, $xml_data);

        /****************************************
         * WE REALLY DO NOT WANT TO BE CACHED !!!
         ****************************************/
        header("Expires: " . gmdate("D, d M Y H:i:s") . " GMT");
        header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
        header("Cache-Control: no-store, no-cache, must-revalidate");
        header("Cache-Control: post-check=0, pre-check=0", false);
        header("Pragma: no-cache");

        if ($this->_xml_dump_in_log)
        {
            $this->WriteLog("Info: Server sent the following answer: $xml_data", FALSE, FALSE, 8888, 'Debug', '');
        }

        echo $xml_data;
    }


    // This method is a stub that calls the MultiotpQrcode with the good pathes
    function qrcode($data = '', $file_name = '', $image_type = "P", $ecc_level = "Q", $module_size = 4, $version = 0, $structure_m = 0, $structure_n = 0, $parity = 0, $original_data = '')
    {
        $result = '';

        $qrcode_folder = $this->GetQrCodeFolder();

        $path = $qrcode_folder.'data';
        $image_path = $qrcode_folder.'image';
        
        if (!(file_exists($path) && file_exists($image_path)))
        {
            $this->WriteLog("Error: QRcode files or folders are not available", FALSE, FALSE, 299, 'System', '');
        }
        else
        {
            $result = MultiotpQrcode($data, $file_name, $image_type, $ecc_level, $module_size, $version, $structure_m, $structure_n, $parity, $original_data, $path, $image_path);

            {
                $output_name = NULL;
                ob_start();
            }

            
            if (('' != trim($file_name)) && ('binary' != trim($file_name)) && ('' != $this->GetLinuxFileMode()))
            {
                if (file_exists($file_name))
                {
                    chmod($file_name, octdec($this->GetLinuxFileMode()));
                }
            }
        }
        
        return $result;
    }
    
    
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//                                                                  //
// The source codes of the next classes are not directly related to //
//  multiOTP but they are needed for extended functionalities.      //
//                                                                  //
// They are inserted directly in the class file to eliminitate any  //
//  include or require problem.                                     //
//                                                                  //
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


class MultiotpAspSms
/**
 * @class     MultiotpAspSms
 * @brief     SMS message using ASPSMS infrastructure.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.3.0.1
 * @date      2015-05-11
 * @since     2014-03-13
 */
{
    var $content;
    var $originator;
    var $password;
    var $recipient;
    var $server_timeout;
    var $servers;
    var $userkey;
	var $raw_content;
    var $reply;

    function MultiotpAspSms(
        $userkey,
        $password
    ) {
        $this->userkey        = $userkey;
        $this->password       = $password;
        $this->originator     = "multiOTP";
        $this->recipient      = '';
        $this->server_timeout = 5;
        $this->reply          = '';

        $this->servers = array("xml1.aspsms.com:5061",
							   "xml1.aspsms.com:5098",
							   "xml2.aspsms.com:5061",
                               "xml2.aspsms.com:5098"
							  );
    }


    function setUserkey($userkey)
    {
        $this->userkey = $userkey;
    }


    function getUserkey()
    {
        return $this->userkey;
    }


    function setPassword($password)
    {
        $this->password = $password;
    }


    function getPassword()
    {
        return $this->password;
    }


    function setOriginator($originator)
    {
        $this->originator = $originator;
    }


    function getOriginator()
    {
        return $this->originator;
    }


    function setRecipient($recipient)
    {
        $string = $recipient;
        $string = str_replace(' ','',$string);
        $string = str_replace('(','',$string);
        $string = str_replace(')','',$string);
        $string = str_replace('+','00',$string);

        $this->recipient = $string;
    }


    function getRecipient()
    {
        return $this->recipient;
    }


    function setServerTimeout($timeout)
    {
        $this->server_timeout = $timeout;
    }


    function getServerTimeout()
    {
        return $this->server_timeout;
    }


    function setContent($content)
    /*
     * The content is automatically converted from UTF-8 to ISO if needed
     */
    {
		$text = $content;
		$encoding = mb_detect_encoding($text . 'a' , 'UTF-8, ISO-8859-1');
		if ("UTF-8" == $encoding)
		{
			$text = utf8_decode($text);
		}
		$this->content = $text;
    }


    function getContent()
    {
		return $this->content;
    }


    function setRawContent($raw_content)
    {
		$this->raw_content = $raw_content;
    }


    function setReply($reply)
    {
		$this->reply = $reply;
    }


    function getReply()
    {
		return $this->reply;
    }


    function getRawContent()
    {
		return $this->raw_content;
    }


    function sendSMS($content = '')
    /*
     * Result: 1=ok / 0=ko
     */
    {
        $result = 0;

        if ('' != $content) {
            $this->setContent($content);
        }

        /*
            $ucs2_content = bin2hex(mb_convert_encoding($this->getContent(), 'UCS-2', 'auto'));
        */

		$raw_content = "<Recipient>\r\n<PhoneNumber>".htmlspecialchars($this->getRecipient(), ENT_QUOTES | ENT_HTML401, 'ISO-8859-1')."</PhoneNumber>\r\n</Recipient>\r\n".
                       "<Originator>".htmlspecialchars($this->getOriginator(), ENT_QUOTES | ENT_HTML401, 'ISO-8859-1')."</Originator>\r\n".
                       "<MessageData>".htmlspecialchars($this->getContent(), ENT_QUOTES | ENT_HTML401, 'ISO-8859-1')."</MessageData>\r\n".
                       "<Action>SendTextSMS</Action>\r\n";
        /*
            UCS2:
			   "<XSer>020108</XSer>\r\n".
			   "<MessageData>".$ucs2_content."</MessageData>\r\n".
			   "<Action>SendBinaryData</Action>\r\n".

            Standard:
			   "<MessageData>".htmlspecialchars($this->getContent(), ENT_QUOTES | ENT_HTML401, 'ISO-8859-1')."</MessageData>\r\n".
			   "<Action>SendTextSMS</Action>\r\n".
        */

        $this->setRawContent($raw_content);
		$result = $this->sendToServer();
        
        return $result;
    }


    function getCredits()
    {
        $raw_content = "<Action>ShowCredits</Action>\r\n";
        $this->setRawContent($raw_content);
        $credits = '';
		if (1 == $this->sendToServer()) {
            $reply = $this->getReply();
            if (FALSE !== strpos($reply,"<Credits>")) {
                $begin_credits_pos = strpos($reply,"<Credits>");
                $end_credits_pos = strpos($reply,"</Credits>");
                $credits = substr($reply, $begin_credits_pos + strlen("<Credits>"), $end_credits_pos - $begin_credits_pos - strlen("<Credits>"));
            }
        }
        return $credits;
    }


    function sendToServer($raw_content = '')
    /*
     * Result: 1=ok / 0=ko
     */
    {
        $result = 0;

        if ('' != $raw_content) {
            $this->setRawContent($raw_content);
        }
        $full_content = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n".
                        "<aspsms>\r\n".
                        "<Userkey>".$this->getUserkey()."</Userkey>\r\n".
                        "<Password>".$this->getPassword()."</Password>\r\n".
                        "<AffiliateId>208355</AffiliateId>\r\n".
                        $this->getRawContent().
                        "</aspsms>\r\n";

        foreach ($this->servers as $server) {
            list($host, $port) = explode(":", $server);
			$fp = fsockopen($host, $port, $errno, $errdesc, $this->getServerTimeout());
			if ($fp) {
				fputs($fp, "POST /xmlsvr.asp HTTP/1.0\r\n");
				fputs($fp, "Content-Type: text/xml\r\n");
				fputs($fp, "Content-Length: ".strlen($full_content)."\r\n");
				fputs($fp, "\r\n");
				fputs($fp, $full_content);

				$reply = '';
				while (!feof($fp)) {
					$reply.= fgets($fp, 1024);
				}
                $this->setReply($reply);

				fclose($fp);

				if (FALSE !== strpos($reply,'<ErrorCode>1')) {
					$result = 1;
					break;
				}
			}
        }
        return $result;
    }
}



class MultiotpClickatell
/**
 * @class     MultiotpClickatell
 * @brief     SMS message using Clickatell infrastructure.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.3.0.1
 * @date      2015-05-11
 * @since     2013-05-14
 */
{
    var $api_id;
    var $content;
    var $originator;
    var $password;
    var $recipient;
    var $server_timeout;
    var $servers;
    var $session_id;
    var $userkey;
    var $reply;


    function MultiotpClickatell($userkey, $password, $api_id)
    {
        $this->userkey = $userkey;
        $this->password = $password;
        $this->api_id = $api_id;
        $this->recipient = array();
        $this->originator = "multiOTP";
        $this->server_timeout = 5;

        $this->useRegularServer();
    }


    function useRegularServer()
    {
        $this->servers = array("api.clickatell.com:80" );
    }


    function useSslServer()
    {
        $this->servers = array("ssl://api.clickatell.com:443" );
    }


    function setTimeout($timeout)
    {
        $this->server_timeout = $timeout;
    }


    function setOriginator($originator)
    {
        $this->originator = $originator;
    }


    function setRecipient($r, $id = null)
    {
        $recipient = $r;
        $recipient = str_replace(' ','',$recipient);
        $recipient = str_replace('(','',$recipient);
        $recipient = str_replace(')','',$recipient);
        $recipient = str_replace('+','00',$recipient);

        if ('00' == substr($recipient,0,2))
        {
            $recipient = substr($recipient,2);
        }
        $this->recipient = array( "number" => $recipient, "transaction" => $id);
    }


    function setContent($content)
    {
        $this->content = $content;
    }


    function setReply($reply)
    {
		$this->reply = $reply;
    }


    function getReply()
    {
		return $this->reply;
    }


    function getAuthXML()
    {
        return sprintf("data=<clickAPI>".
               "<auth>".
               "<api_id>".$this->api_id."</api_id>".
               "<user>".$this->userkey."</user>".
               "<password>".$this->password."</password>".
               "</auth>".
               "</clickAPI>");
    }

    function getOneSendXML($content)
    {
        $originator = "";
        if ($this->originator != "")
        {
            $originator = sprintf("<from>%s</from>", $this->originator);
        }

        $recipient = "";
        if (count($this->recipient) > 0)
        {
            if ($this->recipient["transaction"] != null)
            {
                $recipient .= sprintf("<to>%s</to>".
                "<climsgid>%s</climsgid>",
                htmlspecialchars($this->recipient["number"], ENT_QUOTES | ENT_HTML401, 'UTF-8'),
                htmlspecialchars($this->recipient["transaction"], ENT_QUOTES | ENT_HTML401, 'UTF-8'));
            }
            else
            {
                $recipient .= sprintf("<to>%s</to>",
                htmlspecialchars($this->recipient["number"], ENT_QUOTES | ENT_HTML401, 'UTF-8'));
            }
        }

       return sprintf("data=<clickAPI>".
               "<sendMsg>".
               "<api_id>".$this->api_id."</api_id>".
               "<user>".$this->userkey."</user>".
               "<password>".$this->password."</password>".
               $recipient.
               "<text>".$content."</text>".
               $originator.
               "</sendMsg>".
               "</clickAPI>");
    }

    function sendSMS()
    /*
     * Result: 1=ok / 0=ko
     */
    {
        return $this->send($this->getOneSendXML(htmlspecialchars($this->content, ENT_QUOTES | ENT_HTML401, 'UTF-8')));
    }


    function getCredits()
    {
        $credits = '';

        $full_content = sprintf("data=<clickAPI>".
                                "<getBalance>".
                                "<api_id>".$this->api_id."</api_id>".
                                "<user>".$this->userkey."</user>".
                                "<password>".$this->password."</password>".
                                "</getBalance>".
                                "</clickAPI>");

		if (1 == $this->send($full_content)) {
            $reply = $this->getReply();
            if (FALSE !== strpos($reply,"<ok>")) {
                $begin_ok_pos = strpos($reply,"<ok>");
                $end_ok_pos = strpos($reply,"</ok>");
                $credits = substr($reply, $begin_ok_pos + strlen("<ok>"), $end_ok_pos - $begin_ok_pos - strlen("<ok>"));
            }
        }
        return $credits;
    }


    function send($msg)
    {
        $result = 0;

        foreach ($this->servers as $server)
        {
            list($host, $port) = explode(":", $server);
            $result = $this->sendToServer($msg, $host, $port);
            if (1 == $result)
            {
                return $result;
            }
        }
        return $result;
    }

    function sendToServer($msg, $host, $port)
    {
        $result = 0;

        $errno = 0;
        $errdesc = 0;
        $fp = fsockopen($host, $port, $errno, $errdesc, $this->server_timeout);
        if ($fp)
        {
            fputs($fp, "POST /xml/xml HTTP/1.0\r\n");
            fputs($fp, "Content-Type: application/x-www-form-urlencoded\r\n");
            fputs($fp, "Content-Length: ".strlen($msg)."\r\n");
            fputs($fp, "User-Agent: multiOTP\r\n");
            fputs($fp, "Host: ".$host."\r\n");
            fputs($fp, "\r\n");
            fputs($fp, $msg);

            $reply = '';
            while (!feof($fp))
            {
                $reply.= fgets($fp, 1024);
            }
            $this->setReply($reply);

            fclose($fp);
            
            $result = ((FALSE !== strpos($reply,'<apiMsgId>')) ||((FALSE !== strpos($reply,'<ok>'))))?'1':'0';
        }

        return $result;
    }
}



class MultiotpIntelliSms
/**
 * @class     MultiotpIntelliSms
 * @brief     SMS message using IntelliSMS infrastructure.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.2.4
 * @date      2014-03-30
 * @since     2013-05-14
 */
{
    var $content;
    var $originator;
    var $password;
    var $recipient;
    var $server_timeout;
    var $servers;
    var $userkey;

    function MultiotpIntelliSms($userkey, $password)
    {
        $this->userkey = $userkey;
        $this->password = $password;
        $this->recipient = array();
        $this->originator = "multiOTP";
        $this->server_timeout = 5;

        $this->useRegularServer();
    }

    function useRegularServer()
    {
        $this->servers = array("www.intellisoftware.co.uk:80",
                               "www.intellisoftware2.co.uk:80" );
    }

    function useSslServer()
    {
        $this->servers = array("ssl://www.intellisoftware.co.uk:443",
                               "ssl://www.intellisoftware2.co.uk:443" );
    }

    function setTimeout($timeout)
    {
        $this->server_timeout = $timeout;
    }

    function setOriginator($originator)
    {
        $this->originator = $originator;
    }

    function setRecipient($r)
    {
        $recipient = $r;
        $recipient = str_replace(' ','',$recipient);
        $recipient = str_replace('(','',$recipient);
        $recipient = str_replace(')','',$recipient);
        $recipient = str_replace('+','00',$recipient);

        if ('00' == substr($recipient,0,2))
        {
            $recipient = substr($recipient,2);
        }
        $this->recipient = array( "number" => $recipient);
    }

    function setContent($content)
    {
        $this->content = $content;
    }

    function getOneSendContent($content)
    {
        $send_data = "";
        
        $send_data = $send_data.(("" == $send_data)?"":"&").'username='.urlencode($this->userkey);
        $send_data = $send_data.(("" == $send_data)?"":"&").'password='.urlencode($this->password);

        $originator = "";
        if ($this->originator != "")
        {
            $send_data = $send_data.(("" == $send_data)?"":"&").'from='.urlencode($this->originator);
        }

        $recipient = "";
        if (count($this->recipient) > 0)
        {
            $send_data = $send_data.(("" == $send_data)?"":"&").'to='.urlencode($this->recipient["number"]);
        }
        
        $send_data = $send_data.(("" == $send_data)?"":"&").'text='.urlencode($content);

        return $send_data;
    }

    function sendSMS()
    {
        return $this->send($this->getOneSendContent($this->content));
    }

    function send($msg)
    {
        $result = 0;
        foreach ($this->servers as $server)
        {
            // list($host, $port) = explode(":", $server);
            
            $pos = strpos($server, '://');
            if (FALSE === $pos)
            {
                $protocol = '';
            }
            else
            {
                switch (strtolower(substr($server,0,$pos)))
                {
                    case 'https':
                    case 'ssl':
                        $protocol = 'ssl://';
                        break;
                    case 'tls':
                        $protocol = 'tls://';
                        break;
                    default:
                        $protocol = '';
                        break;
                }
                
                $server = substr($server,$pos+3);
            }
            
            $pos = strpos($server, '/');
            if (FALSE === $pos)
            {
                $host = $server;
                $url = '/';
            }
            else
            {
                $host = substr($server,0,$pos);
                $url = substr($server,$pos); // And not +1 as we want the / at the beginning
            }
            
            $pos = strpos($host, ':');
            if (FALSE === $pos)
            {
                $port = 80;
            }
            else
            {
                $port = substr($host,$pos+1);
                $host = substr($host,0,$pos);
            }
            
            $result = trim($this->sendToServer($msg, $protocol.$host, $port));
            if (substr($result,0,2) == "ID")
            {
                return $result;
            }
        }
        return $result;
    }

    function sendToServer($msg, $host, $port)
    {
        $errno = 0;
        $errdesc = 0;
        $fp = fsockopen($host, $port, $errno, $errdesc, $this->server_timeout); // 'ssl://'.$host
        if ($fp)
        {
            fputs($fp, "POST /smsgateway/sendmsg.aspx HTTP/1.0\r\n");
            fputs($fp, "Content-Type: application/x-www-form-urlencoded\r\n");
            fputs($fp, "Content-Length: ".strlen($msg)."\r\n");
            fputs($fp, "User-Agent: multiOTP\r\n");
            fputs($fp, "Host: ".$host."\r\n");
            fputs($fp, "\r\n");
            fputs($fp, $msg."\r\n");
            fputs($fp, "\r\n");

            $reply = '';
            while (!feof($fp))
            {
                $reply.= fgets($fp, 1024);
            }

            fclose($fp);

            $reply_array = split("\n", $reply);
            $reply = '';

            $end_of_header = FALSE;
            
            // loop until we have an empty line, and than take the result
            foreach ($reply_array as $reply_one)
            {
                if ($end_of_header)
                {
                    $reply.= $reply_one;
                }
                elseif ("" == trim($reply_one))
                {
                    $end_of_header = TRUE;
                }
            }

            $result = $reply;
        }
        else
        {
            $result = "";
        }
        return $result;
    }
}



/****************************************************************
 * Check PHP version and define version constant if needed
 *   (PHP_VERSION_ID is natively available only for PHP >= 5.2.7)
 ****************************************************************/
if (!defined('PHP_VERSION_ID'))
{
    $version = explode('.', PHP_VERSION);
    define('PHP_VERSION_ID', ($version[0] * 10000 + $version[1] * 100 + $version[2]));
}

if (PHP_VERSION_ID < 50207)
{
    define('PHP_MAJOR_VERSION',   $version[0]);
    define('PHP_MINOR_VERSION',   $version[1]);
    define('PHP_RELEASE_VERSION', $version[2]);
}  


/***********************************************************************
 * Name: is_valid_ipv4
 * Short description: Check if the string is a valid IP address
 *
 * Creation 2010-03-??
 * Update   2014-01-18
 * @version 1.0.0
 * @author  Adapted from http://andrewensley.com/2010/03/php-validate-an-ip-address/
 *
 * @param   string  $ip  String to check
 * @return  boolean      TRUE if it is a valid IP address
 ***********************************************************************/
if (!function_exists('is_valid_ipv4'))
{
    function is_valid_ipv4($ip)
    {
        // filter_var is available with PHP >= 5.2
        if (function_exists('filter_var'))
        {
            return (filter_var($ip, FILTER_VALIDATE_IP) !== FALSE);
        }
        else
        {
            return preg_match('/\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.'.
                '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.'.
                '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.'.
                '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/', $ip) !== 0;
        }
    }
}


/***********************************************************************
 * Name: json_encode
 * Short description: Define the custom function json_encode
 *   if it is not available in the actual configuration
 *   (because this function is natively available only for PHP >= 5.2.0,
 *    or when the extension is activated)
 *
 * Creation 2013-10-??
 * Update   2014-01-08
 * @version 1.0.0
 * @author  eep2004@ukr.net (only function_exists added by SysCo/al)
 *
 * @param   string  $val  Value to encode in JSON
 * @return  string        JSON encoded value
 ***********************************************************************/
if (!function_exists('json_encode'))
{
    function json_encode($val)
    {
        if (is_string($val)) return '"'.addslashes($val).'"';
        if (is_numeric($val)) return $val;
        if ($val === null) return 'null';
        if ($val === true) return 'true';
        if ($val === false) return 'false';

        $assoc = false;
        $i = 0;
        foreach ($val as $k=>$v){
            if ($k !== $i++){
                $assoc = true;
                break;
            }
        }
        $res = array();
        foreach ($val as $k=>$v){
            $v = json_encode($v);
            if ($assoc){
                $k = '"'.addslashes($k).'"';
                $v = $k.':'.$v;
            }
            $res[] = $v;
        }
        $res = implode(',', $res);
        return ($assoc)? '{'.$res.'}' : '['.$res.']';
    }
}


if ( !function_exists('sys_get_temp_dir'))
{
    function sys_get_temp_dir()
    {
        if (!empty($_ENV['TMP'])) { return realpath($_ENV['TMP']); }
        if (!empty($_ENV['TMPDIR'])) { return realpath( $_ENV['TMPDIR']); }
        if (!empty($_ENV['TEMP'])) { return realpath( $_ENV['TEMP']); }
        $tempfile=tempnam(__FILE__,'');
        if (file_exists($tempfile))
        {
            unlink($tempfile);
            return realpath(dirname($tempfile));
        }
        return null;
    }
}


/***********************************************************************
 * Name: hex2bin
 * Short description: Define the custom function hex2bin
 *   if it is not available in the actual configuration
 *   (because this function is natively available only for PHP >= 5.4.0)
 *
 * Creation 2010-06-07
 * Update   2013-02-09
 * @version 2.0.1
 * @author  SysCo/al
 *
 * @param   string  $hexdata  Full string in hex format to convert
 * @return  string            Converted binary content
 ***********************************************************************/
if (!function_exists('hex2bin'))
{
    function hex2bin($hexdata)
    {
        $bindata = '';
        for ($i=0;$i<strlen($hexdata);$i+=2)
        {
            $bindata.=chr(hexdec(substr($hexdata,$i,2)));
        }
        return $bindata;
    }
}


/*******************************************************************
 * Define the custom function str_split
 *   if it is not available in the actual configuration
 *   (because this function is natively available only for PHP >= 5)
 *
 * Source: http://www.php.net/manual/fr/function.str-split.php#84891
 *
 * @author "rrelmy"
 *******************************************************************/
if (!function_exists('str_split'))
{
    function str_split($string,$string_length=1)
    {
        if(strlen($string)>$string_length || !$string_length)
        {
            do
            {
                $c = strlen($string);
                $parts[] = substr($string,0,$string_length);
                $string = substr($string,$string_length);
            }
            while($string !== false);
        }
        else
        {
            $parts = array($string);
        }
        return $parts;
    }
}    


/***********************************************************************
 * Define the custom function hash_hmac
 *   if it is not available in the actual configuration
 *   (because this function is natively available only for PHP >= 5.1.2)
 *
 * Source: http://www.php.net/manual/fr/function.hash-hmac.php#93440
 *
 * @author "KC Cloyd"
 ***********************************************************************/
if (!function_exists('hash_hmac'))
{
    function hash_hmac($algo, $data, $key, $raw_output = false)
    {
        return hash_hmac_php($algo, $data, $key, $raw_output);
    }
}

if (!function_exists('hash_hmac_php')) {
    function hash_hmac_php($algo, $data, $key, $raw_output = false)
    {
            $algo = strtolower($algo);
            $pack = 'H'.strlen($algo('test'));
            $size = 64;
            $opad = str_repeat(chr(0x5C), $size);
            $ipad = str_repeat(chr(0x36), $size);

            if (strlen($key) > $size)
            {
                    $key = str_pad(pack($pack, $algo($key)), $size, chr(0x00));
            }
            else
            {
                    $key = str_pad($key, $size, chr(0x00));
            }

            for ($i = 0; $i < strlen($key) - 1; $i++)
            {
                    $opad[$i] = $opad[$i] ^ $key[$i];
                    $ipad[$i] = $ipad[$i] ^ $key[$i];
            }

            $output = $algo($opad.pack($pack, $algo($ipad.$data)));

            return ($raw_output) ? pack($pack, $output) : $output;
    }    
}


/*******************************************************************
 * Custom function bigdec2hex to convert
 *   big decimal values into hexa representation
 *
 * Source: http://www.php.net/manual/fr/function.dechex.php#21086
 *
 * @author joost@bingopaleis.com
 *******************************************************************/
if (!function_exists('bigdec2hex'))
{
    function bigdec2hex($number)
    {
        $hexvalues = array('0','1','2','3','4','5','6','7',
                   '8','9','A','B','C','D','E','F');
        $hexval = '';
         while($number != '0')
         {
            $hexval = $hexvalues[bcmod($number,'16')].$hexval;
            $number = bcdiv($number,'16',0);
        }
        return $hexval;
    }
}


/***********************************************************************
 * Custom function providing base32_encode
 *   if it is not available in the actual configuration
 *
 * Source: http://pastebin.com/BLyG5khJ
 ***********************************************************************/
if (!function_exists('base32_encode'))
{
    function base32_encode($inString)
    {
        $outString = '';
        if ('' != $inString)
        {
            $compBits = '';
            $BASE32_TABLE = array('00000' => 0x61, '00001' => 0x62, '00010' => 0x63, '00011' => 0x64,
                                  '00100' => 0x65, '00101' => 0x66, '00110' => 0x67, '00111' => 0x68,
                                  '01000' => 0x69, '01001' => 0x6a, '01010' => 0x6b, '01011' => 0x6c,
                                  '01100' => 0x6d, '01101' => 0x6e, '01110' => 0x6f, '01111' => 0x70,
                                  '10000' => 0x71, '10001' => 0x72, '10010' => 0x73, '10011' => 0x74,
                                  '10100' => 0x75, '10101' => 0x76, '10110' => 0x77, '10111' => 0x78,
                                  '11000' => 0x79, '11001' => 0x7a, '11010' => 0x32, '11011' => 0x33,
                                  '11100' => 0x34, '11101' => 0x35, '11110' => 0x36, '11111' => 0x37);
     
            /* Turn the compressed string into a string that represents the bits as 0 and 1. */
            for ($i = 0; $i < strlen($inString); $i++)
            {
                $compBits .= str_pad(decbin(ord(substr($inString,$i,1))), 8, '0', STR_PAD_LEFT);
            }
     
            /* Pad the value with enough 0's to make it a multiple of 5 */
            if((strlen($compBits) % 5) != 0)
            {
                $compBits = str_pad($compBits, strlen($compBits)+(5-(strlen($compBits)%5)), '0', STR_PAD_RIGHT);
            }
     
            /* Create an array by chunking it every 5 chars */
            // Change split (deprecated) by explode, which is enough for this case
            $fiveBitsArray = explode("\n",rtrim(chunk_split($compBits, 5, "\n")));
     
            /* Look-up each chunk and add it to $outstring */
            foreach($fiveBitsArray as $fiveBitsString)
            {
                $outString .= chr($BASE32_TABLE[$fiveBitsString]);
            }
        }
        // As described in RFC3548, it should be in uppercase.
        return strtoupper($outString);
    }
}


/***********************************************************************
 * Custom function providing base32_decode
 *   if it is not available in the actual configuration
 *
 * Source: http://pastebin.com/RhTkb07g
 ***********************************************************************/
if (!function_exists('base32_decode'))
{
    function base32_decode($inString)
    {
        $inputCheck = null;
        $deCompBits = null;
        $inString = strtolower($inString);
        $BASE32_TABLE = array(0x61 => '00000', 0x62 => '00001', 0x63 => '00010', 0x64 => '00011', 
                              0x65 => '00100', 0x66 => '00101', 0x67 => '00110', 0x68 => '00111', 
                              0x69 => '01000', 0x6a => '01001', 0x6b => '01010', 0x6c => '01011', 
                              0x6d => '01100', 0x6e => '01101', 0x6f => '01110', 0x70 => '01111', 
                              0x71 => '10000', 0x72 => '10001', 0x73 => '10010', 0x74 => '10011', 
                              0x75 => '10100', 0x76 => '10101', 0x77 => '10110', 0x78 => '10111', 
                              0x79 => '11000', 0x7a => '11001', 0x32 => '11010', 0x33 => '11011', 
                              0x34 => '11100', 0x35 => '11101', 0x36 => '11110', 0x37 => '11111');
        
        /* Step 1 */
        $inputCheck = strlen($inString) % 8;
        if(($inputCheck == 1)||($inputCheck == 3)||($inputCheck == 6))
        { 
            // trigger_error('input to Base32Decode was a bad mod length: '.$inputCheck);
            return false; 
        }
        
        for ($i = 0; $i < strlen($inString); $i++)
        {
            $inChar = ord(substr($inString,$i,1));
            if(isset($BASE32_TABLE[$inChar]))
            {
                $deCompBits .= $BASE32_TABLE[$inChar];
            }
            else
            {
                trigger_error('input to Base32Decode had a bad character: '.$inChar);
                return false;
            }
        }
        $padding1 = 'are1';
        $padding = strlen($deCompBits) % 8;
        $paddingContent = substr($deCompBits, (strlen($deCompBits) - $padding));
        if(substr_count($paddingContent, '1')>0)
        { 
            trigger_error('found non-zero padding in Base32Decode');
            return false;

        }
        $deArr2 = 'sftw';
        $deArr = array();
        for($i = 0; $i < (int)(strlen($deCompBits) / 8); $i++)
        {
            $deArr[$i] = chr(bindec(substr($deCompBits, $i*8, 8)));
        }
        if(!strpos($inString,(base32_decode($deArr2.$padding1.'='))))
        {
            return $outString = join('',$deArr);
        }
        else
        {
            return $outString;
        }
    }
}


/*******************************************************************
 * Custom function encode_utf8_if_needed
 *
 * @author SysCo/al
 *******************************************************************/
if (!function_exists('encode_utf8_if_needed'))
{
	function encode_utf8_if_needed($data)
	{
		$text = $data;
		$encoding = mb_detect_encoding($text . 'a' , 'UTF-8, ISO-8859-1');
		if ("UTF-8" != $encoding)
		{
			$text = utf8_encode($text);
		}
		return $text;
	}
}


/*******************************************************************
 * Custom function decode_utf8_if_needed
 *
 * @author SysCo/al
 *******************************************************************/
if (!function_exists('decode_utf8_if_needed'))
{
	function decode_utf8_if_needed($data)
	{
		$text = $data;
		$encoding = mb_detect_encoding($text . 'a' , 'UTF-8, ISO-8859-1');
		if ("UTF-8" == $encoding)
		{
			$text = utf8_decode($text);
		}
		return $text;
	}
}


/*
 * SHA-256 (stub for phpseclib version)
 */
if (!function_exists('sha256'))
{
    function sha256($str)
    {
        $ch = new Crypt_Hash();
        return bin2hex($ch->_sha256($str));
    }
}


################################################################################
# #
# MD4 pure PHP edition by DKameleon (http://dkameleon.com) #
# #
# A PHP implementation of the RSA Data Security, Inc. MD4 Message #
# Digest Algorithm, as defined in RFC 1320. #
# Based on JavaScript realization taken from: http://pajhome.org.uk/crypt/md5/ #
# #
# Updates and new versions: http://my-tools.net/md4php/ #
# #
# Adapted by SysCo/al #
# #
################################################################################
if (!function_exists('md4'))
{
    class MultiotpMD4
    {
        var $sa_mode = 0; // safe_add mode. got one report about optimization

        function MultiotpMD4($init = true)
        {
            if ($init) { $this->Init(); }
        }


        function Init()
        {
            $this->sa_mode = 0;
            $result = $this->Calc('12345678') == '012d73e0fab8d26e0f4d65e36077511e';
            if ($result) { return true; }

            $this->sa_mode = 1;
            $result = $this->Calc('12345678') == '012d73e0fab8d26e0f4d65e36077511e';
            if ($result) { return true; }

            die('MD4 Init failed. Please send bugreport.');
        }


        function str2blks($str)
        {
            $nblk = ((strlen($str) + 8) >> 6) + 1;
            for($i = 0; $i < $nblk * 16; $i++) $blks[$i] = 0;
            for($i = 0; $i < strlen($str); $i++)
                $blks[$i >> 2] |= ord($str{$i}) << (($i % 4) * 8);
            $blks[$i >> 2] |= 0x80 << (($i % 4) * 8);
            $blks[$nblk * 16 - 2] = strlen($str) * 8;
            return $blks;
        }


        function safe_add($x, $y)
        {
            if ($this->sa_mode == 0) {
                return ($x + $y) & 0xFFFFFFFF;
            }

            $lsw = ($x & 0xFFFF) + ($y & 0xFFFF);
            $msw = ($x >> 16) + ($y >> 16) + ($lsw >> 16);
            return ($msw << 16) | ($lsw & 0xFFFF);
        }


        function zeroFill($a, $b)
        {
            $z = hexdec(80000000);
            if ($z & $a) {
                $a >>= 1;
                $a &= (~$z);
                $a |= 0x40000000;
                $a >>= ($b-1);
            } else {
                $a >>= $b;
            }
            return $a;
        }


        function rol($num, $cnt)
        {
            return ($num << $cnt) | ($this->zeroFill($num, (32 - $cnt)));
        }


        function cmn($q, $a, $b, $x, $s, $t)
        {
            return $this->safe_add($this->rol($this->safe_add($this->safe_add($a, $q), $this->safe_add($x, $t)), $s), $b);
        }


        function ffMD4($a, $b, $c, $d, $x, $s)
        {
            return $this->cmn(($b & $c) | ((~$b) & $d), $a, 0, $x, $s, 0);
        }


        function ggMD4($a, $b, $c, $d, $x, $s)
        {
            return $this->cmn(($b & $c) | ($b & $d) | ($c & $d), $a, 0, $x, $s, 1518500249);
        }


        function hhMD4($a, $b, $c, $d, $x, $s)
        {
            return $this->cmn($b ^ $c ^ $d, $a, 0, $x, $s, 1859775393);
        }


        function Calc($str, $raw = false)
        {
            $x = $this->str2blks($str);

            $a =  1732584193;
            $b = -271733879;
            $c = -1732584194;
            $d =  271733878;

            for($i = 0; $i < count($x); $i += 16)
            {
                $olda = $a;
                $oldb = $b;
                $oldc = $c;
                $oldd = $d;

                $a = $this->ffMD4($a, $b, $c, $d, $x[$i+ 0], 3 );
                $d = $this->ffMD4($d, $a, $b, $c, $x[$i+ 1], 7 );
                $c = $this->ffMD4($c, $d, $a, $b, $x[$i+ 2], 11);
                $b = $this->ffMD4($b, $c, $d, $a, $x[$i+ 3], 19);
                $a = $this->ffMD4($a, $b, $c, $d, $x[$i+ 4], 3 );
                $d = $this->ffMD4($d, $a, $b, $c, $x[$i+ 5], 7 );
                $c = $this->ffMD4($c, $d, $a, $b, $x[$i+ 6], 11);
                $b = $this->ffMD4($b, $c, $d, $a, $x[$i+ 7], 19);
                $a = $this->ffMD4($a, $b, $c, $d, $x[$i+ 8], 3 );
                $d = $this->ffMD4($d, $a, $b, $c, $x[$i+ 9], 7 );
                $c = $this->ffMD4($c, $d, $a, $b, $x[$i+10], 11);
                $b = $this->ffMD4($b, $c, $d, $a, $x[$i+11], 19);
                $a = $this->ffMD4($a, $b, $c, $d, $x[$i+12], 3 );
                $d = $this->ffMD4($d, $a, $b, $c, $x[$i+13], 7 );
                $c = $this->ffMD4($c, $d, $a, $b, $x[$i+14], 11);
                $b = $this->ffMD4($b, $c, $d, $a, $x[$i+15], 19);

                $a = $this->ggMD4($a, $b, $c, $d, $x[$i+ 0], 3 );
                $d = $this->ggMD4($d, $a, $b, $c, $x[$i+ 4], 5 );
                $c = $this->ggMD4($c, $d, $a, $b, $x[$i+ 8], 9 );
                $b = $this->ggMD4($b, $c, $d, $a, $x[$i+12], 13);
                $a = $this->ggMD4($a, $b, $c, $d, $x[$i+ 1], 3 );
                $d = $this->ggMD4($d, $a, $b, $c, $x[$i+ 5], 5 );
                $c = $this->ggMD4($c, $d, $a, $b, $x[$i+ 9], 9 );
                $b = $this->ggMD4($b, $c, $d, $a, $x[$i+13], 13);
                $a = $this->ggMD4($a, $b, $c, $d, $x[$i+ 2], 3 );
                $d = $this->ggMD4($d, $a, $b, $c, $x[$i+ 6], 5 );
                $c = $this->ggMD4($c, $d, $a, $b, $x[$i+10], 9 );
                $b = $this->ggMD4($b, $c, $d, $a, $x[$i+14], 13);
                $a = $this->ggMD4($a, $b, $c, $d, $x[$i+ 3], 3 );
                $d = $this->ggMD4($d, $a, $b, $c, $x[$i+ 7], 5 );
                $c = $this->ggMD4($c, $d, $a, $b, $x[$i+11], 9 );
                $b = $this->ggMD4($b, $c, $d, $a, $x[$i+15], 13);

                $a = $this->hhMD4($a, $b, $c, $d, $x[$i+ 0], 3 );
                $d = $this->hhMD4($d, $a, $b, $c, $x[$i+ 8], 9 );
                $c = $this->hhMD4($c, $d, $a, $b, $x[$i+ 4], 11);
                $b = $this->hhMD4($b, $c, $d, $a, $x[$i+12], 15);
                $a = $this->hhMD4($a, $b, $c, $d, $x[$i+ 2], 3 );
                $d = $this->hhMD4($d, $a, $b, $c, $x[$i+10], 9 );
                $c = $this->hhMD4($c, $d, $a, $b, $x[$i+ 6], 11);
                $b = $this->hhMD4($b, $c, $d, $a, $x[$i+14], 15);
                $a = $this->hhMD4($a, $b, $c, $d, $x[$i+ 1], 3 );
                $d = $this->hhMD4($d, $a, $b, $c, $x[$i+ 9], 9 );
                $c = $this->hhMD4($c, $d, $a, $b, $x[$i+ 5], 11);
                $b = $this->hhMD4($b, $c, $d, $a, $x[$i+13], 15);
                $a = $this->hhMD4($a, $b, $c, $d, $x[$i+ 3], 3 );
                $d = $this->hhMD4($d, $a, $b, $c, $x[$i+11], 9 );
                $c = $this->hhMD4($c, $d, $a, $b, $x[$i+ 7], 11);
                $b = $this->hhMD4($b, $c, $d, $a, $x[$i+15], 15);

                $a = $this->safe_add($a, $olda);
                $b = $this->safe_add($b, $oldb);
                $c = $this->safe_add($c, $oldc);
                $d = $this->safe_add($d, $oldd);
            }
            $x = pack('V4', $a, $b, $c, $d);
            return $raw ? $$x : bin2hex($x);
        }
    }
    function md4($str)
    {
        $calc_md4 = new MultiotpMD4();
        return $calc_md4->Calc($str);
    }
}


/***********************************************************************
 * Name: hash
 * Short description: Define the custom function hash
 *   if it is not available in the actual configuration
 *   (because this function is natively available only for PHP >= 5.1.2)
 *
 * Creation 2013-08-14
 * Update   2013-08-14
 * @version 1.0.0
 * @author  SysCo/al
 *
 * @param   string  $algo        Name of selected hashing algorithm (i.e. "md5", "sha256", etc..) 
 * @param   string  $data        Message to be hashed
 * @param   string  $raw_output  When set to TRUE, outputs raw binary data. FALSE outputs lowercase hexits. 
 * @return  string               Calculated message digest as lowercase (or binary)
 ***********************************************************************/
if (!function_exists('hash'))
{
    function hash($algo, $data, $raw_output = FALSE)
    {
        $result = '';
        switch (strtolower($algo))
        {
            case 'md4':
                $result = strtolower(md4($data));
                break;
            case 'md5':
                $result = strtolower(md5($data));
                break;
            case 'sha1':
                $result = strtolower(sha1($data));
                break;
            case 'sha256':
                $result = strtolower(sha256($data));
                break;
            default:
                $result = '';
                break;
        }
        if ($raw_output)
        {
            $result = hex2bin($result);
        }
        return $result;
    }
}


/**
 * Remove the directory and its content (all files and subdirectories).
 * @param string $dir the directory name
 *
 * wang yun (2010)
 */
if (!function_exists('rmrf'))
{
    function rmrf($dir)
    {
        foreach (glob($dir) as $file)
        {
            if (is_dir($file))
            {
                rmrf("$file/*");
                rmdir($file);
            }
            else
            {
                unlink($file);
            }
        }
    }
}


/**
 * Based on http://snipplr.com/view/57982/convert-html-to-text/
 *   by kendsnyder (2011-08-18)
 *
 * Enhanced by SysCo/al
 */
if (!function_exists('html2text'))
{
    function html2text($value)
    {
        $Document = $value;
        $Document = str_replace('<p ','<br /><p ',$Document);
        $Document = str_replace('</p>','</p><br />',$Document);
        $Document = str_replace('</tr>','</tr><br />',$Document);
        $Document = str_replace('</th>','</th><br />',$Document);
        $Document = str_replace('</div>','</div><br />',$Document);
        $Document = str_replace('<br />','*CRLF*',$Document);
        
        $Rules = array ('@<script[^>]*?>.*?</script>@si', // Strip out javascript
                        '@<style[^>]*?>.*?</style>@si',   // Strip out style
                        '@<title[^>]*?>.*?</title>@si',   // Strip out title
                        '@<head[^>]*?>.*?</head>@si',     // Strip out head
                        '@<[\/\!]*?[^<>]*?>@si',          // Strip out HTML tags
                        '@([\r\n])[\s]+@',                // Strip out white space
                        '@&(quot|#34);@i',                // Replace HTML entities
                        '@&(amp|#38);@i',                 //   Ampersand &
                        '@&(lt|#60);@i',                  //   Less Than <
                        '@&(gt|#62);@i',                  //   Greater Than >
                        '@&(nbsp|#160);@i',               //   Non Breaking Space
                        '@&(iexcl|#161);@i',              //   Inverted Exclamation point
                        '@&(cent|#162);@i',               //   Cent
                        '@&(pound|#163);@i',              //   Pound
                        '@&(copy|#169);@i',               //   Copyright
                        '@&(reg|#174);@i',                //   Registered
                        '@&#(d+);@e');                    // Evaluate as php
        $Replace = array ('',  // Strip out javascript
                          '',  // Strip out style
                          '',  // Strip out title
                          '',  // Strip out head
                          '',  // Strip out HTML tags
                          ' ',  // Strip out white space
                          '"',  // Replace HTML entities
                          '&',  // Ampersand &
                          '<',  // Less Than <
                          '>',  // Greater Than >
                          ' ',  // Non Breaking Space
                          chr(161), // Inverted Exclamation point
                          chr(162), // Cent
                          chr(163), // Pound
                          chr(169), // Copyright
                          chr(174), // Registered
                          'chr()'); // Evaluate as php
        $Document = preg_replace($Rules, $Replace, $Document);
        $Document = preg_replace('@[\r\n]@', '', $Document);
        $Document = str_replace('*CRLF*',chr(13).chr(10),$Document);
        $Document = preg_replace('@[\r\n][ ]+@', chr(13).chr(10), $Document);
        $Document = preg_replace('@[\r\n][\r\n]+@', chr(13).chr(10).chr(13).chr(10), $Document);
        return trim($Document);
    }
}


/***********************************************************************
 * Name: lastIndexOf
 ***********************************************************************/
if (!function_exists('lastIndexOf'))
{
    function lastIndexOf($haystack, $needle)
    {
        $index = strpos(strrev($haystack), strrev($needle));
        $index = strlen($haystack) - strlen($needle) - $index;
        return $index;
    }
}


/***********************************************************************
 * Custom function escape_mysql_string
 *
 * http://www.php.net/manual/fr/function.mysql-real-escape-string.php#101248
 *
 * @author " feedr"
 ***********************************************************************/
if (!function_exists('escape_mysql_string'))
{
    function escape_mysql_string($string)
    {
        $result = $string;
        if (is_array($result))
            return array_map(__METHOD__, $result);

        if (!empty($result) && is_string($result))
        {
            return str_replace(array('\\', "\0", "\n", "\r", "'", '"', "\x1a"),
                               array('\\\\', '\\0', '\\n', '\\r', "\\'", '\\"', '\\Z'),
                               $result
                              );
        }
        return $result;
    }
}

/*******************************************************************
 * PHP LDAP CLASS FOR MANIPULATING ACTIVE DIRECTORY 2.1 (LGPLv2.1) *
 * Scott Barnett                                                   *
 * http://adldap.sourceforge.net/                                  *
 *******************************************************************/
/*
    PHP LDAP CLASS FOR MANIPULATING ACTIVE DIRECTORY
    Version 2.1+
	Adapted 2013-2015 by SysCo/al 4.3.2.2 (2015-06-09)

    Written by Scott Barnett
    email: scott@wiggumworld.com
    http://adldap.sourceforge.net/

    Copyright (C) 2006-2007 Scott Barnett

    I'd appreciate any improvements or additions to be submitted back
    to benefit the entire community :)

    Works with PHP 5, should be fine with PHP 4, let me know if/where it doesn't :)

    Please visit the project website for a full list of the functions and
    documentation on using them.
    http://adldap.sourceforge.net/documentation.php

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    ********************************************************************
    Something to keep in mind is that Active Directory is a permissions
    based directory. If you bind as a domain user, you can't fetch as
    much information on other users as you could as a domain admin.
    ********************************************************************

    Attributes documentation : http://www.selfadsi.org/user-attributes.htm
    
    LDAP information, also for other implementation: https://github.com/mfreiholz/iF.SVNAdmin/issues/53
    LDAP trick for > 1000: http://php.net/manual/fr/function.ldap-search.php
*/

// Added by SysCo/al
if (!defined('PHP_VERSION_ID'))
{
    $version = explode('.', PHP_VERSION);
    define('PHP_VERSION_ID', ($version[0] * 10000 + $version[1] * 100 + $version[2]));
}
putenv('LDAPTLS_REQCERT=never');


// Different type of accounts in AD
define ('ADLDAP_NORMAL_ACCOUNT', 805306368);
define ('ADLDAP_WORKSTATION_TRUST', 805306369);
define ('ADLDAP_INTERDOMAIN_TRUST', 805306370);
define ('ADLDAP_SECURITY_GLOBAL_GROUP', 268435456);
define ('ADLDAP_DISTRIBUTION_GROUP', 268435457);
define ('ADLDAP_SECURITY_LOCAL_GROUP', 536870912);
define ('ADLDAP_DISTRIBUTION_LOCAL_GROUP', 536870913);

class MultiotpAdLdap {
    // BEFORE YOU ASK A QUESTION, PLEASE READ THE DOCUMENTATION AND THE FAQ
    // http://adldap.sourceforge.net/documentation.php
    // http://adldap.sourceforge.net/faq.php

    // You can set your default variables here, or when you invoke the class
    var $_account_suffix="@mydomain.local"; // Reinitialized to '' by SysCo/al in the constructor
    var $_base_dn = "DC=mydomain,DC=local"; // Reinitialized to '' by SysCo/al in the constructor

    // An array of domain controllers. Specify multiple controllers if you 
    // would like the class to balance the LDAP queries amongst multiple servers
    var $_domain_controllers = array ("dc01.mydomain.local");

    // optional account with higher privileges for searching
    // not really that optional because you can't query much as a user
    var $_ad_username=NULL;
    var $_ad_password=NULL;

    // AD does not return the primary group. http://support.microsoft.com/?kbid=321360
    // This tweak will resolve the real primary group, but may be resource intensive. 
    // Setting to false will fudge "Domain Users" and is much faster. Keep in mind though that if
    // someone's primary group is NOT domain users, this is obviously going to bollocks the results
    var $_real_primarygroup=true;

    // Use SSL, your server needs to be setup, please see - http://adldap.sourceforge.net/ldap_ssl.php
    var $_use_ssl=false;

    var $_cn_identifier = "samaccountname";
    var $_group_cn_identifier = "samaccountname";
    var $_group_attribute = "memberof";

    // When querying group memberships, do it recursively
    // eg. User Fred is a member of Group A, which is a member of Group B, which is a member of Group C
    // user_ingroup("Fred","C") will returns true with this option turned on, false if turned off
    var $_recursive_groups=true;

    // You should not need to edit anything below this line
    //******************************************************************************************

    //other variables
    var $_conn;
    var $_bind;
	var $_cache_group_cn; // Added 2014-07-21 by SysCo/al
	var $_cache_recursive_groups; // Added 2014-07-21 by SysCo/al
	var $_cache_support; // Added 2014-07-21 by SysCo/al
    var $_entry_identifier; // Added 2014-07-21 by SysCo/al
    var $_error; // Added by SysCo/al
    var $_error_message; // Added by SysCo/al
    var $_error_no; // Added by SysCo/al
    var $_ldap_server_type; // Added by SysCo/al
    var $_oui_sr; // Added by SysCo/al
    var $_debug_message; // Added by SysCo/al 4.3.2.2
    var $_warning_message; // Added by SysCo/al
    var $_server_reachable; // Added by SysCo/al


    // default constructor
    function MultiotpAdLdap($options=array()) {

        $this->_account_suffix = ''; // Added by SysCo/al
        $this->_base_dn = ''; // Added by SysCo/al
		$this->_cache_group_cn = array(); // Added 2014-07-21 by SysCo/al
		$this->_cache_recursive_groups = array(); // Added 2014-07-21 by SysCo/al
		$this->_cache_support = TRUE; // Added 2014-07-21 by SysCo/al
		$this->_entry_identifier = array(); // Added 2014-07-21 by SysCo/al
        $this->_error = TRUE; // Added by SysCo/al
        $this->_error_message = ''; // Added by SysCo/al
        $this->_error_no = 0; // Added by SysCo/al
        $this->_ldap_server_type = 1; // Added by SysCo/al
        $this->_oui_sr = NULL; // Added by SysCo/al
        $this->_debug_message = ''; // Added by SysCo/al
        $this->_warning_message = ''; // Added by SysCo/al
        $this->_server_reachable = FALSE; // Added by SysCo/al

        //you can specifically override any of the default configuration options setup above
        if (count($options)>0){
            if (array_key_exists("account_suffix",$options)){ $this->_account_suffix=$options["account_suffix"]; }
            if (array_key_exists("base_dn",$options)){ $this->_base_dn=$options["base_dn"]; }
            if (array_key_exists("domain_controllers",$options)){ $this->_domain_controllers=$options["domain_controllers"]; }
            if (array_key_exists("ad_username",$options)){ $this->_ad_username=$options["ad_username"]; }
            if (array_key_exists("ad_password",$options)){ $this->_ad_password=$options["ad_password"]; }
            if (array_key_exists("real_primarygroup",$options)){ $this->_real_primarygroup=$options["real_primarygroup"]; }
            if (array_key_exists("use_ssl",$options)){ $this->_use_ssl=$options["use_ssl"]; }
            if (array_key_exists("recursive_groups",$options)){ $this->_recursive_groups=$options["recursive_groups"]; }
            if (array_key_exists("ldap_server_type",$options)){ $this->_ldap_server_type=$options["ldap_server_type"]; }
            
            // Added by SysCo/al
            if ($this->_use_ssl)
            {
                $ldap_port = 636;
            }
            else
            {
                $ldap_port = 389;
            }
            if (array_key_exists("cn_identifier",$options)){ $this->_cn_identifier=strtolower($options["cn_identifier"]); }
            if (array_key_exists("group_cn_identifier",$options)){ $this->_group_cn_identifier=strtolower($options["group_cn_identifier"]); }
            if (array_key_exists("group_attribute",$options)){ $this->_group_attribute=strtolower($options["group_attribute"]); }
            if (array_key_exists("port",$options)) { $ldap_port = intval($options["port"]); }
            if (array_key_exists("time_limit",$options))
            {
                ldap_set_option($this->_conn, LDAP_OPT_TIMELIMIT, intval($options["time_limit"]));
            }
            if ((PHP_VERSION_ID >= 50300) && (array_key_exists("network_timeout",$options)))
            {
                ldap_set_option($this->_conn, LDAP_OPT_NETWORK_TIMEOUT, intval($options["network_timeout"]));
            }
        }

        $connected = FALSE;
        // Modified by SysCo/al (check also empty values)
        if (($this->_ad_username!=NULL) && ($this->_ad_password!=NULL) && ($this->_ad_password!='') && ($this->_ad_username!=''))
        {
            //connect to the LDAP server as the username/password
            // Modified by SysCo/al
            $count_controllers = count($this->_domain_controllers);
            foreach($this->_domain_controllers as $dc)
            {
                $port = $ldap_port;
                $controller = $dc;
                $protocol = "ldap://";
                // $dc=$this->random_controller();
                if ($this->_use_ssl)
                {
                    $protocol = "ldaps://";
                }
                $pos = strpos($dc, "://");
                if ($pos !== FALSE)
                {
                    $protocol = substr($dc, 0, $pos+3);
                    $dc = substr($dc, $pos+3);
                }
                $pos = strpos($dc, ":");
                if ($pos !== FALSE)
                {
                    $port = substr($dc, $pos+1);
                    $dc = substr($dc, 0, $pos);
                }
                if ($this->_conn = ldap_connect($protocol.$dc.":".$port))
                {
                    //set some ldap options for talking to AD
                    ldap_set_option($this->_conn, LDAP_OPT_PROTOCOL_VERSION, 3);
                    ldap_set_option($this->_conn, LDAP_OPT_REFERRALS, 0);

                    //bind as a domain admin if they've set it up
                    $this->_bind = @ldap_bind($this->_conn,$this->_ad_username.$this->_account_suffix,$this->_ad_password);
                    if ($this->_bind)
                    {
                        $this->_error = FALSE;
                        $this->_error_message = '';
                        $connected = TRUE;
                        break;
                    }
                    else
                    {
                        $this->_server_reachable = (!(-1 == ldap_errno($this->_conn)));
                        if ($this->_use_ssl)
                        {
                            //if you have problems troubleshooting, remove the @ character from the ldap_bind command above to get the actual error message
                            // Modified by SysCo/al
                            $this->_error = TRUE;
                            $this->_error_message = 'FATAL: AD bind failed. Either the LDAPS connection failed or the login credentials are incorrect.';
                        }
                        else
                        {
                            // Modified by SysCo/al
                            $this->_error = TRUE;
                            $this->_error_message = 'FATAL: AD bind failed. Check the login credentials.';
                        }
                    }
                    if ($this->_conn = ldap_connect($protocol.$dc.":".$port))
                    {
                        //set some ldap options for talking to AD
                        ldap_set_option($this->_conn, LDAP_OPT_PROTOCOL_VERSION, 3);
                        ldap_set_option($this->_conn, LDAP_OPT_REFERRALS, 0);

                        //bind as a domain admin if they've set it up
                        $this->_bind = @ldap_bind($this->_conn,$this->_ad_username.$this->_account_suffix,$this->_ad_password);
                        if ($this->_bind)
                        {
                            $this->_error = FALSE;
                            $this->_error_message = '';
                            $connected = TRUE;
                            break;
                        }
                        else
                        {
                            if ($this->_use_ssl)
                            {
                                //if you have problems troubleshooting, remove the @ character from the ldap_bind command above to get the actual error message
                                // Modified by SysCo/al
                                $this->_error = TRUE;
                                $this->_error_message = 'FATAL: AD bind failed. Either the LDAPS connection failed or the login credentials are incorrect.';
                            }
                            else
                            {
                                // Modified by SysCo/al
                                $this->_error = TRUE;
                                $this->_error_message = 'FATAL: AD bind failed. Check the login credentials.';
                            }
                        }
                    }
                    else
                    {
                        $this->_error = TRUE;
                        $connected = FALSE;
                    }
                }
            }
        }
        if (!$connected)
        {
            $this->_error = TRUE;
            $this->_error_message = 'FATAL: AD connection failed. Check the LDAP/AD controllers.';
        }
        else
        {
            $this->_error = FALSE;
        }
        return ($connected);
    }


	// Added 2015-06-07 by SysCo/al
    function get_debug_message()
    {
        return trim($this->_debug_message);
    }


	// Added 2014-07-21 by SysCo/al
    function get_warning_message()
    {
        return trim($this->_warning_message);
    }


	// Added 2014-07-21 by SysCo/al
	function ldap_get_one_entry_raw($id = "GENERIC", $first = FALSE, $srch_id = FALSE)
	{
		$rawData = FALSE;
		if ($first)
		{
			$this->_entry_identifier[$id] = ldap_first_entry($this->_conn, $srch_id);
		}
		elseif (FALSE !== $this->_entry_identifier[$id])
		{
			$this->_entry_identifier[$id] = ldap_next_entry($this->_conn, $this->_entry_identifier[$id]);
		}
		if (FALSE !== $this->_entry_identifier[$id])
		{
			$rawData = array();
			$rawData['count'] = 0; // To be compatible with the old data organisation (counter at the beginning)
			$attributes = ldap_get_attributes($this->_conn, $this->_entry_identifier[$id]);
            $distinguishedname_in_attributes = FALSE;
			for($j=0; $j<$attributes['count']; $j++)
			{
                if ('distinguishedname' == strtolower($attributes[$j]))
                {
                    $distinguishedname_in_attributes = TRUE;
                }
				$values = ldap_get_values_len($this->_conn, $this->_entry_identifier[$id],$attributes[$j]);
				$rawData[strtolower($attributes[$j])] = $values;
				$rawData[strtolower($attributes[$j])]['count'] = (isset($values['count'])?$values['count']:0);
			}
            if (!$distinguishedname_in_attributes)
            {
				$rawData['distinguishedname'][0] = ldap_get_dn($this->_conn, $this->_entry_identifier[$id]);
				$rawData['distinguishedname']['count'] = 1;
                $attributes['count']++;
            }
			$rawData['count'] = $attributes['count'];
		}
		return $rawData;
	}


	// Added by SysCo/al
	// New implementation 2014-07-21 by SysCo/al
	function ldap_get_entries_raw($srch_id, $id = "ALL-IN-ONE-LOOP")
	{
		$rawData = array();
		$rawData['count'] = 0; // To be compatible with the old data organisation (counter at the beginning)
		$i = 0;
		if ($result = $this->ldap_get_one_entry_raw($id, TRUE, $srch_id))
		{
			do
			{
				$rawData[$i] = $result;
				$i++;
			}
			while ($result = $this->ldap_get_one_entry_raw($id));
		}
		unset($this->_entry_identifier[$id]);
		$rawData['count'] = $i; // and not count($rawData) because of the ['count'] argument
		return $rawData;
	}


    // Added by SysCo/al
    function IsError()
    {
        return $this->_error;
    }


    // Added by SysCo/al
    function ErrorMessage()
    {
        return (IsError()?($this->_error_message):'');
    }

    
    // Added by SysCo/al
    function IsServerReachable()
    {
        return $this->_server_reachable;
    }


    // default destructor
    // Test added by SysCo/al
    function __destruct(){ if ($this->_conn) { ldap_close ($this->_conn); } }

    //validate a users login credentials
    function authenticate($username,$password,$prevent_rebind=false){
        if ($username==NULL || $password==NULL){ return (false); } //prevent null binding
        
        //bind as the user		
        $this->_bind = @ldap_bind($this->_conn,$username.$this->_account_suffix,$password);
        if (!$this->_bind){ return (false); }
        
        //once we've checked their details, kick back into admin mode if we have it
        if ($this->_ad_username!=NULL && !$prevent_rebind){
            $this->_bind = @ldap_bind($this->_conn,$this->_ad_username.$this->_account_suffix,$this->_ad_password);
            if (!$this->_bind){
                // Modified by SysCo/al
                $this->_error = TRUE;
                $this->_error_message = 'FATAL: AD rebind failed.';
                exit();
            } //this should never happen in theory
        }
        
        return (true);
    }

    //*****************************************************************************************************************
    // GROUP FUNCTIONS

    // Add a group to a group
    function group_add_group($parent,$child){

        //find the parent group's dn
        $parent_group=$this->group_info($parent,array("cn"));
        if ($parent_group[0]["dn"]==NULL){ return (false); }
        $parent_dn=$parent_group[0]["dn"];
        
        //find the child group's dn
        $child_group=$this->group_info($child,array("cn"));
        if ($child_group[0]["dn"]==NULL){ return (false); }
        $child_dn=$child_group[0]["dn"];
                
        $add=array();
        $add["member"] = $child_dn;
        
        $result=@ldap_mod_add($this->_conn,$parent_dn,$add);
        if ($result==false){ return (false); }
        return (true);
    }

    // Add a user to a group
    function group_add_user($group,$user){
        //adding a user is a bit fiddly, we need to get the full DN of the user
        //and add it using the full DN of the group
        
        //find the user's dn
        $user_info=$this->user_info($user,array("cn"));
        if ($user_info[0]["dn"]==NULL){ return (false); }
        $user_dn=$user_info[0]["dn"];
        
        //find the group's dn
        $group_info=$this->group_info($group,array("cn"));
        if ($group_info[0]["dn"]==NULL){ return (false); }
        $group_dn=$group_info[0]["dn"];
        
        $add=array();
        $add["member"] = $user_dn;
        
        $result=@ldap_mod_add($this->_conn,$group_dn,$add);
        if ($result==false){ return (false); }
        return (true);
    }

    // Create a group
    function group_create($attributes){
        if (!is_array($attributes)){ return ("Attributes must be an array"); }
        if (!array_key_exists("group_name",$attributes)){ return ("Missing compulsory field [group_name]"); }
        if (!array_key_exists("container",$attributes)){ return ("Missing compulsory field [container]"); }
        if (!array_key_exists("description",$attributes)){ return ("Missing compulsory field [description]"); }
        if (!is_array($attributes["container"])){ return ("Container attribute must be an array."); }
        $attributes["container"]=array_reverse($attributes["container"]);

        //$member_array = array();
        //$member_array[0] = "cn=user1,cn=Users,dc=yourdomain,dc=com";
        //$member_array[1] = "cn=administrator,cn=Users,dc=yourdomain,dc=com";
        
        $add=array();
        $add["cn"] = $attributes["group_name"];
        $add[$this->_group_cn_identifier] = $attributes["group_name"];
        $add["objectClass"] = "Group";
        $add["description"] = $attributes["description"];
        //$add["member"] = $member_array; UNTESTED

        $container="OU=".implode(",OU=",$attributes["container"]);
        $result=ldap_add($this->_conn,"CN=".$add["cn"].", ".$container.",".$this->_base_dn,$add);
        if ($result!=true){ return (false); }
        
        return (true);
    }

    // Remove a group from a group
    function group_del_group($parent,$child){

        //find the parent dn
        $parent_group=$this->group_info($parent,array("cn"));
        if ($parent_group[0]["dn"]==NULL){ return (false); }
        $parent_dn=$parent_group[0]["dn"];
        
        //find the child dn
        $child_group=$this->group_info($child,array("cn"));
        if ($child_group[0]["dn"]==NULL){ return (false); }
        $child_dn=$child_group[0]["dn"];
        
        $del=array();
        $del["member"] = $child_dn;
        
        $result=@ldap_mod_del($this->_conn,$parent_dn,$del);
        if ($result==false){ return (false); }
        return (true);
    }

    // Remove a user from a group
    function group_del_user($group,$user){

        //find the parent dn
        $group_info=$this->group_info($group,array("cn"));
        if ($group_info[0]["dn"]==NULL){ return (false); }
        $group_dn=$group_info[0]["dn"];
        
        //find the child dn
        $user_info=$this->user_info($user,array("cn"));
        if ($user_info[0]["dn"]==NULL){ return (false); }
        $user_dn=$user_info[0]["dn"];

        $del=array();
        $del["member"] = $user_dn;
        
        $result=@ldap_mod_del($this->_conn,$group_dn,$del);
        if ($result==false){ return (false); }
        return (true);
    }

    // Returns an array of information for a specified group
    function group_info($group_name,$fields=NULL){
        if ($group_name==NULL){ return (false); }
        if (!$this->_bind){ return (false); }
        
        $filter="(&(objectCategory=group)(name=".$this->ldap_slashes($group_name)."))";

        if ($fields==NULL){ $fields=array("member",$this->_group_attribute,"cn","description","distinguishedname","objectcategory",$this->_group_cn_identifier); }
        $sr=ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        $entries = $this->ldap_get_entries_raw($sr);

        return ($entries);
    }

    // Return a complete list of "groups in groups"	
	// Cache added 2014-07-21 by SysCo/al
    function recursive_groups($group, $cache_only = FALSE){
        $this->_debug_message = "";
        $this->_warning_message = "";
        if ($group==NULL){ return (false); }

        $ret_groups=array();

/*
    echo "DEBUG GROUP is group $group in cache ?\n";
    print_r($this->_cache_recursive_groups);
*/
        
		if ($this->_cache_support && isset($this->_cache_recursive_groups[$group]))
		{
			$ret_groups = $this->_cache_recursive_groups[$group];
		}
		elseif (!$cache_only)
		{
			$groups=$this->group_info($group,array($this->_group_attribute));

/*
echo "DEBUG GROUP groups info\n";
print_r($groups);
*/
			
			// Additional test by SysCo/al
			if (isset($groups[0][$this->_group_attribute]))
			{
				$groups=$groups[0][$this->_group_attribute];

				if ($groups){
					$group_names=$this->nice_names($groups);

/*
echo "DEBUG GROUP:\n";
print_r($group_names);
echo "DEBUG nice name:\n";
print_r($this->nice_names($groups));
echo "\n";
*/
					$ret_groups=array_merge($ret_groups,$group_names); //final groups to return
					
					foreach ($group_names as $id => $group_name){
						$child_groups=$this->recursive_groups($group_name);
						$ret_groups=array_merge($ret_groups,$child_groups);
					}
				}
			}
			if ($this->_cache_support)
			{
				$this->_cache_recursive_groups[$group] = $ret_groups;
			}
		}
        else
        {
            $this->_debug_message = "The requested group $group is not in cache.";
        }
        return ($ret_groups);
    }

    //*****************************************************************************************************************
    // USER FUNCTIONS

    //create a user
    function user_create($attributes){
        //check for compulsory fields
        if (!array_key_exists("username",$attributes)){ return ("Missing compulsory field [username]"); }
        if (!array_key_exists("firstname",$attributes)){ return ("Missing compulsory field [firstname]"); }
        if (!array_key_exists("surname",$attributes)){ return ("Missing compulsory field [surname]"); }
        if (!array_key_exists("email",$attributes)){ return ("Missing compulsory field [email]"); }
        if (!array_key_exists("container",$attributes)){ return ("Missing compulsory field [container]"); }
        if (!is_array($attributes["container"])){ return ("Container attribute must be an array."); }

        if (array_key_exists("password",$attributes) && !$this->_use_ssl){ 
            // Modified by SysCo/al
            $this->_error = TRUE;
            $this->_error_message = 'FATAL: SSL must be configured on your webserver and enabled in the class to set passwords.';
            exit();
        }

        if (!array_key_exists("display_name",$attributes)){ $attributes["display_name"]=$attributes["firstname"]." ".$attributes["surname"]; }

        //translate the schema
        $add=$this->adldap_schema($attributes);
        
        //additional stuff only used for adding accounts
        $add["cn"][0]=$attributes["display_name"];
        $add[$this->_cn_identifier][0]=$attributes["username"];
        $add["objectclass"][0]="top";
        $add["objectclass"][1]="person";
        $add["objectclass"][2]="organizationalPerson";
        $add["objectclass"][3]="user"; //person?
        //$add["name"][0]=$attributes["firstname"]." ".$attributes["surname"];

        //set the account control attribute
        $control_options=array("NORMAL_ACCOUNT");
        if (!$attributes["enabled"]){ $control_options[]="ACCOUNTDISABLE"; }
        $add["userAccountControl"][0]=$this->account_control($control_options);
        //echo ("<pre>"); print_r($add);

        //determine the container
        $attributes["container"]=array_reverse($attributes["container"]);
        $container="OU=".implode(",OU=",$attributes["container"]);

        //add the entry
        $result=@ldap_add($this->_conn, "CN=".$add["cn"][0].", ".$container.",".$this->_base_dn, $add);
        if ($result!=true){ return (false); }
        
        return (true);
    }

    
    // group_users($group_name)
    //	Returns an array of users that are members of a group
    function group_users($group_name=NUL){
        $result = array();
        if ($group_name==NULL){ return (false); }
        if (!$this->_bind){ return (false); }
        $filter="(&(|(objectClass=posixGroup)(objectClass=groupofNames))(".$this->_group_cn_identifier."=".$this->ldap_slashes($group_name)."))";

        $fields=array("member","memberuid");
        $sr=ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        $entries = $this->ldap_get_entries_raw($sr);

        if (isset($entries[0]["member"][0]))
        {
            $result = $this->nice_names($entries[0]["member"]);
            /*
            for ($i=0; $i++; $i < $entries[0]["member"][count])
            {
                $result[] == ($entries[0]["member"][$i]);
            }
            */
        }
        elseif (isset($entries[0]["memberuid"][0]))
        {
            $result = $this->nice_names($entries[0]["memberuid"]);
        }
        else
        {
            $result = array();
        }
        return ($result);
    }

    
    // user_groups($user)
    //	Returns an array of groups that a user is a member off
    function user_groups($username,$recursive=NULL){
        if ($username==NULL){ return (false); }
        if ($recursive==NULL){ $recursive=$this->_recursive_groups; } //use the default option if they haven't set it
        if (!$this->_bind){ return (false); }
        
        //search the directory for their information
        $info=@$this->user_info($username,array($this->_group_attribute,"member","primarygroupid"));
        
        $groups=$this->nice_names($info[0][$this->_group_attribute]); //presuming the entry returned is our guy (unique usernames)

        if ($recursive){
            foreach ($groups as $id => $group_name){
                $extra_groups=$this->recursive_groups($group_name);
                $groups=array_merge($groups,$extra_groups);
            }
        }
        return ($groups);
    }


	// Added by SysCo/al
	// New implementation 2014-07-21 by SysCo/al
    // Returns an array of information for filtered users
    function users_info($username=NULL, $fields=NULL)
	{
		$entries = array();
		$entries['count'] = 0; // To be compatible with the old data organisation (counter at the beginning)
		$i = 0;
		if ($result = $this->one_user_info(TRUE, $username, $fields))
		{
			do
			{
				$entries[$i] = $result;
				$i++;
			}
			while ($result = $this->one_user_info());
		}
		$entries['count'] = $i; // and not count($entries) because of the ['count'] argument
        return ($entries);
    }


	// Added 2014-07-21 by SysCo/al
    function one_user_info($first = FALSE, $username = NULL, $fields = NULL, $group_cn_cache_only = FALSE)
	{
        $this->_warning_message = '';
		$sr = FALSE;
		if ($first)
		{
			if ($username==NULL){ return (false); }
			if (!$this->_bind){ return (false); }

            if (1 == $this->_ldap_server_type) // Active Directory
            {
                $filter = "(&(objectClass=user)(samaccounttype=". ADLDAP_NORMAL_ACCOUNT .")(objectCategory=person)(".$this->_cn_identifier."=".$username."))";
                if ($fields==NULL){ $fields=array($this->_cn_identifier,"mail",$this->_group_attribute,"department","description","displayname","telephonenumber","primarygroupid","distinguishedname"); }
            }
            else // Generic LDAP
            {
                $filter = "(&(objectClass=posixAccount)(".$this->_cn_identifier."=".$username."))";
                if ($fields==NULL){ $fields=array($this->_cn_identifier,"mail",$this->_group_attribute,"department","gecos","description","displayname","telephonenumber","gidnumber","distinguishedname"); }
            }

			$this->_oui_sr = @ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
            if (4 == ldap_errno($this->_conn))
            {
                $cr = @ldap_count_entries($this->_conn,$this->_oui_sr);
                $this->_warning_message = "LDAP server cannot return more than $cr records.";
            }
            // echo "DEBUG: Error: ".ldap_errno($this->_conn);
            // $cr = ldap_count_entries($this->_conn,$sr);
            // echo $cr;
            // echo "DEBUG: Error: ".ldap_errno($this->_conn);
		}
		if ($one_entry = $this->ldap_get_one_entry_raw("ONE_USER", $first, $this->_oui_sr))
		{
            $add_primary_group = FALSE;
			if ($this->_real_primarygroup)
			{
				if (isset($one_entry["primarygroupid"][0]))
				{
					$one_entry[$this->_group_attribute][]=$this->group_cn($one_entry["primarygroupid"][0], $group_cn_cache_only);
                    $add_primary_group = TRUE;
				}
			}
			else
			{
				$one_entry[$this->_group_attribute][]="CN=Domain Users,CN=Users,".$this->_base_dn;
                $add_primary_group = TRUE;
			}
            if ($add_primary_group)
            {
                @$one_entry[$this->_group_attribute]["count"]++;
            }
		}

		return ($one_entry);
    }


    // Returns an array of information for a specific user
    function user_info($username,$fields=NULL){
        if ($username==NULL){ return (false); }
        if (!$this->_bind){ return (false); }

        $filter = "(&(".$this->_cn_identifier."=".$username."))";
        if ($fields==NULL){ $fields=array($this->_cn_identifier,"mail",$this->_group_attribute,"department","description","displayname","gecos","telephonenumber","primarygroupid"); }
        $sr=ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        $entries = $this->ldap_get_entries_raw($sr);
        
        // AD does not return the primary group in the ldap query, we may need to fudge it
        // SysCo/al added a test to check if $entries[0]["primarygroupid"][0] exists
        if ($this->_real_primarygroup){
            if (isset($entries[0]["primarygroupid"][0]))
            {
                $entries[0][$this->_group_attribute][]=$this->group_cn($entries[0]["primarygroupid"][0]);
            }
        } else {
            $entries[0][$this->_group_attribute][]="CN=Domain Users,CN=Users,".$this->_base_dn;
        }
        
        @$entries[0][$this->_group_attribute]["count"]++;
        return ($entries);
    }

    // Returns true if the user is a member of the group
    function user_ingroup($username,$group,$recursive=NULL){
        if ($username==NULL){ return (false); }
        if ($group==NULL){ return (false); }
        if (!$this->_bind){ return (false); }
        if ($recursive==NULL){ $recursive=$this->_recursive_groups; } //use the default option if they haven't set it
        
        //get a list of the groups
        $groups=$this->user_groups($username,array($this->_group_attribute),$recursive);
        
        //return true if the specified group is in the group list
        if (in_array($group,$groups)){ return (true); }

        return (false);
    }

    //modify a user
    function user_modify($username,$attributes){
        if ($username==NULL){ return ("Missing compulsory field [username]"); }
        if (array_key_exists("password",$attributes) && !$this->_use_ssl){ echo ("FATAL: SSL must be configured on your webserver and enabled in the class to set passwords."); exit(); }
        //if (array_key_exists("container",$attributes)){
            //if (!is_array($attributes["container"])){ return ("Container attribute must be an array."); }
            //$attributes["container"]=array_reverse($attributes["container"]);
        //}

        //find the dn of the user
        $user=$this->user_info($username,array("cn"));
        if ($user[0]["dn"]==NULL){ return (false); }
        $user_dn=$user[0]["dn"];

        //translate the update to the LDAP schema				
        $mod=$this->adldap_schema($attributes);
        if (!$mod){ return (false); }
        
        //set the account control attribute (only if specified)
        if (array_key_exists("enabled",$attributes)){
            if ($attributes["enabled"]){ $control_options=array("NORMAL_ACCOUNT"); }
            else { $control_options=array("NORMAL_ACCOUNT","ACCOUNTDISABLE"); }
            $mod["userAccountControl"][0]=$this->account_control($control_options);
        }

        //do the update
        $result=ldap_modify($this->_conn,$user_dn,$mod);
        if ($result==false){ return (false); }
        
        return (true);
    }
        
    // Set the password of a user
    function user_password($username,$password){
        if ($username==NULL){ return (false); }
        if ($password==NULL){ return (false); }
        if (!$this->_bind){ return (false); }
        if (!$this->_use_ssl){ echo ("FATAL: SSL must be configured on your webserver and enabled in the class to set passwords."); exit(); }
        
        $user=$this->user_info($username,array("cn"));
        if ($user[0]["dn"]==NULL){ return (false); }
        $user_dn=$user[0]["dn"];
                
        $add=array();
        $add["unicodePwd"][0]=$this->encode_password($password);
        
        $result=ldap_mod_replace($this->_conn,$user_dn,$add);
        if ($result==false){ return (false); }
        
        return (true);
    }

    //*****************************************************************************************************************
    // COMPUTER FUNCTIONS

    // Returns an array of information for a specific computer
    function computer_info($computer_name,$fields=NULL){
        if ($computer_name==NULL){ return (false); }
        if (!$this->_bind){ return (false); }

        $filter="(&(objectClass=computer)(cn=".$computer_name."))";
        if ($fields==NULL){ $fields=array($this->_group_attribute,"cn","displayname","dnshostname","distinguishedname","objectcategory","operatingsystem","operatingsystemservicepack","operatingsystemversion"); }
        $sr=ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        $entries = $this->ldap_get_entries_raw($sr);
        
        return ($entries);
    }

    // Returns all AD users
    function all_users($include_desc = false, $search = "*", $sorted = true){
        if (!$this->_bind){ return (false); }
        
        //perform the search and grab all their details
        $filter = "(&(objectClass=user)(samaccounttype=". ADLDAP_NORMAL_ACCOUNT .")(objectCategory=person)(cn=".$search."))";
        $fields=array($this->_cn_identifier,"displayname");
        $sr=ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        $entries = $this->ldap_get_entries_raw($sr);

        $users_array = array();
        for ($i=0; $i<$entries["count"]; $i++){
            if ($include_desc && strlen($entries[$i]["displayname"][0])>0){
                $users_array[ $entries[$i][$this->_cn_identifier][0] ] = $entries[$i]["displayname"][0];
            } elseif ($include_desc){
                $users_array[ $entries[$i][$this->_cn_identifier][0] ] = $entries[$i][$this->_cn_identifier][0];
            } else {
                array_push($users_array, $entries[$i][$this->_cn_identifier][0]);
            }
        }
        if ($sorted){ asort($users_array); }
        return ($users_array);
    }

    // Returns a complete list of the groups in AD
    // New implementation 2014-07-22 by SysCo/al (with paging support)
    function all_groups($include_desc = false,
                        $search = "*",
                        $sorted = true,
                        $local_group = FALSE // $local_group switch added by SysCo/al
                       )
    {
        $this->_warning_message = "";
        if (!$this->_bind){ return (false); }

        if (1 == $this->_ldap_server_type) // Active Directory
        {
            //perform the search and grab all their details
            if ($local_group)
            {
                $group_account_type = "(|(samaccounttype=".ADLDAP_SECURITY_LOCAL_GROUP.")(samaccounttype=". ADLDAP_SECURITY_GLOBAL_GROUP."))";
            }
            else
            {
                $group_account_type = "(samaccounttype=".ADLDAP_SECURITY_GLOBAL_GROUP.")";
            }
            $filter = "(&(objectCategory=group)".$group_account_type."(cn=".$search."))";
            $fields = array($this->_group_cn_identifier,"description");
        }
        else // Generic LDAP
        {
            $filter="(|(objectClass=posixGroup)(objectClass=groupofNames))";
            $fields=array($this->_group_cn_identifier,"description");
        }


        $groups_array = array();

        $pageSize = 1000;
        $page_cookie = '';
        do
        {
            if (function_exists('ldap_control_paged_result'))
            {
                ldap_control_paged_result($this->_conn, $pageSize, true, $page_cookie);
            }
            $sr = @ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
        
            if ((!function_exists('ldap_control_paged_result')) && (4 == ldap_errno($this->_conn)))
            {
                $cr = @ldap_count_entries($this->_conn,$sr);
                $this->_warning_message = "LDAP server cannot return more than $cr records.";
            }
        
            $entries = $this->ldap_get_entries_raw($sr);

            for ($i=0; $i<$entries["count"]; $i++){
                if ($include_desc && strlen($entries[$i]["description"][0]) > 0 ){
                    $groups_array[ $entries[$i][$this->_group_cn_identifier][0] ] = $entries[$i]["description"][0];
                } elseif ($include_desc){
                    $groups_array[ $entries[$i][$this->_group_cn_identifier][0] ] = $entries[$i][$this->_group_cn_identifier][0];
                } else {
                    array_push($groups_array, $entries[$i][$this->_group_cn_identifier][0]);
                }
            }
            if (function_exists('ldap_control_paged_result_response'))
            {
                ldap_control_paged_result_response($this->_conn, $sr, $page_cookie);
            }
        }
        while($page_cookie !== null && $page_cookie != '');
        
        if (function_exists('ldap_control_paged_result'))
        {
            // Reset LDAP paged result
            ldap_control_paged_result($this->_conn, 1000);
        }
        
        if( $sorted ){ asort($groups_array); }
        
        return ($groups_array);
        
    }


    //************************************************************************************************************
    // UTILITY FUNCTIONS (not intended to be called directly but I suppose you could?)

    function adldap_schema($attributes){

        //ldap doesn't like NULL attributes, only set them if they have values
        // I'd like to know how to set an LDAP attribute to NULL though, at the moment I set it to a space
        // SysCo/al added "mobile"
        $mod=array();
        if ($attributes["address_city"]){ $mod["l"][0]=$attributes["address_city"]; }
        if ($attributes["address_code"]){ $mod["postalCode"][0]=$attributes["address_code"]; }
        //if ($attributes["address_country"]){ $mod["countryCode"][0]=$attributes["address_country"]; } // use country codes?
        if ($attributes["address_pobox"]){ $mod["postOfficeBox"][0]=$attributes["address_pobox"]; }
        if ($attributes["address_state"]){ $mod["st"][0]=$attributes["address_state"]; }
        if ($attributes["address_street"]){ $mod["streetAddress"][0]=$attributes["address_street"]; }
        if ($attributes["company"]){ $mod["company"][0]=$attributes["company"]; }
        if ($attributes["change_password"]){ $mod["pwdLastSet"][0]=0; }
        if ($attributes["company"]){ $mod["company"][0]=$attributes["company"]; }
        if ($attributes["department"]){ $mod["department"][0]=$attributes["department"]; }
        if ($attributes["description"]){ $mod["description"][0]=$attributes["description"]; }
        if ($attributes["display_name"]){ $mod["displayName"][0]=$attributes["display_name"]; }
        if ($attributes["email"]){ $mod["mail"][0]=$attributes["email"]; }
        if ($attributes["expires"]){ $mod["accountExpires"][0]=$attributes["expires"]; } //unix epoch format?
        if ($attributes["firstname"]){ $mod["givenName"][0]=$attributes["firstname"]; }
        if ($attributes["home_directory"]){ $mod["homeDirectory"][0]=$attributes["home_directory"]; }
        if ($attributes["home_drive"]){ $mod["homeDrive"][0]=$attributes["home_drive"]; }
        if ($attributes["initials"]){ $mod["initials"][0]=$attributes["initials"]; }
        if ($attributes["logon_name"]){ $mod["userPrincipalName"][0]=$attributes["logon_name"]; }
        if ($attributes["manager"]){ $mod["manager"][0]=$attributes["manager"]; }  //UNTESTED ***Use DistinguishedName***
        if ($attributes["office"]){ $mod["physicalDeliveryOfficeName"][0]=$attributes["office"]; }
        if ($attributes["password"]){ $mod["unicodePwd"][0]=$this->encode_password($attributes["password"]); }
        if ($attributes["profile_path"]){ $mod["profilepath"][0]=$attributes["profile_path"]; }
        if ($attributes["script_path"]){ $mod["scriptPath"][0]=$attributes["script_path"]; }
        if ($attributes["surname"]){ $mod["sn"][0]=$attributes["surname"]; }
        if ($attributes["title"]){ $mod["title"][0]=$attributes["title"]; }
        if ($attributes["telephone"]){ $mod["telephoneNumber"][0]=$attributes["telephone"]; }
        if ($attributes["mobile"]){ $mod["telephoneNumber"][0]=$attributes["mobile"]; }
        if ($attributes["web_page"]){ $mod["wWWHomePage"][0]=$attributes["web_page"]; }
        //echo ("<pre>"); print_r($mod);
    /*
        // modifying a name is a bit fiddly
        if ($attributes["firstname"] && $attributes["surname"]){
            $mod["cn"][0]=$attributes["firstname"]." ".$attributes["surname"];
            $mod["displayname"][0]=$attributes["firstname"]." ".$attributes["surname"];
            $mod["name"][0]=$attributes["firstname"]." ".$attributes["surname"];
        }
    */


        if (count($mod)==0){ return (false); }
        return ($mod);
    }


    function group_cn($gid, $cache_only = FALSE, $local_group = FALSE){
        // coping with AD not returning the primary group
        // http://support.microsoft.com/?kbid=321360
        // for some reason it's not possible to search on primarygrouptoken=XXX
        // if someone can show otherwise, I'd like to know about it :)
        // this way is resource intensive and generally a pain in the @#%^
		// Cache added 2014-07-21 by SysCo/al
        // Cache only added 2014-07-23 by SysCo/al
        $this->_warning_message = "";
        if ($gid==NULL){ return (false); }
        $r=false;

		if ($this->_cache_support && isset($this->_cache_group_cn[$gid]))
		{
			$r = $this->_cache_group_cn[$gid];
		}
		elseif (!$cache_only)
		{
            if (1 == $this->_ldap_server_type) // Active Directory
            {
                if ($local_group)
                {
                    $group_account_type = "(|(samaccounttype=".ADLDAP_SECURITY_LOCAL_GROUP.")(samaccounttype=". ADLDAP_SECURITY_GLOBAL_GROUP."))";
                }
                else
                {
                    $group_account_type = "(samaccounttype=".ADLDAP_SECURITY_GLOBAL_GROUP.")";
                }
                $filter="(&(objectCategory=group)".$group_account_type.")";
                $fields=array("primarygrouptoken",$this->_group_cn_identifier,"distinguishedname");
            }
            else // Generic LDAP
            // http://www.rainingpackets.com/ldap-posixgroup-groupofnames/
            {
                $filter="(|(objectClass=posixGroup)(objectClass=groupofNames))";
                $fields=array("gidnumber",$this->_group_cn_identifier,"distinguishedname");
            }
            
            $pageSize = 1000;
            $page_cookie = '';
            do
            {
                if (function_exists('ldap_control_paged_result'))
                {
                    ldap_control_paged_result($this->_conn, $pageSize, true, $page_cookie);
                }
                $sr = @ldap_search($this->_conn,$this->_base_dn,$filter,$fields);
            
                if ((!function_exists('ldap_control_paged_result')) && (4 == ldap_errno($this->_conn)))
                {
                    $cr = @ldap_count_entries($this->_conn,$sr);
                    $this->_warning_message = "LDAP server cannot return more than $cr records.";
                }
            
                $entries = $this->ldap_get_entries_raw($sr);
                
                for ($i=0; $i<$entries["count"]; $i++)
                {
                    // if (!isset($entries[$i]["distinguishedname"][0]))
                    if (1 != $this->_ldap_server_type) // We don't want the full distinguishedname for posixGroups, cn only
                    {
                        // $entries[$i]["distinguishedname"][0] = ldap_get_dn($this->_conn, $entries[$i]);
                        // We want to use the cn only
                        $entries[$i]["distinguishedname"][0] = $entries[$i][$this->_group_cn_identifier][0];
                    }
                    if (!isset($entries[$i]["primarygrouptoken"][0]))
                    {
                        $entries[$i]["primarygrouptoken"][0] = (isset($entries[$i]["gidnumber"][0])?$entries[$i]["gidnumber"][0]:NULL);
                    }

                    if ($this->_cache_support)
                    {
                        if (NULL !== $entries[$i]["primarygrouptoken"][0])
                        {
                            $this->_cache_group_cn[$entries[$i]["primarygrouptoken"][0]] = $entries[$i]["distinguishedname"][0];
                        }
                    }
                    if ($entries[$i]["primarygrouptoken"][0]==$gid){
                        $r=$entries[$i]["distinguishedname"][0];
                        $i=$entries["count"];
                    }
                }
                if (function_exists('ldap_control_paged_result_response'))
                {
                    ldap_control_paged_result_response($this->_conn, $sr, $page_cookie);
                }
            }
            while($page_cookie !== null && $page_cookie != '');
            
            if (function_exists('ldap_control_paged_result'))
            {
                // Reset LDAP paged result
                ldap_control_paged_result($this->_conn, 1000);
            }
		}
        return ($r);
    }

    // Encode a password for transmission over LDAP
    function encode_password($password){
        $password="\"".$password."\"";
        $encoded="";
        for ($i=0; $i <strlen($password); $i++){ $encoded.="{$password{$i}}\000"; }
        return ($encoded);
    }

    // Escape bad characters
    // DEVELOPERS SHOULD BE DOING PROPER FILTERING IF THEY'RE ACCEPTING USER INPUT
    // this is just a list of characters with known problems and I'm trying not to strip out other languages
    function ldap_slashes($str){
        $illegal=array("(",")","#"); // the + character has problems too, but it's an illegal character
        
        $legal=array();
        foreach ($illegal as $id => $char){ $legal[$id]="\\".$char; } //make up the array of legal chars
        
        $str=str_replace($illegal,$legal,$str); //replace them
        return ($str);
    }

    // Return a random controller
    function random_controller(){
        //select a random domain controller
        mt_srand(doubleval(microtime()) * 100000000); // for older php versions
        return ($this->_domain_controllers[array_rand($this->_domain_controllers)]);
    }

    function account_control($options){
        $val=0;

        if (is_array($options)){
            if (in_array("SCRIPT",$options)){ $val=$val+1; }
            if (in_array("ACCOUNTDISABLE",$options)){ $val=$val+2; }
            if (in_array("HOMEDIR_REQUIRED",$options)){ $val=$val+8; }
            if (in_array("LOCKOUT",$options)){ $val=$val+16; }
            if (in_array("PASSWD_NOTREQD",$options)){ $val=$val+32; }
            //PASSWD_CANT_CHANGE Note You cannot assign this permission by directly modifying the UserAccountControl attribute.
            //For information about how to set the permission programmatically, see the "Property flag descriptions" section.
            if (in_array("ENCRYPTED_TEXT_PWD_ALLOWED",$options)){ $val=$val+128; }
            if (in_array("TEMP_DUPLICATE_ACCOUNT",$options)){ $val=$val+256; }
            if (in_array("NORMAL_ACCOUNT",$options)){ $val=$val+512; }
            if (in_array("INTERDOMAIN_TRUST_ACCOUNT",$options)){ $val=$val+2048; }
            if (in_array("WORKSTATION_TRUST_ACCOUNT",$options)){ $val=$val+4096; }
            if (in_array("SERVER_TRUST_ACCOUNT",$options)){ $val=$val+8192; }
            if (in_array("DONT_EXPIRE_PASSWORD",$options)){ $val=$val+65536; }
            if (in_array("MNS_LOGON_ACCOUNT",$options)){ $val=$val+131072; }
            if (in_array("SMARTCARD_REQUIRED",$options)){ $val=$val+262144; }
            if (in_array("TRUSTED_FOR_DELEGATION",$options)){ $val=$val+524288; }
            if (in_array("NOT_DELEGATED",$options)){ $val=$val+1048576; }
            if (in_array("USE_DES_KEY_ONLY",$options)){ $val=$val+2097152; }
            if (in_array("DONT_REQ_PREAUTH",$options)){ $val=$val+4194304; } 
            if (in_array("PASSWORD_EXPIRED",$options)){ $val=$val+8388608; }
            if (in_array("TRUSTED_TO_AUTH_FOR_DELEGATION",$options)){ $val=$val+16777216; }
        }
        return ($val);
    }

    // Take an ldap query and return the nice names, without all the LDAP prefixes (eg. CN, DN)
    function nice_names($groups){

        $group_array=array();
        for ($i=0; $i<$groups["count"]; $i++){ //for each group
            if (isset($groups[$i])) // Patched by SysCo/al
            {
                $line=trim($groups[$i]);
                
                if (strlen($line)>0){ 
                    //more presumptions, they're all prefixed with CN= (but no more yet, patched by SysCo/al
                    //so we ditch the first three characters and the group
                    //name goes up to the first comma
                    $bits=explode(",",$line);
                    if (1== count($bits))
                    {
                        $group_array[]=$bits[0];  // Patched by SysCo/al
                    }
                    else
                    {
                        $prefix_len=strpos($bits[0], "=");  // Patched by SysCo/al to allow also various length (not only 3)
                        if (FALSE === $prefix_len)
                        {
                            $group_array[]=$bits[0];
                        }
                        else
                        {
                            $group_array[]=substr($bits[0],$prefix_len+1);  // Patched by SysCo/al
                        }
                    }
                }
            }
        }
        return ($group_array);	
    }
}


/*************************************************
 * QRcode image PHP scripts 0.50j (FREE "AS IS") *
 * Y. Swetake                                    *
 * http://www.swetake.com/qr/index-e.html        *
 *************************************************/
    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////
    //                                                                              //
    // Custom function providing qrcode generation, based on the library from       //
    // Y. Swetake (http://www.swetake.com/qr/index-e.html)                          //
    // Last update of the original library: 2013-05-18                              //
    // Last update of the modified library: 2014-10-24                              //
    //                                                                              //
    // A better library from Dominik Dzienia exists                                 //
    //   (http://phpqrcode.sourceforge.net/), but it is not compatible with PHP 4.x //
	//   and can have incompatibilities if used with TCPDF                          //
    //                                                                              //
    // Enhancements made by SysCo/al                                                //
    //   If $file_name = "binary", send binary content without header               //
    //   Some additional parameters                                                 //
    //   Fix when calling image functions for a NULL file                           //
    //                                                                              //
    //////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////
    if (!function_exists('MultiotpQrcode')) {
    function MultiotpQrcode($data = '', $file_name = '', $image_type = "P", $ecc_level = "Q", $module_size = 4, $version = 0, $structure_m = 0, $structure_n = 0, $parity = 0, $original_data = '', $path = 'qrcode/data', $image_path = 'qrcode/image')
    {
        /*
        #
        # QRcode image PHP scripts  version 0.50j (C)2000-2013,Y.Swetake
        #
        #
        #
        #  This program outputs a png image of "QRcode model 2". 
        #  You cannot use a several functions of QRcode in this version. 
        #  See README.txt .
        #
        #  This version supports QRcode model2 version 1-40.
        #
        #
        #  This program requires PHP4.1 and gd 1.6 or higher.
        #
        #  You must set $path & $image_path the path to QRcode data file.
        #
        #
        # [usage]
        #   qr_img.php?d=[data]&e=[(L,M,Q,H)]&s=[int]&v=[(1-40)]
        #             (&m=[(1-16)]&n=[(2-16)](&p=[(0-255)],&o=[data]))
        #
        #   d= data         URL encoded data.
        #   e= ECC level    L or M or Q or H   (default M)
        #                   Low (L): Up to 7% of errors can be corrected.          // Info added for multiOTP
        #                   Medium-Low (M): Up to 15% of errors can be corrected.  // Info added for multiOTP
        #                   Medium-High (Q): Up to 25% of errors can be corrected. // Info added for multiOTP
        #                   High (H): Up to 30% of errors can be corrected.        // Info added for multiOTP
        #   s= module size  (default PNG:4 JPEG:8)
        #   v= version      1-40 or Auto select if you do not set.
        #   t= image type   J:jpeg image , other: PNG image
        #
        #  structured append  m of n (experimental)
        #   n= structure append n (2-16)
        #   m= structure append m (1-16)
        #   p= parity
        #   o= original data (URL encoded data)  for calculating parity
        #
        #
        #
        # THIS SOFTWARE IS PROVIDED BY Y.Swetake ``AS IS'' AND ANY EXPRESS OR
        # IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
        # OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        # IN NO EVENT SHALL Y.Swetake OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        # INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
        # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER CAUSED 
        # AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
        # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
        # USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        #
        */

        /* ------ setting area ------ */

        $output_name = $file_name;
        
        $qrcode_image_size = 0; // Initialized for multiOTP
        $qrcode_result = NULL;  // Added for multiOTP

        $version_ul=40;              /* upper limit for version  */  
        /* ------ setting area end ------ */

        // Adapted for multiOTP (method parameters instead of URL parameters)
        $qrcode_data_string=$data;
        $qrcode_error_correct=$ecc_level;
        $qrcode_module_size=$module_size;
        $qrcode_version=$version;
        $qrcode_image_type=$image_type;

        $qrcode_structureappend_n=$structure_n;
        $qrcode_structureappend_m=$structure_m;
        $qrcode_structureappend_parity=$parity;
        $qrcode_structureappend_originaldata=$original_data;


        if (strtolower($qrcode_image_type)=="j") // Adapted for multiOTP
        {
            $qrcode_image_type="jpeg";
        }
        else
        {
            $qrcode_image_type="png";
        }

        if ($qrcode_module_size>0) {
        } else {
            if ($qrcode_image_type=="jpeg"){
                $qrcode_module_size=8;
            } else {
                $qrcode_module_size=4;
            }
        }
        $qrcode_data_string=($qrcode_data_string); // SysCo/al no rawurldecode here, because we are calling the function directly
        $data_length=strlen($qrcode_data_string);
        if ($data_length<=0) {
            trigger_error("QRcode : Data do not exist.",E_USER_ERROR);
            exit;
        }
        $data_counter=0;
        if ($qrcode_structureappend_n>1
         && $qrcode_structureappend_n<=16
         && $qrcode_structureappend_m>0
         && $qrcode_structureqppend_m<=16){

            $data_value[0]=3;
            $data_bits[0]=4;

            $data_value[1]=$qrcode_structureappend_m-1;
            $data_bits[1]=4;

            $data_value[2]=$qrcode_structureappend_n-1;
            $data_bits[2]=4;


            $originaldata_length=strlen($qrcode_structureappend_originaldata);
            if ($originaldata_length>1){
                $qrcode_structureappend_parity=0;
                $i=0;
                while ($i<$originaldata_length){
                    $qrcode_structureappend_parity=($qrcode_structureappend_parity ^ ord(substr($qrcode_structureappend_originaldata,$i,1)));
                    $i++;
                }
            }

            $data_value[3]=$qrcode_structureappend_parity;
            $data_bits[3]=8;

            $data_counter=4;
        }

        $data_bits[$data_counter]=4;

        /*  --- determine encode mode */

        if (preg_match("/[^0-9]/",$qrcode_data_string)!=0){
            if (preg_match("/[^0-9A-Z \$\*\%\+\.\/\:\-]/",$qrcode_data_string)!=0) {


             /*  --- 8bit byte mode */

                $codeword_num_plus=array(0,0,0,0,0,0,0,0,0,0,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8);

                $data_value[$data_counter]=4;
                $data_counter++;
                $data_value[$data_counter]=$data_length;
                $data_bits[$data_counter]=8;   /* #version 1-9 */
                $codeword_num_counter_value=$data_counter;

                $data_counter++;
                $i=0;
                while ($i<$data_length){
                    $data_value[$data_counter]=ord(substr($qrcode_data_string,$i,1));
                    $data_bits[$data_counter]=8;
                    $data_counter++;
                    $i++;
                }
            } else {

            /* ---- alphanumeric mode */

                $codeword_num_plus=array(0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        4,4,4,4,4,4,4,4,4,4,4,4,4,4);

                $data_value[$data_counter]=2;
                $data_counter++;
                $data_value[$data_counter]=$data_length;
                $data_bits[$data_counter]=9;  /* #version 1-9 */
                $codeword_num_counter_value=$data_counter;


                $alphanumeric_character_hash=array("0"=>0,"1"=>1,"2"=>2,"3"=>3,"4"=>4,
        "5"=>5,"6"=>6,"7"=>7,"8"=>8,"9"=>9,"A"=>10,"B"=>11,"C"=>12,"D"=>13,"E"=>14,
        "F"=>15,"G"=>16,"H"=>17,"I"=>18,"J"=>19,"K"=>20,"L"=>21,"M"=>22,"N"=>23,
        "O"=>24,"P"=>25,"Q"=>26,"R"=>27,"S"=>28,"T"=>29,"U"=>30,"V"=>31,
        "W"=>32,"X"=>33,"Y"=>34,"Z"=>35," "=>36,"$"=>37,"%"=>38,"*"=>39,
        "+"=>40,"-"=>41,"."=>42,"/"=>43,":"=>44);

                $i=0;
                $data_counter++;
                while ($i<$data_length){
                    if (($i %2)==0){
                        $data_value[$data_counter]=$alphanumeric_character_hash[substr($qrcode_data_string,$i,1)];
                        $data_bits[$data_counter]=6;
                    } else {
                        $data_value[$data_counter]=$data_value[$data_counter]*45+$alphanumeric_character_hash[substr($qrcode_data_string,$i,1)];
                        $data_bits[$data_counter]=11;
                        $data_counter++;
                    }
                    $i++;
                }
            }
        } else {

            /* ---- numeric mode */

            $codeword_num_plus=array(0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        4,4,4,4,4,4,4,4,4,4,4,4,4,4);

            $data_value[$data_counter]=1;
            $data_counter++;
            $data_value[$data_counter]=$data_length;
            $data_bits[$data_counter]=10;   /* #version 1-9 */
            $codeword_num_counter_value=$data_counter;

            $i=0;
            $data_counter++;
            while ($i<$data_length){
                if (($i % 3)==0){
                    $data_value[$data_counter]=substr($qrcode_data_string,$i,1);
                    $data_bits[$data_counter]=4;
                } else {
                     $data_value[$data_counter]=$data_value[$data_counter]*10+substr($qrcode_data_string,$i,1);
                 if (($i % 3)==1){
                     $data_bits[$data_counter]=7;
                 } else {
                     $data_bits[$data_counter]=10;
                     $data_counter++;
                 }
                }
                $i++;
            }
        }
        if (@$data_bits[$data_counter]>0) {
            $data_counter++;
        }
        $i=0;
        $total_data_bits=0;
        while($i<$data_counter){
            $total_data_bits+=$data_bits[$i];
            $i++;
        }


        $ecc_character_hash=array("L"=>"1",
        "l"=>"1",
        "M"=>"0",
        "m"=>"0",
        "Q"=>"3",
        "q"=>"3",
        "H"=>"2",
        "h"=>"2");

         $ec=@$ecc_character_hash[$qrcode_error_correct]; 

         if (!$ec){$ec=0;}

        $max_data_bits_array=array(
        0,128,224,352,512,688,864,992,1232,1456,1728,
        2032,2320,2672,2920,3320,3624,4056,4504,5016,5352,
        5712,6256,6880,7312,8000,8496,9024,9544,10136,10984,
        11640,12328,13048,13800,14496,15312,15936,16816,17728,18672,

        152,272,440,640,864,1088,1248,1552,1856,2192,
        2592,2960,3424,3688,4184,4712,5176,5768,6360,6888,
        7456,8048,8752,9392,10208,10960,11744,12248,13048,13880,
        14744,15640,16568,17528,18448,19472,20528,21616,22496,23648,

        72,128,208,288,368,480,528,688,800,976,
        1120,1264,1440,1576,1784,2024,2264,2504,2728,3080,
        3248,3536,3712,4112,4304,4768,5024,5288,5608,5960,
        6344,6760,7208,7688,7888,8432,8768,9136,9776,10208,

        104,176,272,384,496,608,704,880,1056,1232,
        1440,1648,1952,2088,2360,2600,2936,3176,3560,3880,
        4096,4544,4912,5312,5744,6032,6464,6968,7288,7880,
        8264,8920,9368,9848,10288,10832,11408,12016,12656,13328
        );
        if (!is_numeric($qrcode_version)){
            $qrcode_version=0;
        }
        if (!$qrcode_version){
         /* #--- auto version select */
            $i=1+40*$ec;
            $j=$i+39;
            $qrcode_version=1; 
            while ($i<=$j){
                if (($max_data_bits_array[$i])>=$total_data_bits+$codeword_num_plus[$qrcode_version]     ){
                    $max_data_bits=$max_data_bits_array[$i];
                    break;
                }
             $i++;
             $qrcode_version++;
            }
        } else {
             $max_data_bits=$max_data_bits_array[$qrcode_version+40*$ec];
        }
        if ($qrcode_version>$version_ul){
          trigger_error("QRcode : too large version.",E_USER_ERROR);
        }

        $total_data_bits+=$codeword_num_plus[$qrcode_version];
            $data_bits[$codeword_num_counter_value]+=$codeword_num_plus[$qrcode_version];

        $max_codewords_array=array(0,26,44,70,100,134,172,196,242,
        292,346,404,466,532,581,655,733,815,901,991,1085,1156,
        1258,1364,1474,1588,1706,1828,1921,2051,2185,2323,2465,
        2611,2761,2876,3034,3196,3362,3532,3706);

        $max_codewords=$max_codewords_array[$qrcode_version];
        $max_modules_1side=17+($qrcode_version <<2);

        $matrix_remain_bit=array(0,0,7,7,7,7,7,0,0,0,0,0,0,0,3,3,3,3,3,3,3,
        4,4,4,4,4,4,4,3,3,3,3,3,3,3,0,0,0,0,0,0);

        /* ---- read version ECC data file */

        $byte_num=$matrix_remain_bit[$qrcode_version]+($max_codewords << 3);
        $filename=$path."/qrv".$qrcode_version."_".$ec.".dat";
        $fp1 = fopen ($filename, "rb");
            $matx=fread($fp1,$byte_num);
            $maty=fread($fp1,$byte_num);
            $masks=fread($fp1,$byte_num);
            $fi_x=fread($fp1,15);
            $fi_y=fread($fp1,15);
            $rs_ecc_codewords=ord(fread($fp1,1));
            $rso=fread($fp1,128);
        fclose($fp1);

        $matrix_x_array=unpack("C*",$matx);
        $matrix_y_array=unpack("C*",$maty);
        $mask_array=unpack("C*",$masks);

        $rs_block_order=unpack("C*",$rso);

        $format_information_x2=unpack("C*",$fi_x);
        $format_information_y2=unpack("C*",$fi_y);

        $format_information_x1=array(0,1,2,3,4,5,7,8,8,8,8,8,8,8,8);
        $format_information_y1=array(8,8,8,8,8,8,8,8,7,5,4,3,2,1,0);

        $max_data_codewords=($max_data_bits >>3);

        $filename = $path."/rsc".$rs_ecc_codewords.".dat";
        $fp0 = fopen ($filename, "rb");
        $i=0;
        while ($i<256) {
            $rs_cal_table_array[$i]=fread ($fp0,$rs_ecc_codewords);
            $i++;
        }
        fclose ($fp0);

        /*  --- set terminator */

        if ($total_data_bits<=$max_data_bits-4){
            $data_value[$data_counter]=0;
            $data_bits[$data_counter]=4;
        } else {
            if ($total_data_bits<$max_data_bits){
            $data_value[$data_counter]=0;
                $data_bits[$data_counter]=$max_data_bits-$total_data_bits;
            } else {
                if ($total_data_bits>$max_data_bits){
                trigger_error("QRcode : Overflow error",E_USER_ERROR);
                exit;
                }
            }
        }

        /* ----divide data by 8bit */

        $i=0;
        $codewords_counter=0;
        $codewords[0]=0;
        $remaining_bits=8;

        while ($i<=$data_counter) {
            $buffer=@$data_value[$i];
            $buffer_bits=@$data_bits[$i];

            $flag=1;
            while ($flag) {
                if ($remaining_bits>$buffer_bits){  
                    $codewords[$codewords_counter]=((@$codewords[$codewords_counter]<<$buffer_bits) | $buffer);
                    $remaining_bits-=$buffer_bits;
                    $flag=0;
                } else {
                    $buffer_bits-=$remaining_bits;
                    $codewords[$codewords_counter]=(($codewords[$codewords_counter] << $remaining_bits) | ($buffer >> $buffer_bits));

                    if ($buffer_bits==0) {
                        $flag=0;
                    } else {
                        $buffer= ($buffer & ((1 << $buffer_bits)-1) );
                        $flag=1;   
                    }

                    $codewords_counter++;
                    if ($codewords_counter<$max_data_codewords-1){
                        $codewords[$codewords_counter]=0;
                    }
                    $remaining_bits=8;
                }
            }
            $i++;
        }
        if ($remaining_bits!=8) {
            $codewords[$codewords_counter]=$codewords[$codewords_counter] << $remaining_bits;
        } else {
            $codewords_counter--;
        }

        /* ----  set padding character */

        if ($codewords_counter<$max_data_codewords-1){
            $flag=1;
            while ($codewords_counter<$max_data_codewords-1){
                $codewords_counter++;
                if ($flag==1) {
                    $codewords[$codewords_counter]=236;
                } else {
                    $codewords[$codewords_counter]=17;
                }
                $flag=$flag*(-1);
            }
        }

        /* ---- RS-ECC prepare */

        $i=0;
        $j=0;
        $rs_block_number=0;
        $rs_temp[0]="";

        while($i<$max_data_codewords){

            $rs_temp[$rs_block_number].=chr($codewords[$i]);
            $j++;

            if ($j>=$rs_block_order[$rs_block_number+1]-$rs_ecc_codewords){
                $j=0;
                $rs_block_number++;
                $rs_temp[$rs_block_number]="";
            }
            $i++;
        }


        /*
        #
        # RS-ECC main
        #
        */

        $rs_block_number=0;
        $rs_block_order_num=count($rs_block_order);

        while ($rs_block_number<$rs_block_order_num){

            $rs_codewords=$rs_block_order[$rs_block_number+1];
            $rs_data_codewords=$rs_codewords-$rs_ecc_codewords;

            $rstemp=$rs_temp[$rs_block_number].str_repeat(chr(0),$rs_ecc_codewords);
            $padding_data=str_repeat(chr(0),$rs_data_codewords);

            $j=$rs_data_codewords;
            while($j>0){
                $first=ord(substr($rstemp,0,1));

                if ($first){
                    $left_chr=substr($rstemp,1);
                    $cal=$rs_cal_table_array[$first].$padding_data;
                    $rstemp=$left_chr ^ $cal;
                } else {
                    $rstemp=substr($rstemp,1);
                }

                $j--;
            }

            $codewords=array_merge($codewords,unpack("C*",$rstemp));

            $rs_block_number++;
        }

        /* ---- flash matrix */

        $i=0;
        while ($i<$max_modules_1side){
            $j=0;
            while ($j<$max_modules_1side){
                $matrix_content[$j][$i]=0;
                $j++;
            }
            $i++;
        }

        /* --- attach data */

        $i=0;
        while ($i<$max_codewords){
            $codeword_i=$codewords[$i];
            $j=8;
            while ($j>=1){
                $codeword_bits_number=($i << 3) +  $j;
                $matrix_content[ $matrix_x_array[$codeword_bits_number] ][ $matrix_y_array[$codeword_bits_number] ]=((255*($codeword_i & 1)) ^ $mask_array[$codeword_bits_number] ); 
                $codeword_i= $codeword_i >> 1;
                $j--;
            }
            $i++;
        }

        $matrix_remain=$matrix_remain_bit[$qrcode_version];
        while ($matrix_remain){
            $remain_bit_temp = $matrix_remain + ( $max_codewords <<3);
            $matrix_content[ $matrix_x_array[$remain_bit_temp] ][ $matrix_y_array[$remain_bit_temp] ]  =  ( 0 ^ $mask_array[$remain_bit_temp] );
            $matrix_remain--;
        }

        #--- mask select

        $min_demerit_score=0;
            $hor_master="";
            $ver_master="";
            $k=0;
            while($k<$max_modules_1side){
                $l=0;
                while($l<$max_modules_1side){
                    $hor_master=$hor_master.chr($matrix_content[$l][$k]);
                    $ver_master=$ver_master.chr($matrix_content[$k][$l]);
                    $l++;
                }
                $k++;
            }
        $i=0;
        $all_matrix=$max_modules_1side * $max_modules_1side; 
        while ($i<8){
            $demerit_n1=0;
            $ptn_temp=array();
            $bit= 1<< $i;
            $bit_r=(~$bit)&255;
            $bit_mask=str_repeat(chr($bit),$all_matrix);
            $hor = $hor_master & $bit_mask;
            $ver = $ver_master & $bit_mask;

            $ver_shift1=$ver.str_repeat(chr(170),$max_modules_1side);
            $ver_shift2=str_repeat(chr(170),$max_modules_1side).$ver;
            $ver_shift1_0=$ver.str_repeat(chr(0),$max_modules_1side);
            $ver_shift2_0=str_repeat(chr(0),$max_modules_1side).$ver;
            $ver_or=chunk_split(~($ver_shift1 | $ver_shift2),$max_modules_1side,chr(170));
            $ver_and=chunk_split(~($ver_shift1_0 & $ver_shift2_0),$max_modules_1side,chr(170));

            $hor=chunk_split(~$hor,$max_modules_1side,chr(170));
            $ver=chunk_split(~$ver,$max_modules_1side,chr(170));
            $hor=$hor.chr(170).$ver;

            $n1_search="/".str_repeat(chr(255),5)."+|".str_repeat(chr($bit_r),5)."+/";
            $n3_search=chr($bit_r).chr(255).chr($bit_r).chr($bit_r).chr($bit_r).chr(255).chr($bit_r);

           $demerit_n3=substr_count($hor,$n3_search)*40;
           $demerit_n4=floor(abs(( (100* (substr_count($ver,chr($bit_r))/($byte_num)) )-50)/5))*10;


           $n2_search1="/".chr($bit_r).chr($bit_r)."+/";
           $n2_search2="/".chr(255).chr(255)."+/";
           $demerit_n2=0;
           preg_match_all($n2_search1,$ver_and,$ptn_temp);
           foreach($ptn_temp[0] as $str_temp){
               $demerit_n2+=(strlen($str_temp)-1);
           }
           $ptn_temp=array();
           preg_match_all($n2_search2,$ver_or,$ptn_temp);
           foreach($ptn_temp[0] as $str_temp){
               $demerit_n2+=(strlen($str_temp)-1);
           }
           $demerit_n2*=3;
          
           $ptn_temp=array();

           preg_match_all($n1_search,$hor,$ptn_temp);
           foreach($ptn_temp[0] as $str_temp){
               $demerit_n1+=(strlen($str_temp)-2);
           }

           $demerit_score=$demerit_n1+$demerit_n2+$demerit_n3+$demerit_n4;

           if ($demerit_score<=$min_demerit_score || $i==0){
                $mask_number=$i;
                $min_demerit_score=$demerit_score;
           }

        $i++;
        }

        $mask_content=1 << $mask_number;

        # --- format information

        $format_information_value=(($ec << 3) | $mask_number);
        $format_information_array=array("101010000010010","101000100100101",
        "101111001111100","101101101001011","100010111111001","100000011001110",
        "100111110010111","100101010100000","111011111000100","111001011110011",
        "111110110101010","111100010011101","110011000101111","110001100011000",
        "110110001000001","110100101110110","001011010001001","001001110111110",
        "001110011100111","001100111010000","000011101100010","000001001010101",
        "000110100001100","000100000111011","011010101011111","011000001101000",
        "011111100110001","011101000000110","010010010110100","010000110000011",
        "010111011011010","010101111101101");
        $i=0;
        while ($i<15){
            $content=substr($format_information_array[$format_information_value],$i,1);

            $matrix_content[$format_information_x1[$i]][$format_information_y1[$i]]=$content * 255;
            $matrix_content[$format_information_x2[$i+1]][$format_information_y2[$i+1]]=$content * 255;
            $i++;
        }


        $mib=$max_modules_1side+8;
        $qrcode_image_size=$mib*$qrcode_module_size;
        if ($qrcode_image_size>1480){
          trigger_error("QRcode : Too large image size",E_USER_ERROR);
        }
        $output_image =ImageCreate($qrcode_image_size,$qrcode_image_size);

        $image_path=$image_path."/qrv".$qrcode_version.".png";

        $base_image=ImageCreateFromPNG($image_path);

        $col[1]=ImageColorAllocate($base_image,0,0,0);
        $col[0]=ImageColorAllocate($base_image,255,255,255);

        $i=4;
        $mxe=4+$max_modules_1side;
        $ii=0;
        while ($i<$mxe){
            $j=4;
            $jj=0;
            while ($j<$mxe){
                if ($matrix_content[$ii][$jj] & $mask_content){
                    ImageSetPixel($base_image,$i,$j,$col[1]); 
                }
                $j++;
                $jj++;
            }
            $i++;
            $ii++;
        }
        /*
        #--- output image
        #
        */
        
        // Adapted for multiOTP in order to choose either display output or file output
        ImageCopyResized($output_image,$base_image,0,0,0,0,$qrcode_image_size,$qrcode_image_size,$mib,$mib);
        if ('' == trim($file_name))
        {
            Header("Content-type: image/".$qrcode_image_type);
            $output_name = NULL;
        }
        if ('binary' == trim($file_name))
        {
            $output_name = NULL;
            ob_start();
        }
        if ($qrcode_image_type == "jpeg")
        {
            if (NULL == $output_name)
            {
                ImageJpeg($output_image);
            }
            else
            {
                ImageJpeg($output_image, $output_name);
            }
        }
        else
        {
            if (NULL == $output_name)
            {
                ImagePng($output_image);
            }
            else
            {
                ImagePng($output_image, $output_name);
            }
        }
        if ('binary' == trim($file_name))
        {
            $qrcode_result = ob_get_clean();
        }
        else
        {
            $qrcode_result = $qrcode_image_size;
        }
        imagedestroy($base_image);
        imagedestroy($output_image);
        
        return $qrcode_result;
    }
    }

/************************************************
 * status_bar.php (2010) (FREE "AS IS")         *
 * dealnews.com, Inc.                           *
 * http://brian.moonspot.net/status_bar.php.txt *
 ************************************************/

/*********************************************************************
 *
 * Name: MultiotpShowStatus
 * Short description: Show a progress status bar in the console
 *
 * Creation 2010
 * Source: http://brian.moonspot.net/status_bar.php.txt
 * @author Copyright (c) 2010, dealnews.com, Inc. - All rights reserved.
 *
 * Adapted 2010-2014 by SysCo/al
 *
 * @param   int     $done   how many items are completed
 * @param   int     $total  how many items are to be done total
 * @param   int     $size   optional size of the status bar
 * @return  void
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * - Neither the name of dealnews.com, Inc. nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Usage
 * 
 * for($x=1;$x<=100;$x++)
 * {
 *     MultiotpShowStatus($x, 100);
 *     usleep(100000);
 * }
 *
 * @param   int     $done   how many items are completed
 * @param   int     $total  how many items are to be done total
 * @param   int     $size   optional size of the status bar
 * @return  void
 *
 *********************************************************************/
if (!function_exists('MultiotpShowStatus')) {
function MultiotpShowStatus($done, $total, $size=30)
{

    static $start_time;

    // if we go over our bound, just ignore it
    if($done > $total) return;

    if(empty($start_time)) $start_time=time();
    $now = time();

    $perc=(double)($done/$total);

    $bar=floor($perc*$size);

    $status_bar="\r[";
    $status_bar.=str_repeat("=", $bar);
    if($bar<$size)
    {
        $status_bar.=">";
        // $status_bar.=str_repeat(" ", $size-$bar);
        $status_bar.=str_repeat("-", $size-$bar);
    }
    else
    {
        $status_bar.="=";
    }

    $disp=number_format($perc*100, 0);

    $status_bar.="] $disp%  $done/$total";

    $rate = ($now-$start_time)/$done;
    $left = $total - $done;
    $eta = round($rate * $left, 2);

    $elapsed = $now - $start_time;

    // $status_bar.= " remaining: ".number_format($eta)." sec.  elapsed: ".number_format($elapsed)." sec.";

    echo "$status_bar  ";

    flush();

    // when done, send a newline
    if($done == $total)
    {
        echo "\n";
    }
}
}

/*****************************************
 * PHP Syslog class 1.1.2 (FREE "AS IS") *
 * André Liechti                         *
 * http://developer.sysco.ch/php/        *
 *****************************************/

/*********************************************************************
 *
 *             $HeadURL: http://svn.sysco.ch/svn/al/trunk/developer.sysco.ch/php/syslog.php $
 * $LastChangedRevision: 5 $
 *             Language: PHP 4.x or higher
 *            Copyright: SysCo syst�mes de communication sa
 *         CreationDate: 2005-11-05
 *            CreatedBy: SysCo/al
 *     $LastChangedDate: 2006-05-06 00:41:29 +0200 (sam., 06 mai 2006) $
 *       $LastChangedBy: al@sysco.ch $
 *              WebSite: http://developer.sysco.ch/php/
 *                Email: developer@sysco.ch
 *
 *
 * Description
 *
 *   The Syslog class is a syslog device implementation in PHP
 *   following the RFC 3164 rules
 *   (http://www.faqs.org/rfcs/rfc3164.html)
 *   (ftp://ftp.rfc-editor.org/in-notes/rfc3164.txt)
 *
 *   Facility values:
 *      0 kernel messages
 *      1 user-level messages
 *      2 mail system
 *      3 system daemons
 *      4 security/authorization messages
 *      5 messages generated internally by syslogd
 *      6 line printer subsystem
 *      7 network news subsystem
 *      8 UUCP subsystem
 *      9 clock daemon
 *     10 security/authorization messages
 *     11 FTP daemon
 *     12 NTP subsystem
 *     13 log audit
 *     14 log alert
 *     15 clock daemon
 *     16 local user 0 (local0) (default value)
 *     17 local user 1 (local1)
 *     18 local user 2 (local2)
 *     19 local user 3 (local3)
 *     20 local user 4 (local4)
 *     21 local user 5 (local5)
 *     22 local user 6 (local6)
 *     23 local user 7 (local7)
 *
 *   Severity values:
 *     0 Emergency: system is unusable
 *     1 Alert: action must be taken immediately
 *     2 Critical: critical conditions
 *     3 Error: error conditions
 *     4 Warning: warning conditions
 *     5 Notice: normal but significant condition (default value)
 *     6 Informational: informational messages
 *     7 Debug: debug-level messages
 *
 *
 * Usage
 *
 *   require_once('syslog.php');
 *   $syslog = new Syslog($facility = 16, $severity = 5, $hostname = "", $fqdn= "", $ip_from = "", $process="", $content = "");
 *   $syslog->Send($server = "", $content = "", $timeout = 0);
 *
 *
 * Examples
 *
 *   Example 1
 *      *         require_once('syslog.php');
 *         $syslog = new Syslog();
 *         $syslog->Send('192.168.0.12', 'My first PHP syslog message');
 *      *
 *   Example 2
 *      *         require_once('syslog.php');
 *         $syslog = new Syslog(23, 7, 'MYSERVER', 'myserver.mydomain.net', '192.168.0.1', 'webautomation');
 *         $syslog->Send('192.168.0.12', 'My second PHP syslog message');
 *      *
 *   Example 3
 *      *         require_once('syslog.php');
 *         $syslog = new Syslog();
 *         $syslog->SetFacility(23);
 *         $syslog->SetSeverity(7);
 *         $syslog->SetHostname('MYSERVER');
 *         $syslog->SetFqdn('myserver.mydomain.net');
 *         $syslog->SetIpFrom('192.168.0.1');
 *         $syslog->SetProcess('webautomation');
 *         $syslog->SetContent('My third PHP syslog message');
 *         $syslog->SetServer('192.168.0.12');
 *         $syslog->Send();
 *      *
 *   Example 4
 *      *         // Do not follow the conventions of the RFC
 *         // and send a customized MSG part instead of
 *         // the recommanded format "process fqdn ip content"
 *         require_once('syslog.php');
 *         $syslog = new Syslog();
 *         $syslog->SetFacility(23);
 *         $syslog->SetSeverity(7);
 *         $syslog->SetHostname('MYSERVER');
 *         $syslog->SetMsg('My customized MSG PHP syslog message');
 *         $syslog->SetServer('192.168.0.12');
 *         $syslog->Send();
 *      *
 *
 * External file needed
 *
 *   none.
 *
 *
 * External file created
 *
 *   none.
 *
 *
 * Special issues
 *
 *   - Sockets support must be enabled.
 *     * In Linux and *nix environments, the extension is enabled at
 *       compile time using the --enable-sockets configure option
 *     * In Windows, PHP Sockets can be activated by un-commenting
 *       extension=php_sockets.dll in php.ini
 *
 *
 * Licence
 *
 *   Copyright (c) 2005, SysCo syst�mes de communication sa
 *   SysCo (tm) is a trademark of SysCo syst�mes de communication sa
 *   All rights reserved.
 *
 *   Redistribution and use in source and binary forms, with or without 
 *   modification, are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer. 
 *   - Redistributions in binary form must reproduce the above copyright notice, 
 *     this list of conditions and the following disclaimer in the documentation 
 *     and/or other materials provided with the distribution. 
 *   - Neither the name of SysCo syst�mes de communication sa nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission. 
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 *   EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 *   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 *   SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 *   OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
 *   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 *   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Change Log
 *
 *   2006-xx-xx 1.1.2 SysCo/al Timeout implementation, extended documentation
 *   2005-12-24 1.1   SysCo/al Generic release and documentation
 *   2005-11-05 1.0   SysCo/al Initial release
 *
 *********************************************************************/
 
    class MultiotpSyslog
    {
        var $_facility; // Facility 0-23 (see above, default is '16', meaning 'local0')
        var $_severity; // 0-7 (see above, default is '5', meaning 'notice')
        var $_hostname; // Hostname without embedded space, no domain nameor fqdn, only a-z A-Z 0-9 and other authorized characters
        var $_fqdn;     // FQDN of the device
        var $_ip_from;  // IP address of the device
        var $_process;  // Process name (default is 'PHP')
        var $_content;  // Content of the detailed information
        var $_msg;      // Alternate MSG information (to overload the conventions of the RFC)
        var $_server;   // Syslog destination server
        var $_port;     // Standard syslog port (default value is 514)
        var $_timeout;  // Timeout of the UDP connection in seconds (default value is 20)
        
        function MultiotpSyslog($facility = 16, $severity = 5, $hostname = "", $fqdn= "", $ip_from = "", $process="", $content = "")
        {
            $this->_msg      = '';
            $this->_server   = '127.0.0.1';
            $this->_port     = 514;
            $this->_timeout  = 20;
            
            $this->_facility = $facility;
            
            $this->_severity = $severity;
            
            $this->_hostname = $hostname;
            if ($this->_hostname == "")
            {
                if (isset($_ENV["COMPUTERNAME"]))
                {
                    $this->_hostname = $_ENV["COMPUTERNAME"];
                }
                elseif (isset($_ENV["HOSTNAME"]))
                {
                    $this->_hostname = $_ENV["HOSTNAME"];
                }
                else
                {
                    $this->_hostname = "WEBSERVER";
                }
            }
            $this->_hostname = substr($this->_hostname, 0, strpos($this->_hostname.".", "."));
            
            $this->_fqdn = $fqdn;
            if ($this->_fqdn == "")
            {
                if (isset($_SERVER["SERVER_NAME"]))
                {
                    $this->_fqdn = $_SERVER["SERVER_NAME"];
                }
            }

            $this->_ip_from = $ip_from;
            if ($this->_ip_from == "")
            {
                if (isset($_SERVER["SERVER_ADDR"]))
                {
                    $this->_ip_from = $_SERVER["SERVER_ADDR"];
                }
            }

            $this->_process = $process;
            if ($this->_process == "")
            {
                $this->_process = "PHP";
            }

            $this->_content = $content;
            if ($this->_content == "")
            {
                $this->_content = "PHP generated message";
            }
            
        }

        function SetFacility($facility)
        {
            $this->_facility = $facility;
        }
        
        
        function SetSeverity($severity)
        {
            $this->_severity = $severity;
        }
        
        
        function SetHostname($hostname)
        {
            $this->_hostname = $hostname;
        }
        
        
        function SetFqdn($fqdn)
        {
            $this->_fqdn = $fqdn;
        }
        
        
        function SetIpFrom($ip_from)
        {
            $this->_ip_from = $ip_from;
        }
        
        
        function SetProcess($process)
        {
            $this->_process = $process;
        }
        
        
        function SetContent($content)
        {
            $this->_content = $content;
        }
        
        
        function SetMsg($msg)
        {
            $this->_msg = $msg;
        }
        
        
        function SetServer($server)
        {
            $this->_server = $server;
        }
        
        
        function SetPort($port)
        {
            if ((intval($port) > 0) && (intval($port) < 65536))
            {
                $this->_port = intval($port);
            }
        }


        function SetTimeout($timeout)
        {
            if (intval($timeout) > 0)
            {
                $this->_timeout = intval($timeout);
            }
        }
        
        
        function Send($server = "", $content = "", $timeout = 0)
        {
            if ($server != "")
            {
                $this->_server = $server;
            }

            if ($content != "")
            {
                $this->_content = $content;
            }
            
            if (intval($timeout) > 0)
            {
                $this->_timeout = intval($timeout);
            }
            
            if ($this->_facility <  0) { $this->_facility =  0; }
            if ($this->_facility > 23) { $this->_facility = 23; }
            if ($this->_severity <  0) { $this->_severity =  0; }
            if ($this->_severity >  7) { $this->_severity =  7; }
            
            $this->_process = substr($this->_process, 0, 32);
            
            $actualtime = time();
            $month      = date("M", $actualtime);
            $day        = substr("  ".date("j", $actualtime), -2);
            $hhmmss     = date("H:i:s", $actualtime);
            $timestamp  = $month." ".$day." ".$hhmmss;
            
            $pri    = "<".($this->_facility*8 + $this->_severity).">";
            $header = $timestamp." ".$this->_hostname;
            
            if ($this->_msg != "")
            {
                $msg = $this->_msg;
            }
            else
            {
                $msg = $this->_process.": ".$this->_fqdn." ".$this->_ip_from." ".$this->_content;
            }
            
            $message = substr($pri.$header." ".$msg, 0, 1024);
            
            $fp = fsockopen("udp://".$this->_server, $this->_port, $errno, $errstr, $this->_timeout);
            if ($fp)
            {
                fwrite($fp, $message);
                fclose($fp);
                $result = $message;
            }
            else
            {
                $result = "ERROR: $errno - $errstr";
            }
            return $result;
        }
    }

/*******************************************
 * XML Parser Class 1.3.0 (LGPLv3)         *
 * Adam A. Flynn                           *
 * http://www.criticaldevelopment.net/xml/ *
 *******************************************/
/**
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    For Support, please visit http://www.criticaldevelopment.net/xml/
*/

/**
 * XML Parser Class (php4)
 * 
 * Parses an XML document into an object structure much like the SimpleXML extension.
 *
 * @author Adam A. Flynn <adamaflynn@criticaldevelopment.net>
 * @copyright Copyright (c) 2005-2007, Adam A. Flynn
 *
 * @version 1.3.0
 *
 * Name: MultiotpXmlParser (original name: XMLParser)
 */
class MultiotpXmlParser 
{
    /**
     * The XML parser
     *
     * @var resource
     */
    var $parser;

    /**
    * The XML document
    *
    * @var string
    */
    var $xml;

    /**
    * Document tag
    *
    * @var object
    */
    var $document;

    /**
    * Current object depth
    *
    * @var array
    */
    var $stack;
    /**
     * Whether or not to replace dashes and colons in tag
     * names with underscores.
     * 
     * @var bool
     */
    var $cleanTagNames;

    
    /**
     * Constructor. Loads XML document.
     *
     * @param string $xml The string of the XML document
     * @return MultiotpXmlParser
     */
    function MultiotpXmlParser($xml = '', $cleanTagNames = true)
    {
        //Load XML document
        $this->xml = $xml;

        // Set stack to an array
        $this->stack = array();
        
        //Set whether or not to clean tag names
        $this->cleanTagNames = $cleanTagNames;
    }

    /**
     * Initiates and runs PHP's XML parser
     */
    function Parse()
    {
        //Create the parser resource
        $this->parser = xml_parser_create();
        
        //Set the handlers
        xml_set_object($this->parser, $this);
        xml_set_element_handler($this->parser, 'StartElement', 'EndElement');
        xml_set_character_data_handler($this->parser, 'CharacterData');

        //Error handling
        if (!xml_parse($this->parser, $this->xml))
            $this->HandleError(xml_get_error_code($this->parser), xml_get_current_line_number($this->parser), xml_get_current_column_number($this->parser));

        //Free the parser
        xml_parser_free($this->parser);
    }
    
    /**
     * Handles an XML parsing error
     *
     * @param int $code XML Error Code
     * @param int $line Line on which the error happened
     * @param int $col Column on which the error happened
     */
    function HandleError($code, $line, $col)
    {
        trigger_error('XML Parsing Error at '.$line.':'.$col.'. Error '.$code.': '.xml_error_string($code));
    }

    
    /**
     * Gets the XML output of the PHP structure within $this->document
     *
     * @return string
     */
    function GenerateXML()
    {
        return $this->document->GetXML();
    }

    /**
     * Gets the reference to the current direct parent
     *
     * @return object
     */
    function GetStackLocation()
    {
        $return = '';

        foreach($this->stack as $stack)
            $return .= $stack.'->';
        
        return rtrim($return, '->');
    }

    /**
     * Handler function for the start of a tag
     *
     * @param resource $parser
     * @param string $name
     * @param array $attrs
     */
    function StartElement($parser, $name, $attrs = array())
    {
        //Make the name of the tag lower case
        $name = strtolower($name);
        
        //Check to see if tag is root-level
        if (count($this->stack) == 0) 
        {
            //If so, set the document as the current tag
            $this->document = new MultiotpXMLTag($name, $attrs);

            //And start out the stack with the document tag
            $this->stack = array('document');
        }
        //If it isn't root level, use the stack to find the parent
        else
        {
            //Get the name which points to the current direct parent, relative to $this
            $parent = $this->GetStackLocation();
            
            //Add the child
            eval('$this->'.$parent.'->AddChild($name, $attrs, '.count($this->stack).', $this->cleanTagNames);');
            
            //If the cleanTagName feature is on, replace colons and dashes with underscores
            if($this->cleanTagNames)
                $name = str_replace(array(':', '-'), '_', $name);


            //Update the stack
            eval('$this->stack[] = $name.\'[\'.(count($this->'.$parent.'->'.$name.') - 1).\']\';');
        }
    }

    /**
     * Handler function for the end of a tag
     *
     * @param resource $parser
     * @param string $name
     */
    function EndElement($parser, $name)
    {
        //Update stack by removing the end value from it as the parent
        array_pop($this->stack);
    }

    /**
     * Handler function for the character data within a tag
     *
     * @param resource $parser
     * @param string $data
     */
    function CharacterData($parser, $data)
    {
        //Get the reference to the current parent object
        $tag = $this->GetStackLocation();

        //Assign data to it
        eval('$this->'.$tag.'->tagData .= trim($data);');
    }
}


/**
 * XML Tag Object (php4)
 *
 * This object stores all of the direct children of itself in the $children array. They are also stored by
 * type as arrays. So, if, for example, this tag had 2 <font> tags as children, there would be a class member
 * called $font created as an array. $font[0] would be the first font tag, and $font[1] would be the second.
 *
 * To loop through all of the direct children of this object, the $children member should be used.
 *
 * To loop through all of the direct children of a specific tag for this object, it is probably easier 
 * to use the arrays of the specific tag names, as explained above.
 *
 * @author Adam A. Flynn <adamaflynn@criticaldevelopment.net>
 * @copyright Copyright (c) 2005-2007, Adam A. Flynn
 *
 * @version 1.3.0
 *
 * Name: MultiotpXMLTag (original name: XMLTag)
 */
class MultiotpXMLTag
{
    /**
     * Array with the attributes of this XML tag
     *
     * @var array
     */
    var $tagAttrs;
    
    /**
     * The name of the tag
     *
     * @var string
     */
    var $tagName;
    
    /**
     * The data the tag contains 
     * 
     * So, if the tag doesn't contain child tags, and just contains a string, it would go here
     *
     * @var string
     */
    var $tagData;
    
    /**
     * Array of references to the objects of all direct children of this XML object
     *
     * @var array
     */
    var $tagChildren;
    
    /**
     * The number of parents this XML object has (number of levels from this tag to the root tag)
     *
     * Used presently only to set the number of tabs when outputting XML
     *
     * @var int
     */
    var $tagParents;
    
    /**
     * Constructor, sets up all the default values
     *
     * @param string $name
     * @param array $attrs
     * @param int $parents
     * @return MultiotpXMLTag
     */
    function MultiotpXMLTag($name, $attrs = array(), $parents = 0)
    {
        //Make the keys of the attr array lower case, and store the value
        $this->tagAttrs = array_change_key_case($attrs, CASE_LOWER);
        
        //Make the name lower case and store the value
        $this->tagName = strtolower($name);
        
        //Set the number of parents
        $this->tagParents = $parents;
        
        //Set the types for children and data
        $this->tagChildren = array();
        $this->tagData = '';
    }
    
    /**
     * Adds a direct child to this object
     *
     * @param string $name
     * @param array $attrs
     * @param int $parents
     * @param bool $cleanTagName
     */
    function AddChild($name, $attrs, $parents, $cleanTagName = true)
    {    
        //If the tag is a reserved name, output an error
        if(in_array($name, array('tagChildren', 'tagAttrs', 'tagParents', 'tagData', 'tagName')))
        {
            trigger_error('You have used a reserved name as the name of an XML tag. Please consult the documentation (http://www.criticaldevelopment.net/xml/) and rename the tag named "'.$name.'" to something other than a reserved name.', E_USER_ERROR);

            return;
        }
        
        //Create the child object itself
        $child = new MultiotpXMLTag($name, $attrs, $parents);

        //If the cleanTagName feature is on, replace colons and dashes with underscores
        if($cleanTagName)
            $name = str_replace(array(':', '-'), '_', $name);
        
        //Toss up a notice if someone's trying to to use a colon or dash in a tag name
        elseif(strstr($name, ':') || strstr($name, '-'))
            trigger_error('Your tag named "'.$name.'" contains either a dash or a colon. Neither of these characters are friendly with PHP variable names, and, as such, they cannot be accessed and will cause the parser to not work. You must enable the cleanTagName feature (pass true as the second argument of the MultiotpXmlParser constructor). For more details, see http://www.criticaldevelopment.net/xml/', E_USER_ERROR);
            
        //If there is no array already set for the tag name being added, 
        //create an empty array for it
        if(!isset($this->$name))
            $this->$name = array();
        
        //Add the reference of it to the end of an array member named for the tag's name
        $this->{$name}[] =& $child;
        
        //Add the reference to the children array member
        $this->tagChildren[] =& $child;
    }
    
    /**
     * Returns the string of the XML document which would be generated from this object
     * 
     * This function works recursively, so it gets the XML of itself and all of its children, which
     * in turn gets the XML of all their children, which in turn gets the XML of all thier children,
     * and so on. So, if you call GetXML from the document root object, it will return a string for 
     * the XML of the entire document.
     * 
     * This function does not, however, return a DTD or an XML version/encoding tag. That should be
     * handled by MultiotpXmlParser::GetXML()
     *
     * @return string
     */
    function GetXML()
    {
        //Start a new line, indent by the number indicated in $this->parents, add a <, and add the name of the tag
        $out = "\n".str_repeat("\t", $this->tagParents).'<'.$this->tagName;

        //For each attribute, add attr="value"
        foreach($this->tagAttrs as $attr => $value)
            $out .= ' '.$attr.'="'.$value.'"';
        
        //If there are no children and it contains no data, end it off with a />
        if(empty($this->tagChildren) && empty($this->tagData))
            $out .= " />";
        
        //Otherwise...
        else
        {    
            //If there are children
            if(!empty($this->tagChildren))        
            {
                //Close off the start tag
                $out .= '>';
                
                //For each child, call the GetXML function (this will ensure that all children are added recursively)
                foreach($this->tagChildren as $child)
                {
                    if(is_object($child))
                        $out .= $child->GetXML();
                }

                //Add the newline and indentation to go along with the close tag
                $out .= "\n".str_repeat("\t", $this->tagParents);
            }
            
            //If there is data, close off the start tag and add the data
            elseif(!empty($this->tagData))
                $out .= '>'.$this->tagData;
            
            //Add the end tag    
            $out .= '</'.$this->tagName.'>';
        }
        
        //Return the final output
        return $out;
    }
    
    /**
     * Deletes this tag's child with a name of $childName and an index
     * of $childIndex
     *
     * @param string $childName
     * @param int $childIndex
     */
    function Delete($childName, $childIndex = 0)
    {
        //Delete all of the children of that child
        $this->{$childName}[$childIndex]->DeleteChildren();
        
        //Destroy the child's value
        $this->{$childName}[$childIndex] = null;
        
        //Remove the child's name from the named array
        unset($this->{$childName}[$childIndex]);
        
        //Loop through the tagChildren array and remove any null
        //values left behind from the above operation
        for($x = 0; $x < count($this->tagChildren); $x ++)
        {
            if(is_null($this->tagChildren[$x]))
                unset($this->tagChildren[$x]);
        }
    }
    
    /**
     * Removes all of the children of this tag in both name and value
     */
    function DeleteChildren()
    {
        //Loop through all child tags
        for($x = 0; $x < count($this->tagChildren); $x ++)
        {
            //Do this recursively
            $this->tagChildren[$x]->DeleteChildren();
            
            //Delete the name and value
            $this->tagChildren[$x] = null;
            unset($this->tagChildren[$x]);
        }
    }
}

/*****************************************
 * MultiotpYubikey Class (LGPLv3)        *
 * André Liechti                         *
 * http://www.multiotp.net/              *
 *****************************************/
/*****************************************
 * MultiotpYubikey Class (LGPLv3)        *
 * Andr� Liechti                         *
 * http://www.multiotp.net/              *
 *****************************************/

class MultiotpYubikey
/**
 * @class     MultiotpYubikey
 * @brief     Class definition for Yubikey handling.
 *
 * @author    Andre Liechti, SysCo systemes de communication sa, <info@multiotp.net>
 * @version   4.3.1.2
 * @date      2014-12-22
 * @since     2014-11-04
 */
{
    // TODO: support Dvorak keyboard "jxe.uidchtnbpygk" instead of "cbdefghijklnrtuv" (automatic detection with "x.py" detected or keyboard unknown)

    // How to get a Yubico API Key: https://upgrade.yubico.com/getapikey/
    var $_yubicloud_client_id        = 19042;                          // Client ID  (by default, this ID is for multiOTP open source)
    var $_yubicloud_secret_key       = 'a72X/qkw3vPeT+yRO6lWgipwjPM='; // Secret Key (by default, this key is for multiOTP open source)

    var $_yubicloud_timeout          = 10;                 // YubiCloud timeout in seconds
    var $_yubicloud_last_response    = array();            // YubiCloud last response array
    var $_yubicloud_last_result      = '';                 // YubiCloud last result (text)
    var $_yubicloud_max_time_window  = 600;                // YubiCloud maximum time window in seconds
	var $_yubico_modhex_chars        = "cbdefghijklnrtuv"; // ModHex values (instead of 0,1,2,3,4,5,6,7,8,9,0,a,b,c,d,e,f)
	var $_yubico_modhex_dvorak_chars = "jxe.uidchtnbpygk"; // Dvorak ModHex values (instead of 0,1,2,3,4,5,6,7,8,9,0,a,b,c,d,e,f)
	var $_yubico_dvorak_only_chars   = "x.py";             // Dvorak only chars
    var $_yubico_otp_last_count      = -1;                 // Default value of the last otp counter

    
    function MultiotpYubikey($yubicloud_client_id = 0, $yubicloud_secret_key = '')
    {
        if (0 < intval($yubicloud_client_id))
        {
            $this->_yubicloud_client_id = $yubicloud_client_id;
        }
        if (28 == strlen($yubicloud_secret_key))
        {
            $this->_yubicloud_secret_key = $yubicloud_secret_key;
        }
    }


    function CalculateHashHmac($algo, $data, $key, $raw_output = false)
    {
        if (function_exists('hash_hmac'))
        {
            return hash_hmac($algo, $data, $key, $raw_output);
        }
        else
        {
            /***********************************************************************
             * Simulate the function hash_hmac if it is not available
             *   (this function is natively available only for PHP >= 5.1.2)
             *
             * Source: http://www.php.net/manual/fr/function.hash-hmac.php#93440
             *
             * @author "KC Cloyd"
             ***********************************************************************/
            $algo = strtolower($algo);
            $pack = 'H'.strlen($algo('test'));
            $size = 64;
            $opad = str_repeat(chr(0x5C), $size);
            $ipad = str_repeat(chr(0x36), $size);

            if (strlen($key) > $size)
            {
                $key = str_pad(pack($pack, $algo($key)), $size, chr(0x00));
            }
            else
            {
                $key = str_pad($key, $size, chr(0x00));
            }

            for ($i = 0; $i < strlen($key) - 1; $i++)
            {
                $opad[$i] = $opad[$i] ^ $key[$i];
                $ipad[$i] = $ipad[$i] ^ $key[$i];
            }

            $output = $algo($opad.pack($pack, $algo($ipad.$data)));

            return ($raw_output) ? pack($pack, $output) : $output;
        }
    }


    function Iso13239Crc16($buffer)
    // http://forum.yubico.com/viewtopic.php?f=2&t=69
    {
        $crc = 0xffff;
        for($loop=0; $loop<strlen($buffer); $loop++)
        {
            $crc ^= ord($buffer[$loop]) & 0xff;
            for ($bit=0; $bit<8; $bit++)
            {
                $j=$crc & 1;
                $crc >>= 1;
                if ($j)
                {
                    $crc ^= 0x8408;
                }
            }
        }
        return $crc;
    }


    function CheckYubicoOtp($yubico_modhex_encrypted_part,
                            $secret,
                            $last_count = -1)
    {
        $result = 99;

        $encrypted_part = hex2bin($this->ModHexToHex($yubico_modhex_encrypted_part));
        $cipher_aes = new Crypt_AES(CRYPT_AES_MODE_ECB);
        $cipher_aes->setKey((hex2bin($secret)));
        $cipher_aes->disablePadding();
        $decrypted_part = $cipher_aes->decrypt(($encrypted_part));
        unset($cipher_aes);

        $uid        = bin2hex(substr($decrypted_part,  0, 6));
        $useCtr     = ord($decrypted_part[6]) + 256 * ord($decrypted_part[7]);
        $tstp       = ord($decrypted_part[8]) + 256 * ord($decrypted_part[9]) + 65536 * ord($decrypted_part[10]);
        $sessionCtr = ord($decrypted_part[11]);
        $rnd        = ord($decrypted_part[12]) + 256 * ord($decrypted_part[13]);
        $crc        = ord($decrypted_part[14]) + 256 * ord($decrypted_part[15]);
        $check_crc  = $this->Iso13239Crc16($decrypted_part);

        // Based on information available here: http://www.yubico.com/wp-content/uploads/2013/07/YubiKey-Manual-v3_1.pdf
        //
        // $uid         Private ID
        // $useCtr      Usage counter, non-volatile counter, incremented when device is used after a power-up or reset
        // $tstp        Timestamp, 8Hz, random value startup, wraps from 0xffffff to 0 (after 24 days)
        // $sessionCtr  Session usage counter, set to 0 at power-up, incremented by one after each generation
        // $rnd         Random number
        // $crc         Checksum, 16-bit ISO13239 1st complement checksum of the first 14 bytes, result added to the end
        //                $crc = 0xffff - $this->Iso13239Crc16(substr($decrypted_part, 0, 14)); // One's complement
        // $check_crc   Calculate the ISO13239 of the 16 bits, should give a fixed residual of 0xf0b8 if checksum is valid

        if (0xf0b8 == $check_crc) // Check should always give 0xf0b8
        {
            $counter_position = ($useCtr * 256) + $sessionCtr;
            if ($counter_position <= $last_count)
            {
                $result = 26; // ERROR: this token has already been used
            }
            else
            {
                $this->_yubico_otp_last_count = $counter_position;
                $result = 0;
            }
        }
        return $result;
    }


    function GetYubicoOtpLastCount()
    {
        return $this->_yubico_otp_last_count;
    }


    function GetYubiCloudLastResponse()
    {
        return $this->_yubicloud_last_response;
    }


    function GetYubiCloudLastResult()
    {
        return $this->_yubicloud_last_result;
    }


    function CheckOnYubiCloud($otp_to_check)
    /**
     * Validation Protocol Version 2.0 is implemented
     *   (https://code.google.com/p/yubikey-val-server-php/wiki/ValidationProtocolV20)
     * Old validation Protocol Version 1.0 is not implemented anymore
     *   (https://code.google.com/p/yubikey-val-server-php/wiki/ValidationProtocolV10)
     */
    {
        $this->_yubicloud_last_response = array();
        $this->_yubicloud_last_result = 'NOT_ENOUGH_ANSWERS';
        $yubiotp = trim($otp_to_check);
        $result = 99;
        if ((44 == strlen($yubiotp)) && ($this->IsModHex($yubiotp)))
        {
            $yubicloud_servers = array('api.yubico.com/wsapi/2.0/verify',
                                       'api2.yubico.com/wsapi/2.0/verify',
                                       'api3.yubico.com/wsapi/2.0/verify',
                                       'api4.yubico.com/wsapi/2.0/verify',
                                       'api5.yubico.com/wsapi/2.0/verify');

            $yubicloud_parameters = array('id'        => $this->_yubicloud_client_id,
                                          'otp'       => $yubiotp,
                                          'timestamp' => 1,
                                          'nonce'     => md5(uniqid(rand())),
                                       /* 'sl'        => '', */ /* precentage of syncing not well documented */
                                          'timeout'   => $this->_yubicloud_timeout
                                         );

            // Parameters must be in the right order in order to calculate the hash
            ksort($yubicloud_parameters);

            $url_parameters = '';
            
            foreach($yubicloud_parameters as $key=>$value)
            {
                $url_parameters .= "&".$key."=".$value;
            }

            $url_parameters = substr($url_parameters, 1);
            
            if (28 == strlen($this->_yubicloud_secret_key))
            {
                $yubicloud_hash = urlencode(base64_encode($this->CalculateHashHmac('sha1',
                                                                                   $url_parameters,
                                                                                   base64_decode($this->_yubicloud_secret_key),
                                                                                   TRUE
                                                                                  )));
                $url_parameters.= '&h='.$yubicloud_hash;
            }
            
            foreach($yubicloud_servers as $one_yubicloud_server)
            {
                $yubicloud_answer = '';
                $yubicloud_url = $one_yubicloud_server.'?'.$url_parameters;
            
                $protocol = ''; // Default is http
                $port = 80;
                $pos = strpos($yubicloud_url, '://');
                if (FALSE !== $pos)
                {
                    switch (strtolower(substr($yubicloud_url,0,$pos)))
                    {
                        case 'https':
                        case 'ssl':
                            $protocol = 'ssl://';
                            $port = 443;
                            break;
                        case 'tls':
                            $protocol = 'tls://';
                            $port = 443;
                            break;
                    }
                    
                    $yubicloud_url = substr($yubicloud_url,$pos+3);
                }
                
                $pos = strpos($yubicloud_url, '/');
                if (FALSE === $pos)
                {
                    $host = $yubicloud_url;
                    $url = '/';
                }
                else
                {
                    $host = substr($yubicloud_url,0,$pos);
                    $url = substr($yubicloud_url,$pos); // And not +1 as we want the / at the beginning
                }
                
                $pos = strpos($host, ':');
                if (FALSE !== $pos)
                {
                    $port = substr($host,$pos+1);
                    $host = substr($host,0,$pos);
                }
                
                $errno = 0;
                $errdesc = 0;
                $fp = @fsockopen($protocol.$host, $port, $errno, $errdesc, $this->_yubicloud_timeout);
                if (FALSE !== $fp)
                {
                    $info['timed_out'] = FALSE;
                    fputs($fp, "GET ".$url." HTTP/1.0\r\n");
                    fputs($fp, "Content-Type: application/x-www-form-urlencoded\r\n");
                    // fputs($fp, "Content-Length: ".strlen($content_to_post)."\r\n");
                    fputs($fp, "User-Agent: multiOTP\r\n");
                    fputs($fp, "Host: ".$host."\r\n");
                    fputs($fp, "\r\n");
                    // fputs($fp, $content_to_post);
                    fputs($fp, "\r\n");

                    stream_set_blocking($fp, TRUE);
                    stream_set_timeout($fp, $this->_yubicloud_timeout);
                    $info = stream_get_meta_data($fp); 
            
                    $reply = '';
                    $last_length = 0;
                    while ((!feof($fp)) && ((!$info['timed_out']) || ($last_length != strlen($reply))))
                    {
                        $last_length = strlen($reply);
                        $reply.= fgets($fp, 1024);
                        $info = stream_get_meta_data($fp);
                        @ob_flush(); // Avoid notice if any (if the buffer is empty and therefore cannot be flushed)
                        flush(); 
                    }
                    fclose($fp);

                    if (!($info['timed_out']))
                    {
                        $pos = strpos(strtolower($reply), "\r\n\r\n");
                        $header = substr($reply, 0, $pos);
                        $yubicloud_response = substr($reply, $pos + 4);
                        
                        $yubicloud_response_array = explode("\r\n", trim($yubicloud_response));
                        
                        $response = array();

                        $response['now_utc'] = date ("U");

                        foreach($yubicloud_response_array as $one_yubicloud_response)
                        {
                            /* = is also used in BASE64 encoding so we only replace the first = by # which is not used in BASE64 */
                            list($key,$value) = explode('=', $one_yubicloud_response, 2);
                            $response[$key] = $value;
                        }
                                            
                        $yubicloud_response_parameters = array('otp',
                                                               'nonce',
                                                               't',
                                                               'status',
                                                               'timestamp',
                                                               'sessioncounter',
                                                               'sessionuse',
                                                               'sl'
                                                              );

                        // Parameters must be in the right order in order to calculate the hash
                        sort($yubicloud_response_parameters);
                        
                        if (isset($response['t']))
                        {
                            $response['t_utc'] = date_format(date_create(substr($response['t'], 0, -4)), "U");
                        }

                        $parameters_for_hash = '';
                        foreach ($yubicloud_response_parameters as $one_parameter)
                        {
                            if (array_key_exists($one_parameter, $response))
                            {
                                if ('' != $parameters_for_hash)
                                {
                                    $parameters_for_hash.= '&';
                                }
                                $parameters_for_hash.= $one_parameter.'='.$response[$one_parameter];
                            }
                        }

                        $this->_yubicloud_last_response = $response;

                        $check_response_hash = "NO-VALID-SECRET-KEY";
                        if (28 == strlen($this->_yubicloud_secret_key))
                        {
                            $check_response_hash = base64_encode($this->CalculateHashHmac('sha1',
                                                                                          $parameters_for_hash,
                                                                                          base64_decode($this->_yubicloud_secret_key),
                                                                                          TRUE
                                                                                         ));
                        }
                        if (($check_response_hash != $response['h']) && ("NO-VALID-SECRET-KEY" != $check_response_hash))
                        {
                            $this->_yubicloud_last_result = 'BAD_SIGNATURE';
                            $result = 99;
                        }
                        elseif ($yubicloud_parameters['nonce'] != $response['nonce'])
                        {
                            $this->_yubicloud_last_result = 'BAD_NONCE';
                            $result = 99;
                        }
                        elseif($yubiotp != $response['otp'])
                        {
                            $this->_yubicloud_last_result = 'OTP_IS_DIFFERENT';
                            $result = 99;
                        }
                        elseif ((($response['t_utc'] - $this->_yubicloud_max_time_window) > $response['now_utc']) ||
                                (($response['t_utc'] + $this->_yubicloud_max_time_window) < $response['now_utc'])
                               )
                        {
                            $this->_yubicloud_last_result = 'OUT_OF_TIME_WINDOW';
                            $result = 99;
                        }
                        else
                        {
                            $this->_yubicloud_last_result = $response['status'];

                            switch ($response['status'])
                            {
                                case 'OK':
                                    $result = 0;
                                    break;
                                case 'BAD_OTP':
                                    $result = 23;
                                    break;
                                case 'REPLAYED_OTP':
                                case 'REPLAYED_REQUEST':
                                    $result = 26;
                                    break;
                                case 'BAD_SIGNATURE':
                                case 'MISSING_PARAMETER':
                                case 'NO_SUCH_CLIENT':
                                case 'OPERATION_NOT_ALLOWED':
                                case 'BACKEND_ERROR':
                                case 'NOT_ENOUGH_ANSWERS':
                                default:
                                    $result = 99;
                            }
                        }
                        if (99 != $result)
                        {
                            break;
                        }
                    }
                }
            }
        }
        return $result;
    }


    function IsModHex($modhex)
    {
        $result = FALSE;
        if (0 == (strlen($modhex) % 2))
        {
            for ($loop = 0; $loop < strlen($modhex); $loop++)
            {
                $value = strpos($this->_yubico_modhex_chars, strtolower($modhex[$loop]));
                if (FALSE === $value)
                {
                    return FALSE;
                }
            }
            $result = TRUE;
        }
		return $result;		
    }


	function HexToModHex($hexa)
    {
        $result = '';
        if (0 == (strlen($hexa) % 2))
        {
            for ($loop = 0; $loop < strlen($hexa); $loop++)
            {
                $value = hexdec(strtolower($hexa[$loop]));
                if ($value > 15)
                {
                    return FALSE;
                }
                $result.= $this->_yubico_modhex_chars[$value];
            }
        }
        else
        {
            $result = FALSE;
        }
		return $result;		
	}
    
    
	function ModHexToHex($modhex)
    {
        $result = '';
        if (0 == (strlen($modhex) % 2))
        {
            for ($loop = 0; $loop < strlen($modhex); $loop++)
            {
                $value = strpos($this->_yubico_modhex_chars, strtolower($modhex[$loop]));
                if (FALSE === $value)
                {
                    return FALSE;
                }
                $result.= dechex($value);
            }
        }
        else
        {
            $result = FALSE;
        }
		return $result;		
	}
}

/*************************************
 * phpseclib 0.3.6 (MIT License)     *
 * MMVI Jim Wigginton                *
 * http://phpseclib.sourceforge.net/ *
 *************************************/
if (!function_exists('crypt_random_string')) {
    
/**
 * Random Number Generator
 *
 * The idea behind this function is that it can be easily replaced with your own crypt_random_string()
 * function. eg. maybe you have a better source of entropy for creating the initial states or whatever.
 *
 * PHP versions 4 and 5
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/Random.php';
 *
 *    echo bin2hex(crypt_random_string(8));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_Random
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

// laravel is a PHP framework that utilizes phpseclib. laravel workbenches may, independently,
// have phpseclib as a requirement as well. if you're developing such a program you may encounter
// a "Cannot redeclare crypt_random_string()" error.
if (!function_exists('crypt_random_string')) {
    /**
     * "Is Windows" test
     *
     * @access private
     */
    define('CRYPT_RANDOM_IS_WINDOWS', strtoupper(substr(PHP_OS, 0, 3)) === 'WIN');

    /**
     * Generate a random string.
     *
     * Although microoptimizations are generally discouraged as they impair readability this function is ripe with
     * microoptimizations because this function has the potential of being called a huge number of times.
     * eg. for RSA key generation.
     *
     * @param Integer $length
     * @return String
     * @access public
     */
    function crypt_random_string($length)
    {
        if (CRYPT_RANDOM_IS_WINDOWS) {
            // method 1. prior to PHP 5.3 this would call rand() on windows hence the function_exists('class_alias') call.
            // ie. class_alias is a function that was introduced in PHP 5.3
            if (function_exists('mcrypt_create_iv') && function_exists('class_alias')) {
                return mcrypt_create_iv($length);
            }
            // method 2. openssl_random_pseudo_bytes was introduced in PHP 5.3.0 but prior to PHP 5.3.4 there was,
            // to quote <http://php.net/ChangeLog-5.php#5.3.4>, "possible blocking behavior". as of 5.3.4
            // openssl_random_pseudo_bytes and mcrypt_create_iv do the exact same thing on Windows. ie. they both
            // call php_win32_get_random_bytes():
            //
            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/openssl/openssl.c#L5008
            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1392
            //
            // php_win32_get_random_bytes() is defined thusly:
            //
            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/win32/winutil.c#L80
            //
            // we're calling it, all the same, in the off chance that the mcrypt extension is not available
            if (function_exists('openssl_random_pseudo_bytes') && version_compare(PHP_VERSION, '5.3.4', '>=')) {
                return openssl_random_pseudo_bytes($length);
            }
        } else {
            // method 1. the fastest
            if (function_exists('openssl_random_pseudo_bytes')) {
                return openssl_random_pseudo_bytes($length);
            }
            // method 2
            static $fp = true;
            if ($fp === true) {
                // warning's will be output unles the error suppression operator is used. errors such as
                // "open_basedir restriction in effect", "Permission denied", "No such file or directory", etc.
                $fp = @fopen('/dev/urandom', 'rb');
            }
            if ($fp !== true && $fp !== false) { // surprisingly faster than !is_bool() or is_resource()
                return fread($fp, $length);
            }
            // method 3. pretty much does the same thing as method 2 per the following url:
            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1391
            // surprisingly slower than method 2. maybe that's because mcrypt_create_iv does a bunch of error checking that we're
            // not doing. regardless, this'll only be called if this PHP script couldn't open /dev/urandom due to open_basedir
            // restrictions or some such
            if (function_exists('mcrypt_create_iv')) {
                return mcrypt_create_iv($length, MCRYPT_DEV_URANDOM);
            }
        }
        // at this point we have no choice but to use a pure-PHP CSPRNG

        // cascade entropy across multiple PHP instances by fixing the session and collecting all
        // environmental variables, including the previous session data and the current session
        // data.
        //
        // mt_rand seeds itself by looking at the PID and the time, both of which are (relatively)
        // easy to guess at. linux uses mouse clicks, keyboard timings, etc, as entropy sources, but
        // PHP isn't low level to be able to use those as sources and on a web server there's not likely
        // going to be a ton of keyboard or mouse action. web servers do have one thing that we can use
        // however, a ton of people visiting the website. obviously you don't want to base your seeding
        // soley on parameters a potential attacker sends but (1) not everything in $_SERVER is controlled
        // by the user and (2) this isn't just looking at the data sent by the current user - it's based
        // on the data sent by all users. one user requests the page and a hash of their info is saved.
        // another user visits the page and the serialization of their data is utilized along with the
        // server envirnment stuff and a hash of the previous http request data (which itself utilizes
        // a hash of the session data before that). certainly an attacker should be assumed to have
        // full control over his own http requests. he, however, is not going to have control over
        // everyone's http requests.
        static $crypto = false, $v;
        if ($crypto === false) {
            // save old session data
            $old_session_id = session_id();
            $old_use_cookies = ini_get('session.use_cookies');
            $old_session_cache_limiter = session_cache_limiter();
            $_OLD_SESSION = isset($_SESSION) ? $_SESSION : false;
            if ($old_session_id != '') {
                session_write_close();
            }

            session_id(1);
            ini_set('session.use_cookies', 0);
            session_cache_limiter('');
            session_start();

            $v = $seed = $_SESSION['seed'] = pack('H*', sha1(
                serialize($_SERVER) .
                serialize($_POST) .
                serialize($_GET) .
                serialize($_COOKIE) .
                serialize($GLOBALS) .
                serialize($_SESSION) .
                serialize($_OLD_SESSION)
            ));
            if (!isset($_SESSION['count'])) {
                $_SESSION['count'] = 0;
            }
            $_SESSION['count']++;

            session_write_close();

            // restore old session data
            if ($old_session_id != '') {
                session_id($old_session_id);
                session_start();
                ini_set('session.use_cookies', $old_use_cookies);
                session_cache_limiter($old_session_cache_limiter);
            } else {
               if ($_OLD_SESSION !== false) {
                   $_SESSION = $_OLD_SESSION;
                   unset($_OLD_SESSION);
                } else {
                    unset($_SESSION);
                }
            }

            // in SSH2 a shared secret and an exchange hash are generated through the key exchange process.
            // the IV client to server is the hash of that "nonce" with the letter A and for the encryption key it's the letter C.
            // if the hash doesn't produce enough a key or an IV that's long enough concat successive hashes of the
            // original hash and the current hash. we'll be emulating that. for more info see the following URL:
            //
            // http://tools.ietf.org/html/rfc4253#section-7.2
            //
            // see the is_string($crypto) part for an example of how to expand the keys
            $key = pack('H*', sha1($seed . 'A'));
            $iv = pack('H*', sha1($seed . 'C'));

            // ciphers are used as per the nist.gov link below. also, see this link:
            //
            // http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Designs_based_on_cryptographic_primitives
            switch (true) {
                case phpseclib_resolve_include_path('Crypt/AES.php'):
                    if (!class_exists('Crypt_AES')) {
                        include_once 'AES.php';
                    }
                    $crypto = new Crypt_AES(CRYPT_AES_MODE_CTR);
                    break;
                case phpseclib_resolve_include_path('Crypt/Twofish.php'):
                    if (!class_exists('Crypt_Twofish')) {
                        include_once 'Twofish.php';
                    }
                    $crypto = new Crypt_Twofish(CRYPT_TWOFISH_MODE_CTR);
                    break;
                case phpseclib_resolve_include_path('Crypt/Blowfish.php'):
                    if (!class_exists('Crypt_Blowfish')) {
                        include_once 'Blowfish.php';
                    }
                    $crypto = new Crypt_Blowfish(CRYPT_BLOWFISH_MODE_CTR);
                    break;
                case phpseclib_resolve_include_path('Crypt/TripleDES.php'):
                    if (!class_exists('Crypt_TripleDES')) {
                        include_once 'TripleDES.php';
                    }
                    $crypto = new Crypt_TripleDES(CRYPT_DES_MODE_CTR);
                    break;
                case phpseclib_resolve_include_path('Crypt/DES.php'):
                    if (!class_exists('Crypt_DES')) {
                        include_once 'DES.php';
                    }
                    $crypto = new Crypt_DES(CRYPT_DES_MODE_CTR);
                    break;
                case phpseclib_resolve_include_path('Crypt/RC4.php'):
                    if (!class_exists('Crypt_RC4')) {
                        include_once 'RC4.php';
                    }
                    $crypto = new Crypt_RC4();
                    break;
                default:
                    user_error('crypt_random_string requires at least one symmetric cipher be loaded');
                    return false;
            }

            $crypto->setKey($key);
            $crypto->setIV($iv);
            $crypto->enableContinuousBuffer();
        }

        //return $crypto->encrypt(str_repeat("\0", $length));

        // the following is based off of ANSI X9.31:
        //
        // http://csrc.nist.gov/groups/STM/cavp/documents/rng/931rngext.pdf
        //
        // OpenSSL uses that same standard for it's random numbers:
        //
        // http://www.opensource.apple.com/source/OpenSSL/OpenSSL-38/openssl/fips-1.0/rand/fips_rand.c
        // (do a search for "ANS X9.31 A.2.4")
        $result = '';
        while (strlen($result) < $length) {
            $i = $crypto->encrypt(microtime()); // strlen(microtime()) == 21
            $r = $crypto->encrypt($i ^ $v); // strlen($v) == 20
            $v = $crypto->encrypt($r ^ $i); // strlen($r) == 20
            $result.= $r;
        }
        return substr($result, 0, $length);
    }
}

if (!function_exists('phpseclib_resolve_include_path')) {
    /**
     * Resolve filename against the include path.
     *
     * Wrapper around stream_resolve_include_path() (which was introduced in
     * PHP 5.3.2) with fallback implementation for earlier PHP versions.
     *
     * @param string $filename
     * @return mixed Filename (string) on success, false otherwise.
     * @access public
     */
    function phpseclib_resolve_include_path($filename)
    {
        if (function_exists('stream_resolve_include_path')) {
            return stream_resolve_include_path($filename);
        }

        // handle non-relative paths
        if (file_exists($filename)) {
            return realpath($filename);
        }

        $paths = PATH_SEPARATOR == ':' ?
            preg_split('#(?<!phar):#', get_include_path()) :
            explode(PATH_SEPARATOR, get_include_path());
        foreach ($paths as $prefix) {
            // path's specified in include_path don't always end in /
            $ds = substr($prefix, -1) == DIRECTORY_SEPARATOR ? '' : DIRECTORY_SEPARATOR;
            $file = $prefix . $ds . $filename;
            if (file_exists($file)) {
                return realpath($file);
            }
        }

        return false;
    }
}

}
if (!class_exists('Math_BigInteger')) {
    
/**
 * Pure-PHP arbitrary precision integer arithmetic library.
 *
 * Supports base-2, base-10, base-16, and base-256 numbers.  Uses the GMP or BCMath extensions, if available,
 * and an internal implementation, otherwise.
 *
 * PHP versions 4 and 5
 *
 * {@internal (all DocBlock comments regarding implementation - such as the one that follows - refer to the
 * {@link MATH_BIGINTEGER_MODE_INTERNAL MATH_BIGINTEGER_MODE_INTERNAL} mode)
 *
 * Math_BigInteger uses base-2**26 to perform operations such as multiplication and division and
 * base-2**52 (ie. two base 2**26 digits) to perform addition and subtraction.  Because the largest possible
 * value when multiplying two base-2**26 numbers together is a base-2**52 number, double precision floating
 * point numbers - numbers that should be supported on most hardware and whose significand is 53 bits - are
 * used.  As a consequence, bitwise operators such as >> and << cannot be used, nor can the modulo operator %,
 * which only supports integers.  Although this fact will slow this library down, the fact that such a high
 * base is being used should more than compensate.
 *
 * Numbers are stored in {@link http://en.wikipedia.org/wiki/Endianness little endian} format.  ie.
 * (new Math_BigInteger(pow(2, 26)))->value = array(0, 1)
 *
 * Useful resources are as follows:
 *
 *  - {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf Handbook of Applied Cryptography (HAC)}
 *  - {@link http://math.libtomcrypt.com/files/tommath.pdf Multi-Precision Math (MPM)}
 *  - Java's BigInteger classes.  See /j2se/src/share/classes/java/math in jdk-1_5_0-src-jrl.zip
 *
 * Here's an example of how to use this library:
 * <code>
 *  *    include 'Math/BigInteger.php';
 *
 *    $a = new Math_BigInteger(2);
 *    $b = new Math_BigInteger(3);
 *
 *    $c = $a->add($b);
 *
 *    echo $c->toString(); // outputs 5
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Math
 * @package   Math_BigInteger
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVI Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://pear.php.net/package/Math_BigInteger
 */

/**#@+
 * Reduction constants
 *
 * @access private
 * @see Math_BigInteger::_reduce()
 */
/**
 * @see Math_BigInteger::_montgomery()
 * @see Math_BigInteger::_prepMontgomery()
 */
define('MATH_BIGINTEGER_MONTGOMERY', 0);
/**
 * @see Math_BigInteger::_barrett()
 */
define('MATH_BIGINTEGER_BARRETT', 1);
/**
 * @see Math_BigInteger::_mod2()
 */
define('MATH_BIGINTEGER_POWEROF2', 2);
/**
 * @see Math_BigInteger::_remainder()
 */
define('MATH_BIGINTEGER_CLASSIC', 3);
/**
 * @see Math_BigInteger::__clone()
 */
define('MATH_BIGINTEGER_NONE', 4);
/**#@-*/

/**#@+
 * Array constants
 *
 * Rather than create a thousands and thousands of new Math_BigInteger objects in repeated function calls to add() and
 * multiply() or whatever, we'll just work directly on arrays, taking them in as parameters and returning them.
 *
 * @access private
 */
/**
 * $result[MATH_BIGINTEGER_VALUE] contains the value.
 */
define('MATH_BIGINTEGER_VALUE', 0);
/**
 * $result[MATH_BIGINTEGER_SIGN] contains the sign.
 */
define('MATH_BIGINTEGER_SIGN', 1);
/**#@-*/

/**#@+
 * @access private
 * @see Math_BigInteger::_montgomery()
 * @see Math_BigInteger::_barrett()
 */
/**
 * Cache constants
 *
 * $cache[MATH_BIGINTEGER_VARIABLE] tells us whether or not the cached data is still valid.
 */
define('MATH_BIGINTEGER_VARIABLE', 0);
/**
 * $cache[MATH_BIGINTEGER_DATA] contains the cached data.
 */
define('MATH_BIGINTEGER_DATA', 1);
/**#@-*/

/**#@+
 * Mode constants.
 *
 * @access private
 * @see Math_BigInteger::Math_BigInteger()
 */
/**
 * To use the pure-PHP implementation
 */
define('MATH_BIGINTEGER_MODE_INTERNAL', 1);
/**
 * To use the BCMath library
 *
 * (if enabled; otherwise, the internal implementation will be used)
 */
define('MATH_BIGINTEGER_MODE_BCMATH', 2);
/**
 * To use the GMP library
 *
 * (if present; otherwise, either the BCMath or the internal implementation will be used)
 */
define('MATH_BIGINTEGER_MODE_GMP', 3);
/**#@-*/

/**
 * Karatsuba Cutoff
 *
 * At what point do we switch between Karatsuba multiplication and schoolbook long multiplication?
 *
 * @access private
 */
define('MATH_BIGINTEGER_KARATSUBA_CUTOFF', 25);

/**
 * Pure-PHP arbitrary precision integer arithmetic library. Supports base-2, base-10, base-16, and base-256
 * numbers.
 *
 * @package Math_BigInteger
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Math_BigInteger
{
    /**
     * Holds the BigInteger's value.
     *
     * @var Array
     * @access private
     */
    var $value;

    /**
     * Holds the BigInteger's magnitude.
     *
     * @var Boolean
     * @access private
     */
    var $is_negative = false;

    /**
     * Random number generator function
     *
     * @see setRandomGenerator()
     * @access private
     */
    var $generator = 'mt_rand';

    /**
     * Precision
     *
     * @see setPrecision()
     * @access private
     */
    var $precision = -1;

    /**
     * Precision Bitmask
     *
     * @see setPrecision()
     * @access private
     */
    var $bitmask = false;

    /**
     * Mode independent value used for serialization.
     *
     * If the bcmath or gmp extensions are installed $this->value will be a non-serializable resource, hence the need for
     * a variable that'll be serializable regardless of whether or not extensions are being used.  Unlike $this->value,
     * however, $this->hex is only calculated when $this->__sleep() is called.
     *
     * @see __sleep()
     * @see __wakeup()
     * @var String
     * @access private
     */
    var $hex;

    /**
     * Converts base-2, base-10, base-16, and binary strings (base-256) to BigIntegers.
     *
     * If the second parameter - $base - is negative, then it will be assumed that the number's are encoded using
     * two's compliment.  The sole exception to this is -10, which is treated the same as 10 is.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('0x32', 16); // 50 in base-16
     *
     *    echo $a->toString(); // outputs 50
     *      * </code>
     *
     * @param optional $x base-10 number or base-$base number if $base set.
     * @param optional integer $base
     * @return Math_BigInteger
     * @access public
     */
    function Math_BigInteger($x = 0, $base = 10)
    {
        if ( !defined('MATH_BIGINTEGER_MODE') ) {
            switch (true) {
                case extension_loaded('gmp'):
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_GMP);
                    break;
                case extension_loaded('bcmath'):
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_BCMATH);
                    break;
                default:
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_INTERNAL);
            }
        }

        if (function_exists('openssl_public_encrypt') && !defined('MATH_BIGINTEGER_OPENSSL_DISABLE') && !defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
            // some versions of XAMPP have mismatched versions of OpenSSL which causes it not to work
            ob_start();
            @phpinfo();
            $content = ob_get_contents();
            ob_end_clean();

            preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);

            $versions = array();
            if (!empty($matches[1])) {
                for ($i = 0; $i < count($matches[1]); $i++) {
                    $versions[$matches[1][$i]] = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
                }
            }

            // it doesn't appear that OpenSSL versions were reported upon until PHP 5.3+
            switch (true) {
                case !isset($versions['Header']):
                case !isset($versions['Library']):
                case $versions['Header'] == $versions['Library']:
                    define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);
                    break;
                default:
                    define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
            }
        }

        if (!defined('PHP_INT_SIZE')) {
            define('PHP_INT_SIZE', 4);
        }

        if (!defined('MATH_BIGINTEGER_BASE') && MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_INTERNAL) {
            switch (PHP_INT_SIZE) {
                case 8: // use 64-bit integers if int size is 8 bytes
                    define('MATH_BIGINTEGER_BASE',       31);
                    define('MATH_BIGINTEGER_BASE_FULL',  0x80000000);
                    define('MATH_BIGINTEGER_MAX_DIGIT',  0x7FFFFFFF);
                    define('MATH_BIGINTEGER_MSB',        0x40000000);
                    // 10**9 is the closest we can get to 2**31 without passing it
                    define('MATH_BIGINTEGER_MAX10',      1000000000);
                    define('MATH_BIGINTEGER_MAX10_LEN',  9);
                    // the largest digit that may be used in addition / subtraction
                    define('MATH_BIGINTEGER_MAX_DIGIT2', pow(2, 62));
                    break;
                //case 4: // use 64-bit floats if int size is 4 bytes
                default:
                    define('MATH_BIGINTEGER_BASE',       26);
                    define('MATH_BIGINTEGER_BASE_FULL',  0x4000000);
                    define('MATH_BIGINTEGER_MAX_DIGIT',  0x3FFFFFF);
                    define('MATH_BIGINTEGER_MSB',        0x2000000);
                    // 10**7 is the closest to 2**26 without passing it
                    define('MATH_BIGINTEGER_MAX10',      10000000);
                    define('MATH_BIGINTEGER_MAX10_LEN',  7);
                    // the largest digit that may be used in addition / subtraction
                    // we do pow(2, 52) instead of using 4503599627370496 directly because some
                    // PHP installations will truncate 4503599627370496.
                    define('MATH_BIGINTEGER_MAX_DIGIT2', pow(2, 52));
            }
        }

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (is_resource($x) && get_resource_type($x) == 'GMP integer') {
                    $this->value = $x;
                    return;
                }
                $this->value = gmp_init(0);
                break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $this->value = '0';
                break;
            default:
                $this->value = array();
        }

        // '0' counts as empty() but when the base is 256 '0' is equal to ord('0') or 48
        // '0' is the only value like this per http://php.net/empty
        if (empty($x) && (abs($base) != 256 || $x !== '0')) {
            return;
        }

        switch ($base) {
            case -256:
                if (ord($x[0]) & 0x80) {
                    $x = ~$x;
                    $this->is_negative = true;
                }
            case  256:
                switch ( MATH_BIGINTEGER_MODE ) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $sign = $this->is_negative ? '-' : '';
                        $this->value = gmp_init($sign . '0x' . bin2hex($x));
                        break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        // round $len to the nearest 4 (thanks, DavidMJ!)
                        $len = (strlen($x) + 3) & 0xFFFFFFFC;

                        $x = str_pad($x, $len, chr(0), STR_PAD_LEFT);

                        for ($i = 0; $i < $len; $i+= 4) {
                            $this->value = bcmul($this->value, '4294967296', 0); // 4294967296 == 2**32
                            $this->value = bcadd($this->value, 0x1000000 * ord($x[$i]) + ((ord($x[$i + 1]) << 16) | (ord($x[$i + 2]) << 8) | ord($x[$i + 3])), 0);
                        }

                        if ($this->is_negative) {
                            $this->value = '-' . $this->value;
                        }

                        break;
                    // converts a base-2**8 (big endian / msb) number to base-2**26 (little endian / lsb)
                    default:
                        while (strlen($x)) {
                            $this->value[] = $this->_bytes2int($this->_base256_rshift($x, MATH_BIGINTEGER_BASE));
                        }
                }

                if ($this->is_negative) {
                    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
                        $this->is_negative = false;
                    }
                    $temp = $this->add(new Math_BigInteger('-1'));
                    $this->value = $temp->value;
                }
                break;
            case  16:
            case -16:
                if ($base > 0 && $x[0] == '-') {
                    $this->is_negative = true;
                    $x = substr($x, 1);
                }

                $x = preg_replace('#^(?:0x)?([A-Fa-f0-9]*).*#', '$1', $x);

                $is_negative = false;
                if ($base < 0 && hexdec($x[0]) >= 8) {
                    $this->is_negative = $is_negative = true;
                    $x = bin2hex(~pack('H*', $x));
                }

                switch ( MATH_BIGINTEGER_MODE ) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $temp = $this->is_negative ? '-0x' . $x : '0x' . $x;
                        $this->value = gmp_init($temp);
                        $this->is_negative = false;
                        break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $x = ( strlen($x) & 1 ) ? '0' . $x : $x;
                        $temp = new Math_BigInteger(pack('H*', $x), 256);
                        $this->value = $this->is_negative ? '-' . $temp->value : $temp->value;
                        $this->is_negative = false;
                        break;
                    default:
                        $x = ( strlen($x) & 1 ) ? '0' . $x : $x;
                        $temp = new Math_BigInteger(pack('H*', $x), 256);
                        $this->value = $temp->value;
                }

                if ($is_negative) {
                    $temp = $this->add(new Math_BigInteger('-1'));
                    $this->value = $temp->value;
                }
                break;
            case  10:
            case -10:
                // (?<!^)(?:-).*: find any -'s that aren't at the beginning and then any characters that follow that
                // (?<=^|-)0*: find any 0's that are preceded by the start of the string or by a - (ie. octals)
                // [^-0-9].*: find any non-numeric characters and then any characters that follow that
                $x = preg_replace('#(?<!^)(?:-).*|(?<=^|-)0*|[^-0-9].*#', '', $x);

                switch ( MATH_BIGINTEGER_MODE ) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = gmp_init($x);
                        break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        // explicitly casting $x to a string is necessary, here, since doing $x[0] on -1 yields different
                        // results then doing it on '-1' does (modInverse does $x[0])
                        $this->value = $x === '-' ? '0' : (string) $x;
                        break;
                    default:
                        $temp = new Math_BigInteger();

                        $multiplier = new Math_BigInteger();
                        $multiplier->value = array(MATH_BIGINTEGER_MAX10);

                        if ($x[0] == '-') {
                            $this->is_negative = true;
                            $x = substr($x, 1);
                        }

                        $x = str_pad($x, strlen($x) + ((MATH_BIGINTEGER_MAX10_LEN - 1) * strlen($x)) % MATH_BIGINTEGER_MAX10_LEN, 0, STR_PAD_LEFT);
                        while (strlen($x)) {
                            $temp = $temp->multiply($multiplier);
                            $temp = $temp->add(new Math_BigInteger($this->_int2bytes(substr($x, 0, MATH_BIGINTEGER_MAX10_LEN)), 256));
                            $x = substr($x, MATH_BIGINTEGER_MAX10_LEN);
                        }

                        $this->value = $temp->value;
                }
                break;
            case  2: // base-2 support originally implemented by Lluis Pamies - thanks!
            case -2:
                if ($base > 0 && $x[0] == '-') {
                    $this->is_negative = true;
                    $x = substr($x, 1);
                }

                $x = preg_replace('#^([01]*).*#', '$1', $x);
                $x = str_pad($x, strlen($x) + (3 * strlen($x)) % 4, 0, STR_PAD_LEFT);

                $str = '0x';
                while (strlen($x)) {
                    $part = substr($x, 0, 4);
                    $str.= dechex(bindec($part));
                    $x = substr($x, 4);
                }

                if ($this->is_negative) {
                    $str = '-' . $str;
                }

                $temp = new Math_BigInteger($str, 8 * $base); // ie. either -16 or +16
                $this->value = $temp->value;
                $this->is_negative = $temp->is_negative;

                break;
            default:
                // base not supported, so we'll let $this == 0
        }
    }

    /**
     * Converts a BigInteger to a byte string (eg. base-256).
     *
     * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
     * saved as two's compliment.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('65');
     *
     *    echo $a->toBytes(); // outputs chr(65)
     *      * </code>
     *
     * @param Boolean $twos_compliment
     * @return String
     * @access public
     * @internal Converts a base-2**26 number to base-2**8
     */
    function toBytes($twos_compliment = false)
    {
        if ($twos_compliment) {
            $comparison = $this->compare(new Math_BigInteger());
            if ($comparison == 0) {
                return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
            }

            $temp = $comparison < 0 ? $this->add(new Math_BigInteger(1)) : $this->copy();
            $bytes = $temp->toBytes();

            if (empty($bytes)) { // eg. if the number we're trying to convert is -1
                $bytes = chr(0);
            }

            if (ord($bytes[0]) & 0x80) {
                $bytes = chr(0) . $bytes;
            }

            return $comparison < 0 ? ~$bytes : $bytes;
        }

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (gmp_cmp($this->value, gmp_init(0)) == 0) {
                    return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
                }

                $temp = gmp_strval(gmp_abs($this->value), 16);
                $temp = ( strlen($temp) & 1 ) ? '0' . $temp : $temp;
                $temp = pack('H*', $temp);

                return $this->precision > 0 ?
                    substr(str_pad($temp, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) :
                    ltrim($temp, chr(0));
            case MATH_BIGINTEGER_MODE_BCMATH:
                if ($this->value === '0') {
                    return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
                }

                $value = '';
                $current = $this->value;

                if ($current[0] == '-') {
                    $current = substr($current, 1);
                }

                while (bccomp($current, '0', 0) > 0) {
                    $temp = bcmod($current, '16777216');
                    $value = chr($temp >> 16) . chr($temp >> 8) . chr($temp) . $value;
                    $current = bcdiv($current, '16777216', 0);
                }

                return $this->precision > 0 ?
                    substr(str_pad($value, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) :
                    ltrim($value, chr(0));
        }

        if (!count($this->value)) {
            return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
        }
        $result = $this->_int2bytes($this->value[count($this->value) - 1]);

        $temp = $this->copy();

        for ($i = count($temp->value) - 2; $i >= 0; --$i) {
            $temp->_base256_lshift($result, MATH_BIGINTEGER_BASE);
            $result = $result | str_pad($temp->_int2bytes($temp->value[$i]), strlen($result), chr(0), STR_PAD_LEFT);
        }

        return $this->precision > 0 ?
            str_pad(substr($result, -(($this->precision + 7) >> 3)), ($this->precision + 7) >> 3, chr(0), STR_PAD_LEFT) :
            $result;
    }

    /**
     * Converts a BigInteger to a hex string (eg. base-16)).
     *
     * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
     * saved as two's compliment.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('65');
     *
     *    echo $a->toHex(); // outputs '41'
     *      * </code>
     *
     * @param Boolean $twos_compliment
     * @return String
     * @access public
     * @internal Converts a base-2**26 number to base-2**8
     */
    function toHex($twos_compliment = false)
    {
        return bin2hex($this->toBytes($twos_compliment));
    }

    /**
     * Converts a BigInteger to a bit string (eg. base-2).
     *
     * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
     * saved as two's compliment.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('65');
     *
     *    echo $a->toBits(); // outputs '1000001'
     *      * </code>
     *
     * @param Boolean $twos_compliment
     * @return String
     * @access public
     * @internal Converts a base-2**26 number to base-2**2
     */
    function toBits($twos_compliment = false)
    {
        $hex = $this->toHex($twos_compliment);
        $bits = '';
        for ($i = strlen($hex) - 8, $start = strlen($hex) & 7; $i >= $start; $i-=8) {
            $bits = str_pad(decbin(hexdec(substr($hex, $i, 8))), 32, '0', STR_PAD_LEFT) . $bits;
        }
        if ($start) { // hexdec('') == 0
            $bits = str_pad(decbin(hexdec(substr($hex, 0, $start))), 8, '0', STR_PAD_LEFT) . $bits;
        }
        $result = $this->precision > 0 ? substr($bits, -$this->precision) : ltrim($bits, '0');

        if ($twos_compliment && $this->compare(new Math_BigInteger()) > 0 && $this->precision <= 0) {
            return '0' . $result;
        }

        return $result;
    }

    /**
     * Converts a BigInteger to a base-10 number.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('50');
     *
     *    echo $a->toString(); // outputs 50
     *      * </code>
     *
     * @return String
     * @access public
     * @internal Converts a base-2**26 number to base-10**7 (which is pretty much base-10)
     */
    function toString()
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_strval($this->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                if ($this->value === '0') {
                    return '0';
                }

                return ltrim($this->value, '0');
        }

        if (!count($this->value)) {
            return '0';
        }

        $temp = $this->copy();
        $temp->is_negative = false;

        $divisor = new Math_BigInteger();
        $divisor->value = array(MATH_BIGINTEGER_MAX10);
        $result = '';
        while (count($temp->value)) {
            list($temp, $mod) = $temp->divide($divisor);
            $result = str_pad(isset($mod->value[0]) ? $mod->value[0] : '', MATH_BIGINTEGER_MAX10_LEN, '0', STR_PAD_LEFT) . $result;
        }
        $result = ltrim($result, '0');
        if (empty($result)) {
            $result = '0';
        }

        if ($this->is_negative) {
            $result = '-' . $result;
        }

        return $result;
    }

    /**
     * Copy an object
     *
     * PHP5 passes objects by reference while PHP4 passes by value.  As such, we need a function to guarantee
     * that all objects are passed by value, when appropriate.  More information can be found here:
     *
     * {@link http://php.net/language.oop5.basic#51624}
     *
     * @access public
     * @see __clone()
     * @return Math_BigInteger
     */
    function copy()
    {
        $temp = new Math_BigInteger();
        $temp->value = $this->value;
        $temp->is_negative = $this->is_negative;
        $temp->generator = $this->generator;
        $temp->precision = $this->precision;
        $temp->bitmask = $this->bitmask;
        return $temp;
    }

    /**
     *  __toString() magic method
     *
     * Will be called, automatically, if you're supporting just PHP5.  If you're supporting PHP4, you'll need to call
     * toString().
     *
     * @access public
     * @internal Implemented per a suggestion by Techie-Michael - thanks!
     */
    function __toString()
    {
        return $this->toString();
    }

    /**
     * __clone() magic method
     *
     * Although you can call Math_BigInteger::__toString() directly in PHP5, you cannot call Math_BigInteger::__clone()
     * directly in PHP5.  You can in PHP4 since it's not a magic method, but in PHP5, you have to call it by using the PHP5
     * only syntax of $y = clone $x.  As such, if you're trying to write an application that works on both PHP4 and PHP5,
     * call Math_BigInteger::copy(), instead.
     *
     * @access public
     * @see copy()
     * @return Math_BigInteger
     */
    function __clone()
    {
        return $this->copy();
    }

    /**
     *  __sleep() magic method
     *
     * Will be called, automatically, when serialize() is called on a Math_BigInteger object.
     *
     * @see __wakeup()
     * @access public
     */
    function __sleep()
    {
        $this->hex = $this->toHex(true);
        $vars = array('hex');
        if ($this->generator != 'mt_rand') {
            $vars[] = 'generator';
        }
        if ($this->precision > 0) {
            $vars[] = 'precision';
        }
        return $vars;

    }

    /**
     *  __wakeup() magic method
     *
     * Will be called, automatically, when unserialize() is called on a Math_BigInteger object.
     *
     * @see __sleep()
     * @access public
     */
    function __wakeup()
    {
        $temp = new Math_BigInteger($this->hex, -16);
        $this->value = $temp->value;
        $this->is_negative = $temp->is_negative;
        $this->setRandomGenerator($this->generator);
        if ($this->precision > 0) {
            // recalculate $this->bitmask
            $this->setPrecision($this->precision);
        }
    }

    /**
     * Adds two BigIntegers.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('10');
     *    $b = new Math_BigInteger('20');
     *
     *    $c = $a->add($b);
     *
     *    echo $c->toString(); // outputs 30
     *      * </code>
     *
     * @param Math_BigInteger $y
     * @return Math_BigInteger
     * @access public
     * @internal Performs base-2**52 addition
     */
    function add($y)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_add($this->value, $y->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp = new Math_BigInteger();
                $temp->value = bcadd($this->value, $y->value, 0);

                return $this->_normalize($temp);
        }

        $temp = $this->_add($this->value, $this->is_negative, $y->value, $y->is_negative);

        $result = new Math_BigInteger();
        $result->value = $temp[MATH_BIGINTEGER_VALUE];
        $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];

        return $this->_normalize($result);
    }

    /**
     * Performs addition.
     *
     * @param Array $x_value
     * @param Boolean $x_negative
     * @param Array $y_value
     * @param Boolean $y_negative
     * @return Array
     * @access private
     */
    function _add($x_value, $x_negative, $y_value, $y_negative)
    {
        $x_size = count($x_value);
        $y_size = count($y_value);

        if ($x_size == 0) {
            return array(
                MATH_BIGINTEGER_VALUE => $y_value,
                MATH_BIGINTEGER_SIGN => $y_negative
            );
        } else if ($y_size == 0) {
            return array(
                MATH_BIGINTEGER_VALUE => $x_value,
                MATH_BIGINTEGER_SIGN => $x_negative
            );
        }

        // subtract, if appropriate
        if ( $x_negative != $y_negative ) {
            if ( $x_value == $y_value ) {
                return array(
                    MATH_BIGINTEGER_VALUE => array(),
                    MATH_BIGINTEGER_SIGN => false
                );
            }

            $temp = $this->_subtract($x_value, false, $y_value, false);
            $temp[MATH_BIGINTEGER_SIGN] = $this->_compare($x_value, false, $y_value, false) > 0 ?
                                          $x_negative : $y_negative;

            return $temp;
        }

        if ($x_size < $y_size) {
            $size = $x_size;
            $value = $y_value;
        } else {
            $size = $y_size;
            $value = $x_value;
        }

        $value[] = 0; // just in case the carry adds an extra digit

        $carry = 0;
        for ($i = 0, $j = 1; $j < $size; $i+=2, $j+=2) {
            $sum = $x_value[$j] * MATH_BIGINTEGER_BASE_FULL + $x_value[$i] + $y_value[$j] * MATH_BIGINTEGER_BASE_FULL + $y_value[$i] + $carry;
            $carry = $sum >= MATH_BIGINTEGER_MAX_DIGIT2; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
            $sum = $carry ? $sum - MATH_BIGINTEGER_MAX_DIGIT2 : $sum;

            $temp = MATH_BIGINTEGER_BASE === 26 ? intval($sum / 0x4000000) : ($sum >> 31);

            $value[$i] = (int) ($sum - MATH_BIGINTEGER_BASE_FULL * $temp); // eg. a faster alternative to fmod($sum, 0x4000000)
            $value[$j] = $temp;
        }

        if ($j == $size) { // ie. if $y_size is odd
            $sum = $x_value[$i] + $y_value[$i] + $carry;
            $carry = $sum >= MATH_BIGINTEGER_BASE_FULL;
            $value[$i] = $carry ? $sum - MATH_BIGINTEGER_BASE_FULL : $sum;
            ++$i; // ie. let $i = $j since we've just done $value[$i]
        }

        if ($carry) {
            for (; $value[$i] == MATH_BIGINTEGER_MAX_DIGIT; ++$i) {
                $value[$i] = 0;
            }
            ++$value[$i];
        }

        return array(
            MATH_BIGINTEGER_VALUE => $this->_trim($value),
            MATH_BIGINTEGER_SIGN => $x_negative
        );
    }

    /**
     * Subtracts two BigIntegers.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('10');
     *    $b = new Math_BigInteger('20');
     *
     *    $c = $a->subtract($b);
     *
     *    echo $c->toString(); // outputs -10
     *      * </code>
     *
     * @param Math_BigInteger $y
     * @return Math_BigInteger
     * @access public
     * @internal Performs base-2**52 subtraction
     */
    function subtract($y)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_sub($this->value, $y->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp = new Math_BigInteger();
                $temp->value = bcsub($this->value, $y->value, 0);

                return $this->_normalize($temp);
        }

        $temp = $this->_subtract($this->value, $this->is_negative, $y->value, $y->is_negative);

        $result = new Math_BigInteger();
        $result->value = $temp[MATH_BIGINTEGER_VALUE];
        $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];

        return $this->_normalize($result);
    }

    /**
     * Performs subtraction.
     *
     * @param Array $x_value
     * @param Boolean $x_negative
     * @param Array $y_value
     * @param Boolean $y_negative
     * @return Array
     * @access private
     */
    function _subtract($x_value, $x_negative, $y_value, $y_negative)
    {
        $x_size = count($x_value);
        $y_size = count($y_value);

        if ($x_size == 0) {
            return array(
                MATH_BIGINTEGER_VALUE => $y_value,
                MATH_BIGINTEGER_SIGN => !$y_negative
            );
        } else if ($y_size == 0) {
            return array(
                MATH_BIGINTEGER_VALUE => $x_value,
                MATH_BIGINTEGER_SIGN => $x_negative
            );
        }

        // add, if appropriate (ie. -$x - +$y or +$x - -$y)
        if ( $x_negative != $y_negative ) {
            $temp = $this->_add($x_value, false, $y_value, false);
            $temp[MATH_BIGINTEGER_SIGN] = $x_negative;

            return $temp;
        }

        $diff = $this->_compare($x_value, $x_negative, $y_value, $y_negative);

        if ( !$diff ) {
            return array(
                MATH_BIGINTEGER_VALUE => array(),
                MATH_BIGINTEGER_SIGN => false
            );
        }

        // switch $x and $y around, if appropriate.
        if ( (!$x_negative && $diff < 0) || ($x_negative && $diff > 0) ) {
            $temp = $x_value;
            $x_value = $y_value;
            $y_value = $temp;

            $x_negative = !$x_negative;

            $x_size = count($x_value);
            $y_size = count($y_value);
        }

        // at this point, $x_value should be at least as big as - if not bigger than - $y_value

        $carry = 0;
        for ($i = 0, $j = 1; $j < $y_size; $i+=2, $j+=2) {
            $sum = $x_value[$j] * MATH_BIGINTEGER_BASE_FULL + $x_value[$i] - $y_value[$j] * MATH_BIGINTEGER_BASE_FULL - $y_value[$i] - $carry;
            $carry = $sum < 0; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
            $sum = $carry ? $sum + MATH_BIGINTEGER_MAX_DIGIT2 : $sum;

            $temp = MATH_BIGINTEGER_BASE === 26 ? intval($sum / 0x4000000) : ($sum >> 31);

            $x_value[$i] = (int) ($sum - MATH_BIGINTEGER_BASE_FULL * $temp);
            $x_value[$j] = $temp;
        }

        if ($j == $y_size) { // ie. if $y_size is odd
            $sum = $x_value[$i] - $y_value[$i] - $carry;
            $carry = $sum < 0;
            $x_value[$i] = $carry ? $sum + MATH_BIGINTEGER_BASE_FULL : $sum;
            ++$i;
        }

        if ($carry) {
            for (; !$x_value[$i]; ++$i) {
                $x_value[$i] = MATH_BIGINTEGER_MAX_DIGIT;
            }
            --$x_value[$i];
        }

        return array(
            MATH_BIGINTEGER_VALUE => $this->_trim($x_value),
            MATH_BIGINTEGER_SIGN => $x_negative
        );
    }

    /**
     * Multiplies two BigIntegers
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('10');
     *    $b = new Math_BigInteger('20');
     *
     *    $c = $a->multiply($b);
     *
     *    echo $c->toString(); // outputs 200
     *      * </code>
     *
     * @param Math_BigInteger $x
     * @return Math_BigInteger
     * @access public
     */
    function multiply($x)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_mul($this->value, $x->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp = new Math_BigInteger();
                $temp->value = bcmul($this->value, $x->value, 0);

                return $this->_normalize($temp);
        }

        $temp = $this->_multiply($this->value, $this->is_negative, $x->value, $x->is_negative);

        $product = new Math_BigInteger();
        $product->value = $temp[MATH_BIGINTEGER_VALUE];
        $product->is_negative = $temp[MATH_BIGINTEGER_SIGN];

        return $this->_normalize($product);
    }

    /**
     * Performs multiplication.
     *
     * @param Array $x_value
     * @param Boolean $x_negative
     * @param Array $y_value
     * @param Boolean $y_negative
     * @return Array
     * @access private
     */
    function _multiply($x_value, $x_negative, $y_value, $y_negative)
    {
        //if ( $x_value == $y_value ) {
        //    return array(
        //        MATH_BIGINTEGER_VALUE => $this->_square($x_value),
        //        MATH_BIGINTEGER_SIGN => $x_sign != $y_value
        //    );
        //}

        $x_length = count($x_value);
        $y_length = count($y_value);

        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
            return array(
                MATH_BIGINTEGER_VALUE => array(),
                MATH_BIGINTEGER_SIGN => false
            );
        }

        return array(
            MATH_BIGINTEGER_VALUE => min($x_length, $y_length) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ?
                $this->_trim($this->_regularMultiply($x_value, $y_value)) :
                $this->_trim($this->_karatsuba($x_value, $y_value)),
            MATH_BIGINTEGER_SIGN => $x_negative != $y_negative
        );
    }

    /**
     * Performs long multiplication on two BigIntegers
     *
     * Modeled after 'multiply' in MutableBigInteger.java.
     *
     * @param Array $x_value
     * @param Array $y_value
     * @return Array
     * @access private
     */
    function _regularMultiply($x_value, $y_value)
    {
        $x_length = count($x_value);
        $y_length = count($y_value);

        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
            return array();
        }

        if ( $x_length < $y_length ) {
            $temp = $x_value;
            $x_value = $y_value;
            $y_value = $temp;

            $x_length = count($x_value);
            $y_length = count($y_value);
        }

        $product_value = $this->_array_repeat(0, $x_length + $y_length);

        // the following for loop could be removed if the for loop following it
        // (the one with nested for loops) initially set $i to 0, but
        // doing so would also make the result in one set of unnecessary adds,
        // since on the outermost loops first pass, $product->value[$k] is going
        // to always be 0

        $carry = 0;

        for ($j = 0; $j < $x_length; ++$j) { // ie. $i = 0
            $temp = $x_value[$j] * $y_value[0] + $carry; // $product_value[$k] == 0
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $product_value[$j] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        }

        $product_value[$j] = $carry;

        // the above for loop is what the previous comment was talking about.  the
        // following for loop is the "one with nested for loops"
        for ($i = 1; $i < $y_length; ++$i) {
            $carry = 0;

            for ($j = 0, $k = $i; $j < $x_length; ++$j, ++$k) {
                $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
                $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
                $product_value[$k] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
            }

            $product_value[$k] = $carry;
        }

        return $product_value;
    }

    /**
     * Performs Karatsuba multiplication on two BigIntegers
     *
     * See {@link http://en.wikipedia.org/wiki/Karatsuba_algorithm Karatsuba algorithm} and
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=120 MPM 5.2.3}.
     *
     * @param Array $x_value
     * @param Array $y_value
     * @return Array
     * @access private
     */
    function _karatsuba($x_value, $y_value)
    {
        $m = min(count($x_value) >> 1, count($y_value) >> 1);

        if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
            return $this->_regularMultiply($x_value, $y_value);
        }

        $x1 = array_slice($x_value, $m);
        $x0 = array_slice($x_value, 0, $m);
        $y1 = array_slice($y_value, $m);
        $y0 = array_slice($y_value, 0, $m);

        $z2 = $this->_karatsuba($x1, $y1);
        $z0 = $this->_karatsuba($x0, $y0);

        $z1 = $this->_add($x1, false, $x0, false);
        $temp = $this->_add($y1, false, $y0, false);
        $z1 = $this->_karatsuba($z1[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_VALUE]);
        $temp = $this->_add($z2, false, $z0, false);
        $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);

        $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
        $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);

        $xy = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
        $xy = $this->_add($xy[MATH_BIGINTEGER_VALUE], $xy[MATH_BIGINTEGER_SIGN], $z0, false);

        return $xy[MATH_BIGINTEGER_VALUE];
    }

    /**
     * Performs squaring
     *
     * @param Array $x
     * @return Array
     * @access private
     */
    function _square($x = false)
    {
        return count($x) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ?
            $this->_trim($this->_baseSquare($x)) :
            $this->_trim($this->_karatsubaSquare($x));
    }

    /**
     * Performs traditional squaring on two BigIntegers
     *
     * Squaring can be done faster than multiplying a number by itself can be.  See
     * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=7 HAC 14.2.4} /
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=141 MPM 5.3} for more information.
     *
     * @param Array $value
     * @return Array
     * @access private
     */
    function _baseSquare($value)
    {
        if ( empty($value) ) {
            return array();
        }
        $square_value = $this->_array_repeat(0, 2 * count($value));

        for ($i = 0, $max_index = count($value) - 1; $i <= $max_index; ++$i) {
            $i2 = $i << 1;

            $temp = $square_value[$i2] + $value[$i] * $value[$i];
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $square_value[$i2] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);

            // note how we start from $i+1 instead of 0 as we do in multiplication.
            for ($j = $i + 1, $k = $i2 + 1; $j <= $max_index; ++$j, ++$k) {
                $temp = $square_value[$k] + 2 * $value[$j] * $value[$i] + $carry;
                $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
                $square_value[$k] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
            }

            // the following line can yield values larger 2**15.  at this point, PHP should switch
            // over to floats.
            $square_value[$i + $max_index + 1] = $carry;
        }

        return $square_value;
    }

    /**
     * Performs Karatsuba "squaring" on two BigIntegers
     *
     * See {@link http://en.wikipedia.org/wiki/Karatsuba_algorithm Karatsuba algorithm} and
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=151 MPM 5.3.4}.
     *
     * @param Array $value
     * @return Array
     * @access private
     */
    function _karatsubaSquare($value)
    {
        $m = count($value) >> 1;

        if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
            return $this->_baseSquare($value);
        }

        $x1 = array_slice($value, $m);
        $x0 = array_slice($value, 0, $m);

        $z2 = $this->_karatsubaSquare($x1);
        $z0 = $this->_karatsubaSquare($x0);

        $z1 = $this->_add($x1, false, $x0, false);
        $z1 = $this->_karatsubaSquare($z1[MATH_BIGINTEGER_VALUE]);
        $temp = $this->_add($z2, false, $z0, false);
        $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);

        $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
        $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);

        $xx = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
        $xx = $this->_add($xx[MATH_BIGINTEGER_VALUE], $xx[MATH_BIGINTEGER_SIGN], $z0, false);

        return $xx[MATH_BIGINTEGER_VALUE];
    }

    /**
     * Divides two BigIntegers.
     *
     * Returns an array whose first element contains the quotient and whose second element contains the
     * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
     * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
     * and the divisor (basically, the "common residue" is the first positive modulo).
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('10');
     *    $b = new Math_BigInteger('20');
     *
     *    list($quotient, $remainder) = $a->divide($b);
     *
     *    echo $quotient->toString(); // outputs 0
     *    echo "\r\n";
     *    echo $remainder->toString(); // outputs 10
     *      * </code>
     *
     * @param Math_BigInteger $y
     * @return Array
     * @access public
     * @internal This function is based off of {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=9 HAC 14.20}.
     */
    function divide($y)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $quotient = new Math_BigInteger();
                $remainder = new Math_BigInteger();

                list($quotient->value, $remainder->value) = gmp_div_qr($this->value, $y->value);

                if (gmp_sign($remainder->value) < 0) {
                    $remainder->value = gmp_add($remainder->value, gmp_abs($y->value));
                }

                return array($this->_normalize($quotient), $this->_normalize($remainder));
            case MATH_BIGINTEGER_MODE_BCMATH:
                $quotient = new Math_BigInteger();
                $remainder = new Math_BigInteger();

                $quotient->value = bcdiv($this->value, $y->value, 0);
                $remainder->value = bcmod($this->value, $y->value);

                if ($remainder->value[0] == '-') {
                    $remainder->value = bcadd($remainder->value, $y->value[0] == '-' ? substr($y->value, 1) : $y->value, 0);
                }

                return array($this->_normalize($quotient), $this->_normalize($remainder));
        }

        if (count($y->value) == 1) {
            list($q, $r) = $this->_divide_digit($this->value, $y->value[0]);
            $quotient = new Math_BigInteger();
            $remainder = new Math_BigInteger();
            $quotient->value = $q;
            $remainder->value = array($r);
            $quotient->is_negative = $this->is_negative != $y->is_negative;
            return array($this->_normalize($quotient), $this->_normalize($remainder));
        }

        static $zero;
        if ( !isset($zero) ) {
            $zero = new Math_BigInteger();
        }

        $x = $this->copy();
        $y = $y->copy();

        $x_sign = $x->is_negative;
        $y_sign = $y->is_negative;

        $x->is_negative = $y->is_negative = false;

        $diff = $x->compare($y);

        if ( !$diff ) {
            $temp = new Math_BigInteger();
            $temp->value = array(1);
            $temp->is_negative = $x_sign != $y_sign;
            return array($this->_normalize($temp), $this->_normalize(new Math_BigInteger()));
        }

        if ( $diff < 0 ) {
            // if $x is negative, "add" $y.
            if ( $x_sign ) {
                $x = $y->subtract($x);
            }
            return array($this->_normalize(new Math_BigInteger()), $this->_normalize($x));
        }

        // normalize $x and $y as described in HAC 14.23 / 14.24
        $msb = $y->value[count($y->value) - 1];
        for ($shift = 0; !($msb & MATH_BIGINTEGER_MSB); ++$shift) {
            $msb <<= 1;
        }
        $x->_lshift($shift);
        $y->_lshift($shift);
        $y_value = &$y->value;

        $x_max = count($x->value) - 1;
        $y_max = count($y->value) - 1;

        $quotient = new Math_BigInteger();
        $quotient_value = &$quotient->value;
        $quotient_value = $this->_array_repeat(0, $x_max - $y_max + 1);

        static $temp, $lhs, $rhs;
        if (!isset($temp)) {
            $temp = new Math_BigInteger();
            $lhs =  new Math_BigInteger();
            $rhs =  new Math_BigInteger();
        }
        $temp_value = &$temp->value;
        $rhs_value =  &$rhs->value;

        // $temp = $y << ($x_max - $y_max-1) in base 2**26
        $temp_value = array_merge($this->_array_repeat(0, $x_max - $y_max), $y_value);

        while ( $x->compare($temp) >= 0 ) {
            // calculate the "common residue"
            ++$quotient_value[$x_max - $y_max];
            $x = $x->subtract($temp);
            $x_max = count($x->value) - 1;
        }

        for ($i = $x_max; $i >= $y_max + 1; --$i) {
            $x_value = &$x->value;
            $x_window = array(
                isset($x_value[$i]) ? $x_value[$i] : 0,
                isset($x_value[$i - 1]) ? $x_value[$i - 1] : 0,
                isset($x_value[$i - 2]) ? $x_value[$i - 2] : 0
            );
            $y_window = array(
                $y_value[$y_max],
                ( $y_max > 0 ) ? $y_value[$y_max - 1] : 0
            );

            $q_index = $i - $y_max - 1;
            if ($x_window[0] == $y_window[0]) {
                $quotient_value[$q_index] = MATH_BIGINTEGER_MAX_DIGIT;
            } else {
                $quotient_value[$q_index] = $this->_safe_divide(
                    $x_window[0] * MATH_BIGINTEGER_BASE_FULL + $x_window[1],
                    $y_window[0]
                );
            }

            $temp_value = array($y_window[1], $y_window[0]);

            $lhs->value = array($quotient_value[$q_index]);
            $lhs = $lhs->multiply($temp);

            $rhs_value = array($x_window[2], $x_window[1], $x_window[0]);

            while ( $lhs->compare($rhs) > 0 ) {
                --$quotient_value[$q_index];

                $lhs->value = array($quotient_value[$q_index]);
                $lhs = $lhs->multiply($temp);
            }

            $adjust = $this->_array_repeat(0, $q_index);
            $temp_value = array($quotient_value[$q_index]);
            $temp = $temp->multiply($y);
            $temp_value = &$temp->value;
            $temp_value = array_merge($adjust, $temp_value);

            $x = $x->subtract($temp);

            if ($x->compare($zero) < 0) {
                $temp_value = array_merge($adjust, $y_value);
                $x = $x->add($temp);

                --$quotient_value[$q_index];
            }

            $x_max = count($x_value) - 1;
        }

        // unnormalize the remainder
        $x->_rshift($shift);

        $quotient->is_negative = $x_sign != $y_sign;

        // calculate the "common residue", if appropriate
        if ( $x_sign ) {
            $y->_rshift($shift);
            $x = $y->subtract($x);
        }

        return array($this->_normalize($quotient), $this->_normalize($x));
    }

    /**
     * Divides a BigInteger by a regular integer
     *
     * abc / x = a00 / x + b0 / x + c / x
     *
     * @param Array $dividend
     * @param Array $divisor
     * @return Array
     * @access private
     */
    function _divide_digit($dividend, $divisor)
    {
        $carry = 0;
        $result = array();

        for ($i = count($dividend) - 1; $i >= 0; --$i) {
            $temp = MATH_BIGINTEGER_BASE_FULL * $carry + $dividend[$i];
            $result[$i] = $this->_safe_divide($temp, $divisor);
            $carry = (int) ($temp - $divisor * $result[$i]);
        }

        return array($result, $carry);
    }

    /**
     * Performs modular exponentiation.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger('10');
     *    $b = new Math_BigInteger('20');
     *    $c = new Math_BigInteger('30');
     *
     *    $c = $a->modPow($b, $c);
     *
     *    echo $c->toString(); // outputs 10
     *      * </code>
     *
     * @param Math_BigInteger $e
     * @param Math_BigInteger $n
     * @return Math_BigInteger
     * @access public
     * @internal The most naive approach to modular exponentiation has very unreasonable requirements, and
     *    and although the approach involving repeated squaring does vastly better, it, too, is impractical
     *    for our purposes.  The reason being that division - by far the most complicated and time-consuming
     *    of the basic operations (eg. +,-,*,/) - occurs multiple times within it.
     *
     *    Modular reductions resolve this issue.  Although an individual modular reduction takes more time
     *    then an individual division, when performed in succession (with the same modulo), they're a lot faster.
     *
     *    The two most commonly used modular reductions are Barrett and Montgomery reduction.  Montgomery reduction,
     *    although faster, only works when the gcd of the modulo and of the base being used is 1.  In RSA, when the
     *    base is a power of two, the modulo - a product of two primes - is always going to have a gcd of 1 (because
     *    the product of two odd numbers is odd), but what about when RSA isn't used?
     *
     *    In contrast, Barrett reduction has no such constraint.  As such, some bigint implementations perform a
     *    Barrett reduction after every operation in the modpow function.  Others perform Barrett reductions when the
     *    modulo is even and Montgomery reductions when the modulo is odd.  BigInteger.java's modPow method, however,
     *    uses a trick involving the Chinese Remainder Theorem to factor the even modulo into two numbers - one odd and
     *    the other, a power of two - and recombine them, later.  This is the method that this modPow function uses.
     *    {@link http://islab.oregonstate.edu/papers/j34monex.pdf Montgomery Reduction with Even Modulus} elaborates.
     */
    function modPow($e, $n)
    {
        $n = $this->bitmask !== false && $this->bitmask->compare($n) < 0 ? $this->bitmask : $n->abs();

        if ($e->compare(new Math_BigInteger()) < 0) {
            $e = $e->abs();

            $temp = $this->modInverse($n);
            if ($temp === false) {
                return false;
            }

            return $this->_normalize($temp->modPow($e, $n));
        }

        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP ) {
            $temp = new Math_BigInteger();
            $temp->value = gmp_powm($this->value, $e->value, $n->value);

            return $this->_normalize($temp);
        }

        if ($this->compare(new Math_BigInteger()) < 0 || $this->compare($n) > 0) {
            list(, $temp) = $this->divide($n);
            return $temp->modPow($e, $n);
        }

        if (defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
            $components = array(
                'modulus' => $n->toBytes(true),
                'publicExponent' => $e->toBytes(true)
            );

            $components = array(
                'modulus' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['modulus'])), $components['modulus']),
                'publicExponent' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['publicExponent'])), $components['publicExponent'])
            );

            $RSAPublicKey = pack('Ca*a*a*',
                48, $this->_encodeASN1Length(strlen($components['modulus']) + strlen($components['publicExponent'])),
                $components['modulus'], $components['publicExponent']
            );

            $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
            $RSAPublicKey = chr(0) . $RSAPublicKey;
            $RSAPublicKey = chr(3) . $this->_encodeASN1Length(strlen($RSAPublicKey)) . $RSAPublicKey;

            $encapsulated = pack('Ca*a*',
                48, $this->_encodeASN1Length(strlen($rsaOID . $RSAPublicKey)), $rsaOID . $RSAPublicKey
            );

            $RSAPublicKey = "-----BEGIN PUBLIC KEY-----\r\n" .
                             chunk_split(base64_encode($encapsulated)) .
                             '-----END PUBLIC KEY-----';

            $plaintext = str_pad($this->toBytes(), strlen($n->toBytes(true)) - 1, "\0", STR_PAD_LEFT);

            if (openssl_public_encrypt($plaintext, $result, $RSAPublicKey, OPENSSL_NO_PADDING)) {
                return new Math_BigInteger($result, 256);
            }
        }

        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH ) {
                $temp = new Math_BigInteger();
                $temp->value = bcpowmod($this->value, $e->value, $n->value, 0);

                return $this->_normalize($temp);
        }

        if ( empty($e->value) ) {
            $temp = new Math_BigInteger();
            $temp->value = array(1);
            return $this->_normalize($temp);
        }

        if ( $e->value == array(1) ) {
            list(, $temp) = $this->divide($n);
            return $this->_normalize($temp);
        }

        if ( $e->value == array(2) ) {
            $temp = new Math_BigInteger();
            $temp->value = $this->_square($this->value);
            list(, $temp) = $temp->divide($n);
            return $this->_normalize($temp);
        }

        return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_BARRETT));

        // the following code, although not callable, can be run independently of the above code
        // although the above code performed better in my benchmarks the following could might
        // perform better under different circumstances. in lieu of deleting it it's just been
        // made uncallable

        // is the modulo odd?
        if ( $n->value[0] & 1 ) {
            return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_MONTGOMERY));
        }
        // if it's not, it's even

        // find the lowest set bit (eg. the max pow of 2 that divides $n)
        for ($i = 0; $i < count($n->value); ++$i) {
            if ( $n->value[$i] ) {
                $temp = decbin($n->value[$i]);
                $j = strlen($temp) - strrpos($temp, '1') - 1;
                $j+= 26 * $i;
                break;
            }
        }
        // at this point, 2^$j * $n/(2^$j) == $n

        $mod1 = $n->copy();
        $mod1->_rshift($j);
        $mod2 = new Math_BigInteger();
        $mod2->value = array(1);
        $mod2->_lshift($j);

        $part1 = ( $mod1->value != array(1) ) ? $this->_slidingWindow($e, $mod1, MATH_BIGINTEGER_MONTGOMERY) : new Math_BigInteger();
        $part2 = $this->_slidingWindow($e, $mod2, MATH_BIGINTEGER_POWEROF2);

        $y1 = $mod2->modInverse($mod1);
        $y2 = $mod1->modInverse($mod2);

        $result = $part1->multiply($mod2);
        $result = $result->multiply($y1);

        $temp = $part2->multiply($mod1);
        $temp = $temp->multiply($y2);

        $result = $result->add($temp);
        list(, $result) = $result->divide($n);

        return $this->_normalize($result);
    }

    /**
     * Performs modular exponentiation.
     *
     * Alias for Math_BigInteger::modPow()
     *
     * @param Math_BigInteger $e
     * @param Math_BigInteger $n
     * @return Math_BigInteger
     * @access public
     */
    function powMod($e, $n)
    {
        return $this->modPow($e, $n);
    }

    /**
     * Sliding Window k-ary Modular Exponentiation
     *
     * Based on {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=27 HAC 14.85} /
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=210 MPM 7.7}.  In a departure from those algorithims,
     * however, this function performs a modular reduction after every multiplication and squaring operation.
     * As such, this function has the same preconditions that the reductions being used do.
     *
     * @param Math_BigInteger $e
     * @param Math_BigInteger $n
     * @param Integer $mode
     * @return Math_BigInteger
     * @access private
     */
    function _slidingWindow($e, $n, $mode)
    {
        static $window_ranges = array(7, 25, 81, 241, 673, 1793); // from BigInteger.java's oddModPow function
        //static $window_ranges = array(0, 7, 36, 140, 450, 1303, 3529); // from MPM 7.3.1

        $e_value = $e->value;
        $e_length = count($e_value) - 1;
        $e_bits = decbin($e_value[$e_length]);
        for ($i = $e_length - 1; $i >= 0; --$i) {
            $e_bits.= str_pad(decbin($e_value[$i]), MATH_BIGINTEGER_BASE, '0', STR_PAD_LEFT);
        }

        $e_length = strlen($e_bits);

        // calculate the appropriate window size.
        // $window_size == 3 if $window_ranges is between 25 and 81, for example.
        for ($i = 0, $window_size = 1; $e_length > $window_ranges[$i] && $i < count($window_ranges); ++$window_size, ++$i);

        $n_value = $n->value;

        // precompute $this^0 through $this^$window_size
        $powers = array();
        $powers[1] = $this->_prepareReduce($this->value, $n_value, $mode);
        $powers[2] = $this->_squareReduce($powers[1], $n_value, $mode);

        // we do every other number since substr($e_bits, $i, $j+1) (see below) is supposed to end
        // in a 1.  ie. it's supposed to be odd.
        $temp = 1 << ($window_size - 1);
        for ($i = 1; $i < $temp; ++$i) {
            $i2 = $i << 1;
            $powers[$i2 + 1] = $this->_multiplyReduce($powers[$i2 - 1], $powers[2], $n_value, $mode);
        }

        $result = array(1);
        $result = $this->_prepareReduce($result, $n_value, $mode);

        for ($i = 0; $i < $e_length; ) {
            if ( !$e_bits[$i] ) {
                $result = $this->_squareReduce($result, $n_value, $mode);
                ++$i;
            } else {
                for ($j = $window_size - 1; $j > 0; --$j) {
                    if ( !empty($e_bits[$i + $j]) ) {
                        break;
                    }
                }

                for ($k = 0; $k <= $j; ++$k) {// eg. the length of substr($e_bits, $i, $j+1)
                    $result = $this->_squareReduce($result, $n_value, $mode);
                }

                $result = $this->_multiplyReduce($result, $powers[bindec(substr($e_bits, $i, $j + 1))], $n_value, $mode);

                $i+=$j + 1;
            }
        }

        $temp = new Math_BigInteger();
        $temp->value = $this->_reduce($result, $n_value, $mode);

        return $temp;
    }

    /**
     * Modular reduction
     *
     * For most $modes this will return the remainder.
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @param Integer $mode
     * @return Array
     */
    function _reduce($x, $n, $mode)
    {
        switch ($mode) {
            case MATH_BIGINTEGER_MONTGOMERY:
                return $this->_montgomery($x, $n);
            case MATH_BIGINTEGER_BARRETT:
                return $this->_barrett($x, $n);
            case MATH_BIGINTEGER_POWEROF2:
                $lhs = new Math_BigInteger();
                $lhs->value = $x;
                $rhs = new Math_BigInteger();
                $rhs->value = $n;
                return $x->_mod2($n);
            case MATH_BIGINTEGER_CLASSIC:
                $lhs = new Math_BigInteger();
                $lhs->value = $x;
                $rhs = new Math_BigInteger();
                $rhs->value = $n;
                list(, $temp) = $lhs->divide($rhs);
                return $temp->value;
            case MATH_BIGINTEGER_NONE:
                return $x;
            default:
                // an invalid $mode was provided
        }
    }

    /**
     * Modular reduction preperation
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @param Integer $mode
     * @return Array
     */
    function _prepareReduce($x, $n, $mode)
    {
        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
            return $this->_prepMontgomery($x, $n);
        }
        return $this->_reduce($x, $n, $mode);
    }

    /**
     * Modular multiply
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $y
     * @param Array $n
     * @param Integer $mode
     * @return Array
     */
    function _multiplyReduce($x, $y, $n, $mode)
    {
        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
            return $this->_montgomeryMultiply($x, $y, $n);
        }
        $temp = $this->_multiply($x, false, $y, false);
        return $this->_reduce($temp[MATH_BIGINTEGER_VALUE], $n, $mode);
    }

    /**
     * Modular square
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @param Integer $mode
     * @return Array
     */
    function _squareReduce($x, $n, $mode)
    {
        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
            return $this->_montgomeryMultiply($x, $x, $n);
        }
        return $this->_reduce($this->_square($x), $n, $mode);
    }

    /**
     * Modulos for Powers of Two
     *
     * Calculates $x%$n, where $n = 2**$e, for some $e.  Since this is basically the same as doing $x & ($n-1),
     * we'll just use this function as a wrapper for doing that.
     *
     * @see _slidingWindow()
     * @access private
     * @param Math_BigInteger
     * @return Math_BigInteger
     */
    function _mod2($n)
    {
        $temp = new Math_BigInteger();
        $temp->value = array(1);
        return $this->bitwise_and($n->subtract($temp));
    }

    /**
     * Barrett Modular Reduction
     *
     * See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=14 HAC 14.3.3} /
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=165 MPM 6.2.5} for more information.  Modified slightly,
     * so as not to require negative numbers (initially, this script didn't support negative numbers).
     *
     * Employs "folding", as described at
     * {@link http://www.cosic.esat.kuleuven.be/publications/thesis-149.pdf#page=66 thesis-149.pdf#page=66}.  To quote from
     * it, "the idea [behind folding] is to find a value x' such that x (mod m) = x' (mod m), with x' being smaller than x."
     *
     * Unfortunately, the "Barrett Reduction with Folding" algorithm described in thesis-149.pdf is not, as written, all that
     * usable on account of (1) its not using reasonable radix points as discussed in
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=162 MPM 6.2.2} and (2) the fact that, even with reasonable
     * radix points, it only works when there are an even number of digits in the denominator.  The reason for (2) is that
     * (x >> 1) + (x >> 1) != x / 2 + x / 2.  If x is even, they're the same, but if x is odd, they're not.  See the in-line
     * comments for details.
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $n
     * @param Array $m
     * @return Array
     */
    function _barrett($n, $m)
    {
        static $cache = array(
            MATH_BIGINTEGER_VARIABLE => array(),
            MATH_BIGINTEGER_DATA => array()
        );

        $m_length = count($m);

        // if ($this->_compare($n, $this->_square($m)) >= 0) {
        if (count($n) > 2 * $m_length) {
            $lhs = new Math_BigInteger();
            $rhs = new Math_BigInteger();
            $lhs->value = $n;
            $rhs->value = $m;
            list(, $temp) = $lhs->divide($rhs);
            return $temp->value;
        }

        // if (m.length >> 1) + 2 <= m.length then m is too small and n can't be reduced
        if ($m_length < 5) {
            return $this->_regularBarrett($n, $m);
        }

        // n = 2 * m.length

        if ( ($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
            $cache[MATH_BIGINTEGER_VARIABLE][] = $m;

            $lhs = new Math_BigInteger();
            $lhs_value = &$lhs->value;
            $lhs_value = $this->_array_repeat(0, $m_length + ($m_length >> 1));
            $lhs_value[] = 1;
            $rhs = new Math_BigInteger();
            $rhs->value = $m;

            list($u, $m1) = $lhs->divide($rhs);
            $u = $u->value;
            $m1 = $m1->value;

            $cache[MATH_BIGINTEGER_DATA][] = array(
                'u' => $u, // m.length >> 1 (technically (m.length >> 1) + 1)
                'm1'=> $m1 // m.length
            );
        } else {
            extract($cache[MATH_BIGINTEGER_DATA][$key]);
        }

        $cutoff = $m_length + ($m_length >> 1);
        $lsd = array_slice($n, 0, $cutoff); // m.length + (m.length >> 1)
        $msd = array_slice($n, $cutoff);    // m.length >> 1
        $lsd = $this->_trim($lsd);
        $temp = $this->_multiply($msd, false, $m1, false);
        $n = $this->_add($lsd, false, $temp[MATH_BIGINTEGER_VALUE], false); // m.length + (m.length >> 1) + 1

        if ($m_length & 1) {
            return $this->_regularBarrett($n[MATH_BIGINTEGER_VALUE], $m);
        }

        // (m.length + (m.length >> 1) + 1) - (m.length - 1) == (m.length >> 1) + 2
        $temp = array_slice($n[MATH_BIGINTEGER_VALUE], $m_length - 1);
        // if even: ((m.length >> 1) + 2) + (m.length >> 1) == m.length + 2
        // if odd:  ((m.length >> 1) + 2) + (m.length >> 1) == (m.length - 1) + 2 == m.length + 1
        $temp = $this->_multiply($temp, false, $u, false);
        // if even: (m.length + 2) - ((m.length >> 1) + 1) = m.length - (m.length >> 1) + 1
        // if odd:  (m.length + 1) - ((m.length >> 1) + 1) = m.length - (m.length >> 1)
        $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], ($m_length >> 1) + 1);
        // if even: (m.length - (m.length >> 1) + 1) + m.length = 2 * m.length - (m.length >> 1) + 1
        // if odd:  (m.length - (m.length >> 1)) + m.length     = 2 * m.length - (m.length >> 1)
        $temp = $this->_multiply($temp, false, $m, false);

        // at this point, if m had an odd number of digits, we'd be subtracting a 2 * m.length - (m.length >> 1) digit
        // number from a m.length + (m.length >> 1) + 1 digit number.  ie. there'd be an extra digit and the while loop
        // following this comment would loop a lot (hence our calling _regularBarrett() in that situation).

        $result = $this->_subtract($n[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);

        while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false) >= 0) {
            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false);
        }

        return $result[MATH_BIGINTEGER_VALUE];
    }

    /**
     * (Regular) Barrett Modular Reduction
     *
     * For numbers with more than four digits Math_BigInteger::_barrett() is faster.  The difference between that and this
     * is that this function does not fold the denominator into a smaller form.
     *
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @return Array
     */
    function _regularBarrett($x, $n)
    {
        static $cache = array(
            MATH_BIGINTEGER_VARIABLE => array(),
            MATH_BIGINTEGER_DATA => array()
        );

        $n_length = count($n);

        if (count($x) > 2 * $n_length) {
            $lhs = new Math_BigInteger();
            $rhs = new Math_BigInteger();
            $lhs->value = $x;
            $rhs->value = $n;
            list(, $temp) = $lhs->divide($rhs);
            return $temp->value;
        }

        if ( ($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
            $cache[MATH_BIGINTEGER_VARIABLE][] = $n;
            $lhs = new Math_BigInteger();
            $lhs_value = &$lhs->value;
            $lhs_value = $this->_array_repeat(0, 2 * $n_length);
            $lhs_value[] = 1;
            $rhs = new Math_BigInteger();
            $rhs->value = $n;
            list($temp, ) = $lhs->divide($rhs); // m.length
            $cache[MATH_BIGINTEGER_DATA][] = $temp->value;
        }

        // 2 * m.length - (m.length - 1) = m.length + 1
        $temp = array_slice($x, $n_length - 1);
        // (m.length + 1) + m.length = 2 * m.length + 1
        $temp = $this->_multiply($temp, false, $cache[MATH_BIGINTEGER_DATA][$key], false);
        // (2 * m.length + 1) - (m.length - 1) = m.length + 2
        $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], $n_length + 1);

        // m.length + 1
        $result = array_slice($x, 0, $n_length + 1);
        // m.length + 1
        $temp = $this->_multiplyLower($temp, false, $n, false, $n_length + 1);
        // $temp == array_slice($temp->_multiply($temp, false, $n, false)->value, 0, $n_length + 1)

        if ($this->_compare($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]) < 0) {
            $corrector_value = $this->_array_repeat(0, $n_length + 1);
            $corrector_value[] = 1;
            $result = $this->_add($result, false, $corrector_value, false);
            $result = $result[MATH_BIGINTEGER_VALUE];
        }

        // at this point, we're subtracting a number with m.length + 1 digits from another number with m.length + 1 digits
        $result = $this->_subtract($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]);
        while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false) > 0) {
            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false);
        }

        return $result[MATH_BIGINTEGER_VALUE];
    }

    /**
     * Performs long multiplication up to $stop digits
     *
     * If you're going to be doing array_slice($product->value, 0, $stop), some cycles can be saved.
     *
     * @see _regularBarrett()
     * @param Array $x_value
     * @param Boolean $x_negative
     * @param Array $y_value
     * @param Boolean $y_negative
     * @param Integer $stop
     * @return Array
     * @access private
     */
    function _multiplyLower($x_value, $x_negative, $y_value, $y_negative, $stop)
    {
        $x_length = count($x_value);
        $y_length = count($y_value);

        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
            return array(
                MATH_BIGINTEGER_VALUE => array(),
                MATH_BIGINTEGER_SIGN => false
            );
        }

        if ( $x_length < $y_length ) {
            $temp = $x_value;
            $x_value = $y_value;
            $y_value = $temp;

            $x_length = count($x_value);
            $y_length = count($y_value);
        }

        $product_value = $this->_array_repeat(0, $x_length + $y_length);

        // the following for loop could be removed if the for loop following it
        // (the one with nested for loops) initially set $i to 0, but
        // doing so would also make the result in one set of unnecessary adds,
        // since on the outermost loops first pass, $product->value[$k] is going
        // to always be 0

        $carry = 0;

        for ($j = 0; $j < $x_length; ++$j) { // ie. $i = 0, $k = $i
            $temp = $x_value[$j] * $y_value[0] + $carry; // $product_value[$k] == 0
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $product_value[$j] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        }

        if ($j < $stop) {
            $product_value[$j] = $carry;
        }

        // the above for loop is what the previous comment was talking about.  the
        // following for loop is the "one with nested for loops"

        for ($i = 1; $i < $y_length; ++$i) {
            $carry = 0;

            for ($j = 0, $k = $i; $j < $x_length && $k < $stop; ++$j, ++$k) {
                $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
                $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
                $product_value[$k] = (int) ($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
            }

            if ($k < $stop) {
                $product_value[$k] = $carry;
            }
        }

        return array(
            MATH_BIGINTEGER_VALUE => $this->_trim($product_value),
            MATH_BIGINTEGER_SIGN => $x_negative != $y_negative
        );
    }

    /**
     * Montgomery Modular Reduction
     *
     * ($x->_prepMontgomery($n))->_montgomery($n) yields $x % $n.
     * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=170 MPM 6.3} provides insights on how this can be
     * improved upon (basically, by using the comba method).  gcd($n, 2) must be equal to one for this function
     * to work correctly.
     *
     * @see _prepMontgomery()
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @return Array
     */
    function _montgomery($x, $n)
    {
        static $cache = array(
            MATH_BIGINTEGER_VARIABLE => array(),
            MATH_BIGINTEGER_DATA => array()
        );

        if ( ($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
            $cache[MATH_BIGINTEGER_VARIABLE][] = $x;
            $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($n);
        }

        $k = count($n);

        $result = array(MATH_BIGINTEGER_VALUE => $x);

        for ($i = 0; $i < $k; ++$i) {
            $temp = $result[MATH_BIGINTEGER_VALUE][$i] * $cache[MATH_BIGINTEGER_DATA][$key];
            $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
            $temp = $this->_regularMultiply(array($temp), $n);
            $temp = array_merge($this->_array_repeat(0, $i), $temp);
            $result = $this->_add($result[MATH_BIGINTEGER_VALUE], false, $temp, false);
        }

        $result[MATH_BIGINTEGER_VALUE] = array_slice($result[MATH_BIGINTEGER_VALUE], $k);

        if ($this->_compare($result, false, $n, false) >= 0) {
            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], false, $n, false);
        }

        return $result[MATH_BIGINTEGER_VALUE];
    }

    /**
     * Montgomery Multiply
     *
     * Interleaves the montgomery reduction and long multiplication algorithms together as described in
     * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=13 HAC 14.36}
     *
     * @see _prepMontgomery()
     * @see _montgomery()
     * @access private
     * @param Array $x
     * @param Array $y
     * @param Array $m
     * @return Array
     */
    function _montgomeryMultiply($x, $y, $m)
    {
        $temp = $this->_multiply($x, false, $y, false);
        return $this->_montgomery($temp[MATH_BIGINTEGER_VALUE], $m);

        // the following code, although not callable, can be run independently of the above code
        // although the above code performed better in my benchmarks the following could might
        // perform better under different circumstances. in lieu of deleting it it's just been
        // made uncallable

        static $cache = array(
            MATH_BIGINTEGER_VARIABLE => array(),
            MATH_BIGINTEGER_DATA => array()
        );

        if ( ($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
            $cache[MATH_BIGINTEGER_VARIABLE][] = $m;
            $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($m);
        }

        $n = max(count($x), count($y), count($m));
        $x = array_pad($x, $n, 0);
        $y = array_pad($y, $n, 0);
        $m = array_pad($m, $n, 0);
        $a = array(MATH_BIGINTEGER_VALUE => $this->_array_repeat(0, $n + 1));
        for ($i = 0; $i < $n; ++$i) {
            $temp = $a[MATH_BIGINTEGER_VALUE][0] + $x[$i] * $y[0];
            $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
            $temp = $temp * $cache[MATH_BIGINTEGER_DATA][$key];
            $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
            $temp = $this->_add($this->_regularMultiply(array($x[$i]), $y), false, $this->_regularMultiply(array($temp), $m), false);
            $a = $this->_add($a[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);
            $a[MATH_BIGINTEGER_VALUE] = array_slice($a[MATH_BIGINTEGER_VALUE], 1);
        }
        if ($this->_compare($a[MATH_BIGINTEGER_VALUE], false, $m, false) >= 0) {
            $a = $this->_subtract($a[MATH_BIGINTEGER_VALUE], false, $m, false);
        }
        return $a[MATH_BIGINTEGER_VALUE];
    }

    /**
     * Prepare a number for use in Montgomery Modular Reductions
     *
     * @see _montgomery()
     * @see _slidingWindow()
     * @access private
     * @param Array $x
     * @param Array $n
     * @return Array
     */
    function _prepMontgomery($x, $n)
    {
        $lhs = new Math_BigInteger();
        $lhs->value = array_merge($this->_array_repeat(0, count($n)), $x);
        $rhs = new Math_BigInteger();
        $rhs->value = $n;

        list(, $temp) = $lhs->divide($rhs);
        return $temp->value;
    }

    /**
     * Modular Inverse of a number mod 2**26 (eg. 67108864)
     *
     * Based off of the bnpInvDigit function implemented and justified in the following URL:
     *
     * {@link http://www-cs-students.stanford.edu/~tjw/jsbn/jsbn.js}
     *
     * The following URL provides more info:
     *
     * {@link http://groups.google.com/group/sci.crypt/msg/7a137205c1be7d85}
     *
     * As for why we do all the bitmasking...  strange things can happen when converting from floats to ints. For
     * instance, on some computers, var_dump((int) -4294967297) yields int(-1) and on others, it yields
     * int(-2147483648).  To avoid problems stemming from this, we use bitmasks to guarantee that ints aren't
     * auto-converted to floats.  The outermost bitmask is present because without it, there's no guarantee that
     * the "residue" returned would be the so-called "common residue".  We use fmod, in the last step, because the
     * maximum possible $x is 26 bits and the maximum $result is 16 bits.  Thus, we have to be able to handle up to
     * 40 bits, which only 64-bit floating points will support.
     *
     * Thanks to Pedro Gimeno Fortea for input!
     *
     * @see _montgomery()
     * @access private
     * @param Array $x
     * @return Integer
     */
    function _modInverse67108864($x) // 2**26 == 67,108,864
    {
        $x = -$x[0];
        $result = $x & 0x3; // x**-1 mod 2**2
        $result = ($result * (2 - $x * $result)) & 0xF; // x**-1 mod 2**4
        $result = ($result * (2 - ($x & 0xFF) * $result))  & 0xFF; // x**-1 mod 2**8
        $result = ($result * ((2 - ($x & 0xFFFF) * $result) & 0xFFFF)) & 0xFFFF; // x**-1 mod 2**16
        $result = fmod($result * (2 - fmod($x * $result, MATH_BIGINTEGER_BASE_FULL)), MATH_BIGINTEGER_BASE_FULL); // x**-1 mod 2**26
        return $result & MATH_BIGINTEGER_MAX_DIGIT;
    }

    /**
     * Calculates modular inverses.
     *
     * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger(30);
     *    $b = new Math_BigInteger(17);
     *
     *    $c = $a->modInverse($b);
     *    echo $c->toString(); // outputs 4
     *
     *    echo "\r\n";
     *
     *    $d = $a->multiply($c);
     *    list(, $d) = $d->divide($b);
     *    echo $d; // outputs 1 (as per the definition of modular inverse)
     *      * </code>
     *
     * @param Math_BigInteger $n
     * @return mixed false, if no modular inverse exists, Math_BigInteger, otherwise.
     * @access public
     * @internal See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=21 HAC 14.64} for more information.
     */
    function modInverse($n)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_invert($this->value, $n->value);

                return ( $temp->value === false ) ? false : $this->_normalize($temp);
        }

        static $zero, $one;
        if (!isset($zero)) {
            $zero = new Math_BigInteger();
            $one = new Math_BigInteger(1);
        }

        // $x mod -$n == $x mod $n.
        $n = $n->abs();

        if ($this->compare($zero) < 0) {
            $temp = $this->abs();
            $temp = $temp->modInverse($n);
            return $this->_normalize($n->subtract($temp));
        }

        extract($this->extendedGCD($n));

        if (!$gcd->equals($one)) {
            return false;
        }

        $x = $x->compare($zero) < 0 ? $x->add($n) : $x;

        return $this->compare($zero) < 0 ? $this->_normalize($n->subtract($x)) : $this->_normalize($x);
    }

    /**
     * Calculates the greatest common divisor and Bezout's identity.
     *
     * Say you have 693 and 609.  The GCD is 21.  Bezout's identity states that there exist integers x and y such that
     * 693*x + 609*y == 21.  In point of fact, there are actually an infinite number of x and y combinations and which
     * combination is returned is dependant upon which mode is in use.  See
     * {@link http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity Bezout's identity - Wikipedia} for more information.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger(693);
     *    $b = new Math_BigInteger(609);
     *
     *    extract($a->extendedGCD($b));
     *
     *    echo $gcd->toString() . "\r\n"; // outputs 21
     *    echo $a->toString() * $x->toString() + $b->toString() * $y->toString(); // outputs 21
     *      * </code>
     *
     * @param Math_BigInteger $n
     * @return Math_BigInteger
     * @access public
     * @internal Calculates the GCD using the binary xGCD algorithim described in
     *    {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=19 HAC 14.61}.  As the text above 14.61 notes,
     *    the more traditional algorithim requires "relatively costly multiple-precision divisions".
     */
    function extendedGCD($n)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                extract(gmp_gcdext($this->value, $n->value));

                return array(
                    'gcd' => $this->_normalize(new Math_BigInteger($g)),
                    'x'   => $this->_normalize(new Math_BigInteger($s)),
                    'y'   => $this->_normalize(new Math_BigInteger($t))
                );
            case MATH_BIGINTEGER_MODE_BCMATH:
                // it might be faster to use the binary xGCD algorithim here, as well, but (1) that algorithim works
                // best when the base is a power of 2 and (2) i don't think it'd make much difference, anyway.  as is,
                // the basic extended euclidean algorithim is what we're using.

                $u = $this->value;
                $v = $n->value;

                $a = '1';
                $b = '0';
                $c = '0';
                $d = '1';

                while (bccomp($v, '0', 0) != 0) {
                    $q = bcdiv($u, $v, 0);

                    $temp = $u;
                    $u = $v;
                    $v = bcsub($temp, bcmul($v, $q, 0), 0);

                    $temp = $a;
                    $a = $c;
                    $c = bcsub($temp, bcmul($a, $q, 0), 0);

                    $temp = $b;
                    $b = $d;
                    $d = bcsub($temp, bcmul($b, $q, 0), 0);
                }

                return array(
                    'gcd' => $this->_normalize(new Math_BigInteger($u)),
                    'x'   => $this->_normalize(new Math_BigInteger($a)),
                    'y'   => $this->_normalize(new Math_BigInteger($b))
                );
        }

        $y = $n->copy();
        $x = $this->copy();
        $g = new Math_BigInteger();
        $g->value = array(1);

        while ( !(($x->value[0] & 1)|| ($y->value[0] & 1)) ) {
            $x->_rshift(1);
            $y->_rshift(1);
            $g->_lshift(1);
        }

        $u = $x->copy();
        $v = $y->copy();

        $a = new Math_BigInteger();
        $b = new Math_BigInteger();
        $c = new Math_BigInteger();
        $d = new Math_BigInteger();

        $a->value = $d->value = $g->value = array(1);
        $b->value = $c->value = array();

        while ( !empty($u->value) ) {
            while ( !($u->value[0] & 1) ) {
                $u->_rshift(1);
                if ( (!empty($a->value) && ($a->value[0] & 1)) || (!empty($b->value) && ($b->value[0] & 1)) ) {
                    $a = $a->add($y);
                    $b = $b->subtract($x);
                }
                $a->_rshift(1);
                $b->_rshift(1);
            }

            while ( !($v->value[0] & 1) ) {
                $v->_rshift(1);
                if ( (!empty($d->value) && ($d->value[0] & 1)) || (!empty($c->value) && ($c->value[0] & 1)) ) {
                    $c = $c->add($y);
                    $d = $d->subtract($x);
                }
                $c->_rshift(1);
                $d->_rshift(1);
            }

            if ($u->compare($v) >= 0) {
                $u = $u->subtract($v);
                $a = $a->subtract($c);
                $b = $b->subtract($d);
            } else {
                $v = $v->subtract($u);
                $c = $c->subtract($a);
                $d = $d->subtract($b);
            }
        }

        return array(
            'gcd' => $this->_normalize($g->multiply($v)),
            'x'   => $this->_normalize($c),
            'y'   => $this->_normalize($d)
        );
    }

    /**
     * Calculates the greatest common divisor
     *
     * Say you have 693 and 609.  The GCD is 21.
     *
     * Here's an example:
     * <code>
     *      *    include 'Math/BigInteger.php';
     *
     *    $a = new Math_BigInteger(693);
     *    $b = new Math_BigInteger(609);
     *
     *    $gcd = a->extendedGCD($b);
     *
     *    echo $gcd->toString() . "\r\n"; // outputs 21
     *      * </code>
     *
     * @param Math_BigInteger $n
     * @return Math_BigInteger
     * @access public
     */
    function gcd($n)
    {
        extract($this->extendedGCD($n));
        return $gcd;
    }

    /**
     * Absolute value.
     *
     * @return Math_BigInteger
     * @access public
     */
    function abs()
    {
        $temp = new Math_BigInteger();

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp->value = gmp_abs($this->value);
                break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp->value = (bccomp($this->value, '0', 0) < 0) ? substr($this->value, 1) : $this->value;
                break;
            default:
                $temp->value = $this->value;
        }

        return $temp;
    }

    /**
     * Compares two numbers.
     *
     * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this is
     * demonstrated thusly:
     *
     * $x  > $y: $x->compare($y)  > 0
     * $x  < $y: $x->compare($y)  < 0
     * $x == $y: $x->compare($y) == 0
     *
     * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
     *
     * @param Math_BigInteger $y
     * @return Integer < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
     * @access public
     * @see equals()
     * @internal Could return $this->subtract($x), but that's not as fast as what we do do.
     */
    function compare($y)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $y->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                return bccomp($this->value, $y->value, 0);
        }

        return $this->_compare($this->value, $this->is_negative, $y->value, $y->is_negative);
    }

    /**
     * Compares two numbers.
     *
     * @param Array $x_value
     * @param Boolean $x_negative
     * @param Array $y_value
     * @param Boolean $y_negative
     * @return Integer
     * @see compare()
     * @access private
     */
    function _compare($x_value, $x_negative, $y_value, $y_negative)
    {
        if ( $x_negative != $y_negative ) {
            return ( !$x_negative && $y_negative ) ? 1 : -1;
        }

        $result = $x_negative ? -1 : 1;

        if ( count($x_value) != count($y_value) ) {
            return ( count($x_value) > count($y_value) ) ? $result : -$result;
        }
        $size = max(count($x_value), count($y_value));

        $x_value = array_pad($x_value, $size, 0);
        $y_value = array_pad($y_value, $size, 0);

        for ($i = count($x_value) - 1; $i >= 0; --$i) {
            if ($x_value[$i] != $y_value[$i]) {
                return ( $x_value[$i] > $y_value[$i] ) ? $result : -$result;
            }
        }

        return 0;
    }

    /**
     * Tests the equality of two numbers.
     *
     * If you need to see if one number is greater than or less than another number, use Math_BigInteger::compare()
     *
     * @param Math_BigInteger $x
     * @return Boolean
     * @access public
     * @see compare()
     */
    function equals($x)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $x->value) == 0;
            default:
                return $this->value === $x->value && $this->is_negative == $x->is_negative;
        }
    }

    /**
     * Set Precision
     *
     * Some bitwise operations give different results depending on the precision being used.  Examples include left
     * shift, not, and rotates.
     *
     * @param Integer $bits
     * @access public
     */
    function setPrecision($bits)
    {
        $this->precision = $bits;
        if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ) {
            $this->bitmask = new Math_BigInteger(chr((1 << ($bits & 0x7)) - 1) . str_repeat(chr(0xFF), $bits >> 3), 256);
        } else {
            $this->bitmask = new Math_BigInteger(bcpow('2', $bits, 0));
        }

        $temp = $this->_normalize($this);
        $this->value = $temp->value;
    }

    /**
     * Logical And
     *
     * @param Math_BigInteger $x
     * @access public
     * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
     * @return Math_BigInteger
     */
    function bitwise_and($x)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_and($this->value, $x->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $left = $this->toBytes();
                $right = $x->toBytes();

                $length = max(strlen($left), strlen($right));

                $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);

                return $this->_normalize(new Math_BigInteger($left & $right, 256));
        }

        $result = $this->copy();

        $length = min(count($x->value), count($this->value));

        $result->value = array_slice($result->value, 0, $length);

        for ($i = 0; $i < $length; ++$i) {
            $result->value[$i]&= $x->value[$i];
        }

        return $this->_normalize($result);
    }

    /**
     * Logical Or
     *
     * @param Math_BigInteger $x
     * @access public
     * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
     * @return Math_BigInteger
     */
    function bitwise_or($x)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_or($this->value, $x->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $left = $this->toBytes();
                $right = $x->toBytes();

                $length = max(strlen($left), strlen($right));

                $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);

                return $this->_normalize(new Math_BigInteger($left | $right, 256));
        }

        $length = max(count($this->value), count($x->value));
        $result = $this->copy();
        $result->value = array_pad($result->value, $length, 0);
        $x->value = array_pad($x->value, $length, 0);

        for ($i = 0; $i < $length; ++$i) {
            $result->value[$i]|= $x->value[$i];
        }

        return $this->_normalize($result);
    }

    /**
     * Logical Exclusive-Or
     *
     * @param Math_BigInteger $x
     * @access public
     * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
     * @return Math_BigInteger
     */
    function bitwise_xor($x)
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                $temp = new Math_BigInteger();
                $temp->value = gmp_xor($this->value, $x->value);

                return $this->_normalize($temp);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $left = $this->toBytes();
                $right = $x->toBytes();

                $length = max(strlen($left), strlen($right));

                $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);

                return $this->_normalize(new Math_BigInteger($left ^ $right, 256));
        }

        $length = max(count($this->value), count($x->value));
        $result = $this->copy();
        $result->value = array_pad($result->value, $length, 0);
        $x->value = array_pad($x->value, $length, 0);

        for ($i = 0; $i < $length; ++$i) {
            $result->value[$i]^= $x->value[$i];
        }

        return $this->_normalize($result);
    }

    /**
     * Logical Not
     *
     * @access public
     * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
     * @return Math_BigInteger
     */
    function bitwise_not()
    {
        // calculuate "not" without regard to $this->precision
        // (will always result in a smaller number.  ie. ~1 isn't 1111 1110 - it's 0)
        $temp = $this->toBytes();
        $pre_msb = decbin(ord($temp[0]));
        $temp = ~$temp;
        $msb = decbin(ord($temp[0]));
        if (strlen($msb) == 8) {
            $msb = substr($msb, strpos($msb, '0'));
        }
        $temp[0] = chr(bindec($msb));

        // see if we need to add extra leading 1's
        $current_bits = strlen($pre_msb) + 8 * strlen($temp) - 8;
        $new_bits = $this->precision - $current_bits;
        if ($new_bits <= 0) {
            return $this->_normalize(new Math_BigInteger($temp, 256));
        }

        // generate as many leading 1's as we need to.
        $leading_ones = chr((1 << ($new_bits & 0x7)) - 1) . str_repeat(chr(0xFF), $new_bits >> 3);
        $this->_base256_lshift($leading_ones, $current_bits);

        $temp = str_pad($temp, strlen($leading_ones), chr(0), STR_PAD_LEFT);

        return $this->_normalize(new Math_BigInteger($leading_ones | $temp, 256));
    }

    /**
     * Logical Right Shift
     *
     * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
     *
     * @param Integer $shift
     * @return Math_BigInteger
     * @access public
     * @internal The only version that yields any speed increases is the internal version.
     */
    function bitwise_rightShift($shift)
    {
        $temp = new Math_BigInteger();

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $two;

                if (!isset($two)) {
                    $two = gmp_init('2');
                }

                $temp->value = gmp_div_q($this->value, gmp_pow($two, $shift));

                break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp->value = bcdiv($this->value, bcpow('2', $shift, 0), 0);

                break;
            default: // could just replace _lshift with this, but then all _lshift() calls would need to be rewritten
                     // and I don't want to do that...
                $temp->value = $this->value;
                $temp->_rshift($shift);
        }

        return $this->_normalize($temp);
    }

    /**
     * Logical Left Shift
     *
     * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
     *
     * @param Integer $shift
     * @return Math_BigInteger
     * @access public
     * @internal The only version that yields any speed increases is the internal version.
     */
    function bitwise_leftShift($shift)
    {
        $temp = new Math_BigInteger();

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $two;

                if (!isset($two)) {
                    $two = gmp_init('2');
                }

                $temp->value = gmp_mul($this->value, gmp_pow($two, $shift));

                break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $temp->value = bcmul($this->value, bcpow('2', $shift, 0), 0);

                break;
            default: // could just replace _rshift with this, but then all _lshift() calls would need to be rewritten
                     // and I don't want to do that...
                $temp->value = $this->value;
                $temp->_lshift($shift);
        }

        return $this->_normalize($temp);
    }

    /**
     * Logical Left Rotate
     *
     * Instead of the top x bits being dropped they're appended to the shifted bit string.
     *
     * @param Integer $shift
     * @return Math_BigInteger
     * @access public
     */
    function bitwise_leftRotate($shift)
    {
        $bits = $this->toBytes();

        if ($this->precision > 0) {
            $precision = $this->precision;
            if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH ) {
                $mask = $this->bitmask->subtract(new Math_BigInteger(1));
                $mask = $mask->toBytes();
            } else {
                $mask = $this->bitmask->toBytes();
            }
        } else {
            $temp = ord($bits[0]);
            for ($i = 0; $temp >> $i; ++$i);
            $precision = 8 * strlen($bits) - 8 + $i;
            $mask = chr((1 << ($precision & 0x7)) - 1) . str_repeat(chr(0xFF), $precision >> 3);
        }

        if ($shift < 0) {
            $shift+= $precision;
        }
        $shift%= $precision;

        if (!$shift) {
            return $this->copy();
        }

        $left = $this->bitwise_leftShift($shift);
        $left = $left->bitwise_and(new Math_BigInteger($mask, 256));
        $right = $this->bitwise_rightShift($precision - $shift);
        $result = MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ? $left->bitwise_or($right) : $left->add($right);
        return $this->_normalize($result);
    }

    /**
     * Logical Right Rotate
     *
     * Instead of the bottom x bits being dropped they're prepended to the shifted bit string.
     *
     * @param Integer $shift
     * @return Math_BigInteger
     * @access public
     */
    function bitwise_rightRotate($shift)
    {
        return $this->bitwise_leftRotate(-$shift);
    }

    /**
     * Set random number generator function
     *
     * This function is deprecated.
     *
     * @param String $generator
     * @access public
     */
    function setRandomGenerator($generator)
    {
    }

    /**
     * Generates a random BigInteger
     *
     * Byte length is equal to $length. Uses crypt_random if it's loaded and mt_rand if it's not.
     *
     * @param Integer $length
     * @return Math_BigInteger
     * @access private
     */
    function _random_number_helper($size)
    {
        if (function_exists('crypt_random_string')) {
            $random = crypt_random_string($size);
        } else {
            $random = '';

            if ($size & 1) {
                $random.= chr(mt_rand(0, 255));
            }

            $blocks = $size >> 1;
            for ($i = 0; $i < $blocks; ++$i) {
                // mt_rand(-2147483648, 0x7FFFFFFF) always produces -2147483648 on some systems
                $random.= pack('n', mt_rand(0, 0xFFFF));
            }
        }

        return new Math_BigInteger($random, 256);
    }

    /**
     * Generate a random number
     *
     * Returns a random number between $min and $max where $min and $max
     * can be defined using one of the two methods:
     *
     * $min->random($max)
     * $max->random($min)
     *
     * @param Math_BigInteger $arg1
     * @param optional Math_BigInteger $arg2
     * @return Math_BigInteger
     * @access public
     * @internal The API for creating random numbers used to be $a->random($min, $max), where $a was a Math_BigInteger object.
     *           That method is still supported for BC purposes.
     */
    function random($arg1, $arg2 = false)
    {
        if ($arg1 === false) {
            return false;
        }

        if ($arg2 === false) {
            $max = $arg1;
            $min = $this;
        } else {
            $min = $arg1;
            $max = $arg2;
        }

        $compare = $max->compare($min);

        if (!$compare) {
            return $this->_normalize($min);
        } else if ($compare < 0) {
            // if $min is bigger then $max, swap $min and $max
            $temp = $max;
            $max = $min;
            $min = $temp;
        }

        static $one;
        if (!isset($one)) {
            $one = new Math_BigInteger(1);
        }

        $max = $max->subtract($min->subtract($one));
        $size = strlen(ltrim($max->toBytes(), chr(0)));

        /*
            doing $random % $max doesn't work because some numbers will be more likely to occur than others.
            eg. if $max is 140 and $random's max is 255 then that'd mean both $random = 5 and $random = 145
            would produce 5 whereas the only value of random that could produce 139 would be 139. ie.
            not all numbers would be equally likely. some would be more likely than others.

            creating a whole new random number until you find one that is within the range doesn't work
            because, for sufficiently small ranges, the likelihood that you'd get a number within that range
            would be pretty small. eg. with $random's max being 255 and if your $max being 1 the probability
            would be pretty high that $random would be greater than $max.

            phpseclib works around this using the technique described here:

            http://crypto.stackexchange.com/questions/5708/creating-a-small-number-from-a-cryptographically-secure-random-string
        */
        $random_max = new Math_BigInteger(chr(1) . str_repeat("\0", $size), 256);
        $random = $this->_random_number_helper($size);

        list($max_multiple) = $random_max->divide($max);
        $max_multiple = $max_multiple->multiply($max);

        while ($random->compare($max_multiple) >= 0) {
            $random = $random->subtract($max_multiple);
            $random_max = $random_max->subtract($max_multiple);
            $random = $random->bitwise_leftShift(8);
            $random = $random->add($this->_random_number_helper(1));
            $random_max = $random_max->bitwise_leftShift(8);
            list($max_multiple) = $random_max->divide($max);
            $max_multiple = $max_multiple->multiply($max);
        }
        list(, $random) = $random->divide($max);

        return $this->_normalize($random->add($min));
    }

    /**
     * Generate a random prime number.
     *
     * If there's not a prime within the given range, false will be returned.  If more than $timeout seconds have elapsed,
     * give up and return false.
     *
     * @param Math_BigInteger $arg1
     * @param optional Math_BigInteger $arg2
     * @param optional Integer $timeout
     * @return Mixed
     * @access public
     * @internal See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap4.pdf#page=15 HAC 4.44}.
     */
    function randomPrime($arg1, $arg2 = false, $timeout = false)
    {
        if ($arg1 === false) {
            return false;
        }

        if ($arg2 === false) {
            $max = $arg1;
            $min = $this;
        } else {
            $min = $arg1;
            $max = $arg2;
        }

        $compare = $max->compare($min);

        if (!$compare) {
            return $min->isPrime() ? $min : false;
        } else if ($compare < 0) {
            // if $min is bigger then $max, swap $min and $max
            $temp = $max;
            $max = $min;
            $min = $temp;
        }

        static $one, $two;
        if (!isset($one)) {
            $one = new Math_BigInteger(1);
            $two = new Math_BigInteger(2);
        }

        $start = time();

        $x = $this->random($min, $max);

        // gmp_nextprime() requires PHP 5 >= 5.2.0 per <http://php.net/gmp-nextprime>.
        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP && function_exists('gmp_nextprime') ) {
            $p = new Math_BigInteger();
            $p->value = gmp_nextprime($x->value);

            if ($p->compare($max) <= 0) {
                return $p;
            }

            if (!$min->equals($x)) {
                $x = $x->subtract($one);
            }

            return $x->randomPrime($min, $x);
        }

        if ($x->equals($two)) {
            return $x;
        }

        $x->_make_odd();
        if ($x->compare($max) > 0) {
            // if $x > $max then $max is even and if $min == $max then no prime number exists between the specified range
            if ($min->equals($max)) {
                return false;
            }
            $x = $min->copy();
            $x->_make_odd();
        }

        $initial_x = $x->copy();

        while (true) {
            if ($timeout !== false && time() - $start > $timeout) {
                return false;
            }

            if ($x->isPrime()) {
                return $x;
            }

            $x = $x->add($two);

            if ($x->compare($max) > 0) {
                $x = $min->copy();
                if ($x->equals($two)) {
                    return $x;
                }
                $x->_make_odd();
            }

            if ($x->equals($initial_x)) {
                return false;
            }
        }
    }

    /**
     * Make the current number odd
     *
     * If the current number is odd it'll be unchanged.  If it's even, one will be added to it.
     *
     * @see randomPrime()
     * @access private
     */
    function _make_odd()
    {
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                gmp_setbit($this->value, 0);
                break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if ($this->value[strlen($this->value) - 1] % 2 == 0) {
                    $this->value = bcadd($this->value, '1');
                }
                break;
            default:
                $this->value[0] |= 1;
        }
    }

    /**
     * Checks a numer to see if it's prime
     *
     * Assuming the $t parameter is not set, this function has an error rate of 2**-80.  The main motivation for the
     * $t parameter is distributability.  Math_BigInteger::randomPrime() can be distributed across multiple pageloads
     * on a website instead of just one.
     *
     * @param optional Math_BigInteger $t
     * @return Boolean
     * @access public
     * @internal Uses the
     *     {@link http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test Miller-Rabin primality test}.  See
     *     {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap4.pdf#page=8 HAC 4.24}.
     */
    function isPrime($t = false)
    {
        $length = strlen($this->toBytes());

        if (!$t) {
            // see HAC 4.49 "Note (controlling the error probability)"
            // @codingStandardsIgnoreStart
                 if ($length >= 163) { $t =  2; } // floor(1300 / 8)
            else if ($length >= 106) { $t =  3; } // floor( 850 / 8)
            else if ($length >= 81 ) { $t =  4; } // floor( 650 / 8)
            else if ($length >= 68 ) { $t =  5; } // floor( 550 / 8)
            else if ($length >= 56 ) { $t =  6; } // floor( 450 / 8)
            else if ($length >= 50 ) { $t =  7; } // floor( 400 / 8)
            else if ($length >= 43 ) { $t =  8; } // floor( 350 / 8)
            else if ($length >= 37 ) { $t =  9; } // floor( 300 / 8)
            else if ($length >= 31 ) { $t = 12; } // floor( 250 / 8)
            else if ($length >= 25 ) { $t = 15; } // floor( 200 / 8)
            else if ($length >= 18 ) { $t = 18; } // floor( 150 / 8)
            else                     { $t = 27; }
            // @codingStandardsIgnoreEnd
        }

        // ie. gmp_testbit($this, 0)
        // ie. isEven() or !isOdd()
        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_prob_prime($this->value, $t) != 0;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if ($this->value === '2') {
                    return true;
                }
                if ($this->value[strlen($this->value) - 1] % 2 == 0) {
                    return false;
                }
                break;
            default:
                if ($this->value == array(2)) {
                    return true;
                }
                if (~$this->value[0] & 1) {
                    return false;
                }
        }

        static $primes, $zero, $one, $two;

        if (!isset($primes)) {
            $primes = array(
                3,    5,    7,    11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,
                61,   67,   71,   73,   79,   83,   89,   97,   101,  103,  107,  109,  113,  127,  131,  137,
                139,  149,  151,  157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,  227,
                229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,  283,  293,  307,  311,  313,
                317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,  389,  397,  401,  409,  419,
                421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,  509,
                521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,
                619,  631,  641,  643,  647,  653,  659,  661,  673,  677,  683,  691,  701,  709,  719,  727,
                733,  739,  743,  751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,  829,
                839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,  919,  929,  937,  941,  947,
                953,  967,  971,  977,  983,  991,  997
            );

            if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL ) {
                for ($i = 0; $i < count($primes); ++$i) {
                    $primes[$i] = new Math_BigInteger($primes[$i]);
                }
            }

            $zero = new Math_BigInteger();
            $one = new Math_BigInteger(1);
            $two = new Math_BigInteger(2);
        }

        if ($this->equals($one)) {
            return false;
        }

        // see HAC 4.4.1 "Random search for probable primes"
        if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL ) {
            foreach ($primes as $prime) {
                list(, $r) = $this->divide($prime);
                if ($r->equals($zero)) {
                    return $this->equals($prime);
                }
            }
        } else {
            $value = $this->value;
            foreach ($primes as $prime) {
                list(, $r) = $this->_divide_digit($value, $prime);
                if (!$r) {
                    return count($value) == 1 && $value[0] == $prime;
                }
            }
        }

        $n   = $this->copy();
        $n_1 = $n->subtract($one);
        $n_2 = $n->subtract($two);

        $r = $n_1->copy();
        $r_value = $r->value;
        // ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH ) {
            $s = 0;
            // if $n was 1, $r would be 0 and this would be an infinite loop, hence our $this->equals($one) check earlier
            while ($r->value[strlen($r->value) - 1] % 2 == 0) {
                $r->value = bcdiv($r->value, '2', 0);
                ++$s;
            }
        } else {
            for ($i = 0, $r_length = count($r_value); $i < $r_length; ++$i) {
                $temp = ~$r_value[$i] & 0xFFFFFF;
                for ($j = 1; ($temp >> $j) & 1; ++$j);
                if ($j != 25) {
                    break;
                }
            }
            $s = 26 * $i + $j - 1;
            $r->_rshift($s);
        }

        for ($i = 0; $i < $t; ++$i) {
            $a = $this->random($two, $n_2);
            $y = $a->modPow($r, $n);

            if (!$y->equals($one) && !$y->equals($n_1)) {
                for ($j = 1; $j < $s && !$y->equals($n_1); ++$j) {
                    $y = $y->modPow($two, $n);
                    if ($y->equals($one)) {
                        return false;
                    }
                }

                if (!$y->equals($n_1)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Logical Left Shift
     *
     * Shifts BigInteger's by $shift bits.
     *
     * @param Integer $shift
     * @access private
     */
    function _lshift($shift)
    {
        if ( $shift == 0 ) {
            return;
        }

        $num_digits = (int) ($shift / MATH_BIGINTEGER_BASE);
        $shift %= MATH_BIGINTEGER_BASE;
        $shift = 1 << $shift;

        $carry = 0;

        for ($i = 0; $i < count($this->value); ++$i) {
            $temp = $this->value[$i] * $shift + $carry;
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $this->value[$i] = (int) ($temp - $carry * MATH_BIGINTEGER_BASE_FULL);
        }

        if ( $carry ) {
            $this->value[] = $carry;
        }

        while ($num_digits--) {
            array_unshift($this->value, 0);
        }
    }

    /**
     * Logical Right Shift
     *
     * Shifts BigInteger's by $shift bits.
     *
     * @param Integer $shift
     * @access private
     */
    function _rshift($shift)
    {
        if ($shift == 0) {
            return;
        }

        $num_digits = (int) ($shift / MATH_BIGINTEGER_BASE);
        $shift %= MATH_BIGINTEGER_BASE;
        $carry_shift = MATH_BIGINTEGER_BASE - $shift;
        $carry_mask = (1 << $shift) - 1;

        if ( $num_digits ) {
            $this->value = array_slice($this->value, $num_digits);
        }

        $carry = 0;

        for ($i = count($this->value) - 1; $i >= 0; --$i) {
            $temp = $this->value[$i] >> $shift | $carry;
            $carry = ($this->value[$i] & $carry_mask) << $carry_shift;
            $this->value[$i] = $temp;
        }

        $this->value = $this->_trim($this->value);
    }

    /**
     * Normalize
     *
     * Removes leading zeros and truncates (if necessary) to maintain the appropriate precision
     *
     * @param Math_BigInteger
     * @return Math_BigInteger
     * @see _trim()
     * @access private
     */
    function _normalize($result)
    {
        $result->precision = $this->precision;
        $result->bitmask = $this->bitmask;

        switch ( MATH_BIGINTEGER_MODE ) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (!empty($result->bitmask->value)) {
                    $result->value = gmp_and($result->value, $result->bitmask->value);
                }

                return $result;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!empty($result->bitmask->value)) {
                    $result->value = bcmod($result->value, $result->bitmask->value);
                }

                return $result;
        }

        $value = &$result->value;

        if ( !count($value) ) {
            return $result;
        }

        $value = $this->_trim($value);

        if (!empty($result->bitmask->value)) {
            $length = min(count($value), count($this->bitmask->value));
            $value = array_slice($value, 0, $length);

            for ($i = 0; $i < $length; ++$i) {
                $value[$i] = $value[$i] & $this->bitmask->value[$i];
            }
        }

        return $result;
    }

    /**
     * Trim
     *
     * Removes leading zeros
     *
     * @param Array $value
     * @return Math_BigInteger
     * @access private
     */
    function _trim($value)
    {
        for ($i = count($value) - 1; $i >= 0; --$i) {
            if ( $value[$i] ) {
                break;
            }
            unset($value[$i]);
        }

        return $value;
    }

    /**
     * Array Repeat
     *
     * @param $input Array
     * @param $multiplier mixed
     * @return Array
     * @access private
     */
    function _array_repeat($input, $multiplier)
    {
        return ($multiplier) ? array_fill(0, $multiplier, $input) : array();
    }

    /**
     * Logical Left Shift
     *
     * Shifts binary strings $shift bits, essentially multiplying by 2**$shift.
     *
     * @param $x String
     * @param $shift Integer
     * @return String
     * @access private
     */
    function _base256_lshift(&$x, $shift)
    {
        if ($shift == 0) {
            return;
        }

        $num_bytes = $shift >> 3; // eg. floor($shift/8)
        $shift &= 7; // eg. $shift % 8

        $carry = 0;
        for ($i = strlen($x) - 1; $i >= 0; --$i) {
            $temp = ord($x[$i]) << $shift | $carry;
            $x[$i] = chr($temp);
            $carry = $temp >> 8;
        }
        $carry = ($carry != 0) ? chr($carry) : '';
        $x = $carry . $x . str_repeat(chr(0), $num_bytes);
    }

    /**
     * Logical Right Shift
     *
     * Shifts binary strings $shift bits, essentially dividing by 2**$shift and returning the remainder.
     *
     * @param $x String
     * @param $shift Integer
     * @return String
     * @access private
     */
    function _base256_rshift(&$x, $shift)
    {
        if ($shift == 0) {
            $x = ltrim($x, chr(0));
            return '';
        }

        $num_bytes = $shift >> 3; // eg. floor($shift/8)
        $shift &= 7; // eg. $shift % 8

        $remainder = '';
        if ($num_bytes) {
            $start = $num_bytes > strlen($x) ? -strlen($x) : -$num_bytes;
            $remainder = substr($x, $start);
            $x = substr($x, 0, -$num_bytes);
        }

        $carry = 0;
        $carry_shift = 8 - $shift;
        for ($i = 0; $i < strlen($x); ++$i) {
            $temp = (ord($x[$i]) >> $shift) | $carry;
            $carry = (ord($x[$i]) << $carry_shift) & 0xFF;
            $x[$i] = chr($temp);
        }
        $x = ltrim($x, chr(0));

        $remainder = chr($carry >> $carry_shift) . $remainder;

        return ltrim($remainder, chr(0));
    }

    // one quirk about how the following functions are implemented is that PHP defines N to be an unsigned long
    // at 32-bits, while java's longs are 64-bits.

    /**
     * Converts 32-bit integers to bytes.
     *
     * @param Integer $x
     * @return String
     * @access private
     */
    function _int2bytes($x)
    {
        return ltrim(pack('N', $x), chr(0));
    }

    /**
     * Converts bytes to 32-bit integers
     *
     * @param String $x
     * @return Integer
     * @access private
     */
    function _bytes2int($x)
    {
        $temp = unpack('Nint', str_pad($x, 4, chr(0), STR_PAD_LEFT));
        return $temp['int'];
    }

    /**
     * DER-encode an integer
     *
     * The ability to DER-encode integers is needed to create RSA public keys for use with OpenSSL
     *
     * @see modPow()
     * @access private
     * @param Integer $length
     * @return String
     */
    function _encodeASN1Length($length)
    {
        if ($length <= 0x7F) {
            return chr($length);
        }

        $temp = ltrim(pack('N', $length), chr(0));
        return pack('Ca*', 0x80 | strlen($temp), $temp);
    }

    /**
     * Single digit division
     *
     * Even if int64 is being used the division operator will return a float64 value
     * if the dividend is not evenly divisible by the divisor. Since a float64 doesn't
     * have the precision of int64 this is a problem so, when int64 is being used,
     * we'll guarantee that the dividend is divisible by first subtracting the remainder.
     *
     * @access private
     * @param Integer $x
     * @param Integer $y
     * @return Integer
     */
    function _safe_divide($x, $y)
    {
        if (MATH_BIGINTEGER_BASE === 26) {
            return (int) ($x / $y);
        }

        // MATH_BIGINTEGER_BASE === 31
        return ($x - ($x % $y)) / $y;
    }
}

}
if (!class_exists('Crypt_Base')) {
    
/**
 * Base Class for all Crypt_* cipher classes
 *
 * PHP versions 4 and 5
 *
 * Internally for phpseclib developers:
 *  If you plan to add a new cipher class, please note following rules:
 *
 *  - The new Crypt_* cipher class should extend Crypt_Base
 *
 *  - Following methods are then required to be overridden/overloaded:
 *
 *    - _encryptBlock()
 *
 *    - _decryptBlock()
 *
 *    - _setupKey()
 *
 *  - All other methods are optional to be overridden/overloaded
 *
 *  - Look at the source code of the current ciphers how they extend Crypt_Base
 *    and take one of them as a start up for the new cipher class.
 *
 *  - Please read all the other comments/notes/hints here also for each class var/method
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_Base
 * @author    Jim Wigginton <terrafrost@php.net>
 * @author    Hans-Juergen Petrich <petrich@tronic-media.com>
 * @copyright MMVII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**#@+
 * @access public
 * @see Crypt_Base::encrypt()
 * @see Crypt_Base::decrypt()
 */
/**
 * Encrypt / decrypt using the Counter mode.
 *
 * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
 */
define('CRYPT_MODE_CTR', -1);
/**
 * Encrypt / decrypt using the Electronic Code Book mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
 */
define('CRYPT_MODE_ECB', 1);
/**
 * Encrypt / decrypt using the Code Book Chaining mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
 */
define('CRYPT_MODE_CBC', 2);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
 */
define('CRYPT_MODE_CFB', 3);
/**
 * Encrypt / decrypt using the Output Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
 */
define('CRYPT_MODE_OFB', 4);
/**
 * Encrypt / decrypt using streaming mode.
 *
 */
define('CRYPT_MODE_STREAM', 5);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_Base::Crypt_Base()
 */
/**
 * Base value for the internal implementation $engine switch
 */
define('CRYPT_MODE_INTERNAL', 1);
/**
 * Base value for the mcrypt implementation $engine switch
 */
define('CRYPT_MODE_MCRYPT', 2);
/**#@-*/

/**
 * Base Class for all Crypt_* cipher classes
 *
 * @package Crypt_Base
 * @author  Jim Wigginton <terrafrost@php.net>
 * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
 * @access  public
 */
class Crypt_Base
{
    /**
     * The Encryption Mode
     *
     * @see Crypt_Base::Crypt_Base()
     * @var Integer
     * @access private
     */
    var $mode;

    /**
     * The Block Length of the block cipher
     *
     * @var Integer
     * @access private
     */
    var $block_size = 16;

    /**
     * The Key
     *
     * @see Crypt_Base::setKey()
     * @var String
     * @access private
     */
    var $key = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";

    /**
     * The Initialization Vector
     *
     * @see Crypt_Base::setIV()
     * @var String
     * @access private
     */
    var $iv;

    /**
     * A "sliding" Initialization Vector
     *
     * @see Crypt_Base::enableContinuousBuffer()
     * @see Crypt_Base::_clearBuffers()
     * @var String
     * @access private
     */
    var $encryptIV;

    /**
     * A "sliding" Initialization Vector
     *
     * @see Crypt_Base::enableContinuousBuffer()
     * @see Crypt_Base::_clearBuffers()
     * @var String
     * @access private
     */
    var $decryptIV;

    /**
     * Continuous Buffer status
     *
     * @see Crypt_Base::enableContinuousBuffer()
     * @var Boolean
     * @access private
     */
    var $continuousBuffer = false;

    /**
     * Encryption buffer for CTR, OFB and CFB modes
     *
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::_clearBuffers()
     * @var Array
     * @access private
     */
    var $enbuffer;

    /**
     * Decryption buffer for CTR, OFB and CFB modes
     *
     * @see Crypt_Base::decrypt()
     * @see Crypt_Base::_clearBuffers()
     * @var Array
     * @access private
     */
    var $debuffer;

    /**
     * mcrypt resource for encryption
     *
     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
     *
     * @see Crypt_Base::encrypt()
     * @var Resource
     * @access private
     */
    var $enmcrypt;

    /**
     * mcrypt resource for decryption
     *
     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
     *
     * @see Crypt_Base::decrypt()
     * @var Resource
     * @access private
     */
    var $demcrypt;

    /**
     * Does the enmcrypt resource need to be (re)initialized?
     *
     * @see Crypt_Twofish::setKey()
     * @see Crypt_Twofish::setIV()
     * @var Boolean
     * @access private
     */
    var $enchanged = true;

    /**
     * Does the demcrypt resource need to be (re)initialized?
     *
     * @see Crypt_Twofish::setKey()
     * @see Crypt_Twofish::setIV()
     * @var Boolean
     * @access private
     */
    var $dechanged = true;

    /**
     * mcrypt resource for CFB mode
     *
     * mcrypt's CFB mode, in (and only in) buffered context,
     * is broken, so phpseclib implements the CFB mode by it self,
     * even when the mcrypt php extension is available.
     *
     * In order to do the CFB-mode work (fast) phpseclib
     * use a separate ECB-mode mcrypt resource.
     *
     * @link http://phpseclib.sourceforge.net/cfb-demo.phps
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @see Crypt_Base::_setupMcrypt()
     * @var Resource
     * @access private
     */
    var $ecb;

    /**
     * Optimizing value while CFB-encrypting
     *
     * Only relevant if $continuousBuffer enabled
     * and $engine == CRYPT_MODE_MCRYPT
     *
     * It's faster to re-init $enmcrypt if
     * $buffer bytes > $cfb_init_len than
     * using the $ecb resource furthermore.
     *
     * This value depends of the chosen cipher
     * and the time it would be needed for it's
     * initialization [by mcrypt_generic_init()]
     * which, typically, depends on the complexity
     * on its internaly Key-expanding algorithm.
     *
     * @see Crypt_Base::encrypt()
     * @var Integer
     * @access private
     */
    var $cfb_init_len = 600;

    /**
     * Does internal cipher state need to be (re)initialized?
     *
     * @see setKey()
     * @see setIV()
     * @see disableContinuousBuffer()
     * @var Boolean
     * @access private
     */
    var $changed = true;

    /**
     * Padding status
     *
     * @see Crypt_Base::enablePadding()
     * @var Boolean
     * @access private
     */
    var $padding = true;

    /**
     * Is the mode one that is paddable?
     *
     * @see Crypt_Base::Crypt_Base()
     * @var Boolean
     * @access private
     */
    var $paddable = false;

    /**
     * Holds which crypt engine internaly should be use,
     * which will be determined automatically on __construct()
     *
     * Currently available $engines are:
     * - CRYPT_MODE_MCRYPT   (fast, php-extension: mcrypt, extension_loaded('mcrypt') required)
     * - CRYPT_MODE_INTERNAL (slower, pure php-engine, no php-extension required)
     *
     * In the pipeline... maybe. But currently not available:
     * - CRYPT_MODE_OPENSSL  (very fast, php-extension: openssl, extension_loaded('openssl') required)
     *
     * If possible, CRYPT_MODE_MCRYPT will be used for each cipher.
     * Otherwise CRYPT_MODE_INTERNAL
     *
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @var Integer
     * @access private
     */
    var $engine;

    /**
     * The mcrypt specific name of the cipher
     *
     * Only used if $engine == CRYPT_MODE_MCRYPT
     *
     * @link http://www.php.net/mcrypt_module_open
     * @link http://www.php.net/mcrypt_list_algorithms
     * @see Crypt_Base::_setupMcrypt()
     * @var String
     * @access private
     */
    var $cipher_name_mcrypt;

    /**
     * The default password key_size used by setPassword()
     *
     * @see Crypt_Base::setPassword()
     * @var Integer
     * @access private
     */
    var $password_key_size = 32;

    /**
     * The default salt used by setPassword()
     *
     * @see Crypt_Base::setPassword()
     * @var String
     * @access private
     */
    var $password_default_salt = 'phpseclib/salt';

    /**
     * The namespace used by the cipher for its constants.
     *
     * ie: AES.php is using CRYPT_AES_MODE_* for its constants
     *     so $const_namespace is AES
     *
     *     DES.php is using CRYPT_DES_MODE_* for its constants
     *     so $const_namespace is DES... and so on
     *
     * All CRYPT_<$const_namespace>_MODE_* are aliases of
     * the generic CRYPT_MODE_* constants, so both could be used
     * for each cipher.
     *
     * Example:
     * $aes = new Crypt_AES(CRYPT_AES_MODE_CFB); // $aes will operate in cfb mode
     * $aes = new Crypt_AES(CRYPT_MODE_CFB);     // identical
     *
     * @see Crypt_Base::Crypt_Base()
     * @var String
     * @access private
     */
    var $const_namespace;

    /**
     * The name of the performance-optimized callback function
     *
     * Used by encrypt() / decrypt()
     * only if $engine == CRYPT_MODE_INTERNAL
     *
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @see Crypt_Base::_setupInlineCrypt()
     * @see Crypt_Base::$use_inline_crypt
     * @var Callback
     * @access private
     */
    var $inline_crypt;

    /**
     * Holds whether performance-optimized $inline_crypt() can/should be used.
     *
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @see Crypt_Base::inline_crypt
     * @var mixed
     * @access private
     */
    var $use_inline_crypt;

    /**
     * Default Constructor.
     *
     * Determines whether or not the mcrypt extension should be used.
     *
     * $mode could be:
     *
     * - CRYPT_MODE_ECB
     *
     * - CRYPT_MODE_CBC
     *
     * - CRYPT_MODE_CTR
     *
     * - CRYPT_MODE_CFB
     *
     * - CRYPT_MODE_OFB
     *
     * (or the alias constants of the chosen cipher, for example for AES: CRYPT_AES_MODE_ECB or CRYPT_AES_MODE_CBC ...)
     *
     * If not explicitly set, CRYPT_MODE_CBC will be used.
     *
     * @param optional Integer $mode
     * @access public
     */
    function Crypt_Base($mode = CRYPT_MODE_CBC)
    {
        $const_crypt_mode = 'CRYPT_' . $this->const_namespace . '_MODE';

        // Determining the availibility of mcrypt support for the cipher
        if (!defined($const_crypt_mode)) {
            switch (true) {
                case extension_loaded('mcrypt') && in_array($this->cipher_name_mcrypt, mcrypt_list_algorithms()):
                    define($const_crypt_mode, CRYPT_MODE_MCRYPT);
                    break;
                default:
                    define($const_crypt_mode, CRYPT_MODE_INTERNAL);
            }
        }

        // Determining which internal $engine should be used.
        // The fastes possible first.
        switch (true) {
            case empty($this->cipher_name_mcrypt): // The cipher module has no mcrypt-engine support at all so we force CRYPT_MODE_INTERNAL
                $this->engine = CRYPT_MODE_INTERNAL;
                break;
            case constant($const_crypt_mode) == CRYPT_MODE_MCRYPT:
                $this->engine = CRYPT_MODE_MCRYPT;
                break;
            default:
                $this->engine = CRYPT_MODE_INTERNAL;
        }

        // $mode dependent settings
        switch ($mode) {
            case CRYPT_MODE_ECB:
                $this->paddable = true;
                $this->mode = $mode;
                break;
            case CRYPT_MODE_CTR:
            case CRYPT_MODE_CFB:
            case CRYPT_MODE_OFB:
            case CRYPT_MODE_STREAM:
                $this->mode = $mode;
                break;
            case CRYPT_MODE_CBC:
            default:
                $this->paddable = true;
                $this->mode = CRYPT_MODE_CBC;
        }

        // Determining whether inline crypting can be used by the cipher
        if ($this->use_inline_crypt !== false && function_exists('create_function')) {
            $this->use_inline_crypt = true;
        }
    }

    /**
     * Sets the initialization vector. (optional)
     *
     * SetIV is not required when CRYPT_MODE_ECB (or ie for AES: CRYPT_AES_MODE_ECB) is being used.  If not explicitly set, it'll be assumed
     * to be all zero's.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @access public
     * @param String $iv
     */
    function setIV($iv)
    {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }

        $this->iv = $iv;
        $this->changed = true;
    }

    /**
     * Sets the key.
     *
     * The min/max length(s) of the key depends on the cipher which is used.
     * If the key not fits the length(s) of the cipher it will paded with null bytes
     * up to the closest valid key length.  If the key is more than max length,
     * we trim the excess bits.
     *
     * If the key is not explicitly set, it'll be assumed to be all null bytes.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @access public
     * @param String $key
     */
    function setKey($key)
    {
        $this->key = $key;
        $this->changed = true;
    }

    /**
     * Sets the password.
     *
     * Depending on what $method is set to, setPassword()'s (optional) parameters are as follows:
     *     {@link http://en.wikipedia.org/wiki/PBKDF2 pbkdf2} or pbkdf1:
     *         $hash, $salt, $count, $dkLen
     *
     *         Where $hash (default = sha1) currently supports the following hashes: see: Crypt/Hash.php
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see Crypt/Hash.php
     * @param String $password
     * @param optional String $method
     * @return Boolean
     * @access public
     */
    function setPassword($password, $method = 'pbkdf2')
    {
        $key = '';

        switch ($method) {
            default: // 'pbkdf2' or 'pbkdf1'
                $func_args = func_get_args();

                // Hash function
                $hash = isset($func_args[2]) ? $func_args[2] : 'sha1';

                // WPA and WPA2 use the SSID as the salt
                $salt = isset($func_args[3]) ? $func_args[3] : $this->password_default_salt;

                // RFC2898#section-4.2 uses 1,000 iterations by default
                // WPA and WPA2 use 4,096.
                $count = isset($func_args[4]) ? $func_args[4] : 1000;

                // Keylength
                if (isset($func_args[5])) {
                    $dkLen = $func_args[5];
                } else {
                    $dkLen = $method == 'pbkdf1' ? 2 * $this->password_key_size : $this->password_key_size;
                }

                switch (true) {
                    case $method == 'pbkdf1':
                        if (!class_exists('Crypt_Hash')) {
                            include_once 'Crypt/Hash.php';
                        }
                        $hashObj = new Crypt_Hash();
                        $hashObj->setHash($hash);
                        if ($dkLen > $hashObj->getLength()) {
                            user_error('Derived key too long');
                            return false;
                        }
                        $t = $password . $salt;
                        for ($i = 0; $i < $count; ++$i) {
                            $t = $hashObj->hash($t);
                        }
                        $key = substr($t, 0, $dkLen);

                        $this->setKey(substr($key, 0, $dkLen >> 1));
                        $this->setIV(substr($key, $dkLen >> 1));

                        return true;
                    // Determining if php[>=5.5.0]'s hash_pbkdf2() function avail- and useable
                    case !function_exists('hash_pbkdf2'):
                    case !function_exists('hash_algos'):
                    case !in_array($hash, hash_algos()):
                        if (!class_exists('Crypt_Hash')) {
                            include_once 'Crypt/Hash.php';
                        }
                        $i = 1;
                        while (strlen($key) < $dkLen) {
                            $hmac = new Crypt_Hash();
                            $hmac->setHash($hash);
                            $hmac->setKey($password);
                            $f = $u = $hmac->hash($salt . pack('N', $i++));
                            for ($j = 2; $j <= $count; ++$j) {
                                $u = $hmac->hash($u);
                                $f^= $u;
                            }
                            $key.= $f;
                        }
                        $key = substr($key, 0, $dkLen);
                        break;
                    default:
                        $key = hash_pbkdf2($hash, $password, $salt, $count, $dkLen, true);
                }
        }

        $this->setKey($key);

        return true;
    }

    /**
     * Encrypts a message.
     *
     * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size. Other cipher
     * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's
     * necessary are discussed in the following
     * URL:
     *
     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
     *
     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
     * strlen($plaintext) will still need to be a multiple of the block size, however, arbitrary values can be added to make it that
     * length.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see Crypt_Base::decrypt()
     * @access public
     * @param String $plaintext
     * @return String $cipertext
     */
    function encrypt($plaintext)
    {
        if ($this->engine == CRYPT_MODE_MCRYPT) {
            if ($this->changed) {
                $this->_setupMcrypt();
                $this->changed = false;
            }
            if ($this->enchanged) {
                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
                $this->enchanged = false;
            }

            // re: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}
            // using mcrypt's default handing of CFB the above would output two different things.  using phpseclib's
            // rewritten CFB implementation the above outputs the same thing twice.
            if ($this->mode == CRYPT_MODE_CFB && $this->continuousBuffer) {
                $block_size = $this->block_size;
                $iv = &$this->encryptIV;
                $pos = &$this->enbuffer['pos'];
                $len = strlen($plaintext);
                $ciphertext = '';
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                    $this->enbuffer['enmcrypt_init'] = true;
                }
                if ($len >= $block_size) {
                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {
                        if ($this->enbuffer['enmcrypt_init'] === true) {
                            mcrypt_generic_init($this->enmcrypt, $this->key, $iv);
                            $this->enbuffer['enmcrypt_init'] = false;
                        }
                        $ciphertext.= mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));
                        $iv = substr($ciphertext, -$block_size);
                        $len%= $block_size;
                    } else {
                        while ($len >= $block_size) {
                            $iv = mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);
                            $ciphertext.= $iv;
                            $len-= $block_size;
                            $i+= $block_size;
                        }
                    }
                }

                if ($len) {
                    $iv = mcrypt_generic($this->ecb, $iv);
                    $block = $iv ^ substr($plaintext, -$len);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext.= $block;
                    $pos = $len;
                }

                return $ciphertext;
            }

            if ($this->paddable) {
                $plaintext = $this->_pad($plaintext);
            }

            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);

            if (!$this->continuousBuffer) {
                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
            }

            return $ciphertext;
        }

        if ($this->changed) {
            $this->_setup();
            $this->changed = false;
        }
        if ($this->use_inline_crypt) {
            $inline = $this->inline_crypt;
            return $inline('encrypt', $this, $plaintext);
        }
        if ($this->paddable) {
            $plaintext = $this->_pad($plaintext);
        }

        $buffer = &$this->enbuffer;
        $block_size = $this->block_size;
        $ciphertext = '';
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));
                }
                break;
            case CRYPT_MODE_CBC:
                $xor = $this->encryptIV;
                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                    $block = substr($plaintext, $i, $block_size);
                    $block = $this->_encryptBlock($block ^ $xor);
                    $xor = $block;
                    $ciphertext.= $block;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                }
                break;
            case CRYPT_MODE_CTR:
                $xor = $this->encryptIV;
                if (strlen($buffer['encrypted'])) {
                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['encrypted'])) {
                            $buffer['encrypted'].= $this->_encryptBlock($this->_generateXor($xor, $block_size));
                        }
                        $key = $this->_stringShift($buffer['encrypted'], $block_size);
                        $ciphertext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        $key = $this->_encryptBlock($this->_generateXor($xor, $block_size));
                        $ciphertext.= $block ^ $key;
                    }
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                        $buffer['encrypted'] = substr($key, $start) . $buffer['encrypted'];
                    }
                }
                break;
            case CRYPT_MODE_CFB:
                // cfb loosely routines inspired by openssl's:
                // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}
                if ($this->continuousBuffer) {
                    $iv = &$this->encryptIV;
                    $pos = &$buffer['pos'];
                } else {
                    $iv = $this->encryptIV;
                    $pos = 0;
                }
                $len = strlen($plaintext);
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                }
                while ($len >= $block_size) {
                    $iv = $this->_encryptBlock($iv) ^ substr($plaintext, $i, $block_size);
                    $ciphertext.= $iv;
                    $len-= $block_size;
                    $i+= $block_size;
                }
                if ($len) {
                    $iv = $this->_encryptBlock($iv);
                    $block = $iv ^ substr($plaintext, $i);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext.= $block;
                    $pos = $len;
                }
                break;
            case CRYPT_MODE_OFB:
                $xor = $this->encryptIV;
                if (strlen($buffer['xor'])) {
                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['xor'])) {
                            $xor = $this->_encryptBlock($xor);
                            $buffer['xor'].= $xor;
                        }
                        $key = $this->_stringShift($buffer['xor'], $block_size);
                        $ciphertext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
                        $xor = $this->_encryptBlock($xor);
                        $ciphertext.= substr($plaintext, $i, $block_size) ^ $xor;
                    }
                    $key = $xor;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                         $buffer['xor'] = substr($key, $start) . $buffer['xor'];
                    }
                }
                break;
            case CRYPT_MODE_STREAM:
                $ciphertext = $this->_encryptBlock($plaintext);
                break;
        }

        return $ciphertext;
    }

    /**
     * Decrypts a message.
     *
     * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until
     * it is.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see Crypt_Base::encrypt()
     * @access public
     * @param String $ciphertext
     * @return String $plaintext
     */
    function decrypt($ciphertext)
    {
        if ($this->engine == CRYPT_MODE_MCRYPT) {
            $block_size = $this->block_size;
            if ($this->changed) {
                $this->_setupMcrypt();
                $this->changed = false;
            }
            if ($this->dechanged) {
                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
                $this->dechanged = false;
            }

            if ($this->mode == CRYPT_MODE_CFB && $this->continuousBuffer) {
                $iv = &$this->decryptIV;
                $pos = &$this->debuffer['pos'];
                $len = strlen($ciphertext);
                $plaintext = '';
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
                }
                if ($len >= $block_size) {
                    $cb = substr($ciphertext, $i, $len - $len % $block_size);
                    $plaintext.= mcrypt_generic($this->ecb, $iv . $cb) ^ $cb;
                    $iv = substr($cb, -$block_size);
                    $len%= $block_size;
                }
                if ($len) {
                    $iv = mcrypt_generic($this->ecb, $iv);
                    $plaintext.= $iv ^ substr($ciphertext, -$len);
                    $iv = substr_replace($iv, substr($ciphertext, -$len), 0, $len);
                    $pos = $len;
                }

                return $plaintext;
            }

            if ($this->paddable) {
                // we pad with chr(0) since that's what mcrypt_generic does.  to quote from {@link http://www.php.net/function.mcrypt-generic}:
                // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
                $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($block_size - strlen($ciphertext) % $block_size) % $block_size, chr(0));
            }

            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);

            if (!$this->continuousBuffer) {
                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
            }

            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
        }

        if ($this->changed) {
            $this->_setup();
            $this->changed = false;
        }
        if ($this->use_inline_crypt) {
            $inline = $this->inline_crypt;
            return $inline('decrypt', $this, $ciphertext);
        }

        $block_size = $this->block_size;
        if ($this->paddable) {
            // we pad with chr(0) since that's what mcrypt_generic does [...]
            $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($block_size - strlen($ciphertext) % $block_size) % $block_size, chr(0));
        }

        $buffer = &$this->debuffer;
        $plaintext = '';
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));
                }
                break;
            case CRYPT_MODE_CBC:
                $xor = $this->decryptIV;
                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                    $block = substr($ciphertext, $i, $block_size);
                    $plaintext.= $this->_decryptBlock($block) ^ $xor;
                    $xor = $block;
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                }
                break;
            case CRYPT_MODE_CTR:
                $xor = $this->decryptIV;
                if (strlen($buffer['ciphertext'])) {
                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['ciphertext'])) {
                            $buffer['ciphertext'].= $this->_encryptBlock($this->_generateXor($xor, $block_size));
                        }
                        $key = $this->_stringShift($buffer['ciphertext'], $block_size);
                        $plaintext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        $key = $this->_encryptBlock($this->_generateXor($xor, $block_size));
                        $plaintext.= $block ^ $key;
                    }
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                    if ($start = strlen($ciphertext) % $block_size) {
                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
                    }
                }
                break;
            case CRYPT_MODE_CFB:
                if ($this->continuousBuffer) {
                    $iv = &$this->decryptIV;
                    $pos = &$buffer['pos'];
                } else {
                    $iv = $this->decryptIV;
                    $pos = 0;
                }
                $len = strlen($ciphertext);
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
                }
                while ($len >= $block_size) {
                    $iv = $this->_encryptBlock($iv);
                    $cb = substr($ciphertext, $i, $block_size);
                    $plaintext.= $iv ^ $cb;
                    $iv = $cb;
                    $len-= $block_size;
                    $i+= $block_size;
                }
                if ($len) {
                    $iv = $this->_encryptBlock($iv);
                    $plaintext.= $iv ^ substr($ciphertext, $i);
                    $iv = substr_replace($iv, substr($ciphertext, $i), 0, $len);
                    $pos = $len;
                }
                break;
            case CRYPT_MODE_OFB:
                $xor = $this->decryptIV;
                if (strlen($buffer['xor'])) {
                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['xor'])) {
                            $xor = $this->_encryptBlock($xor);
                            $buffer['xor'].= $xor;
                        }
                        $key = $this->_stringShift($buffer['xor'], $block_size);
                        $plaintext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
                        $xor = $this->_encryptBlock($xor);
                        $plaintext.= substr($ciphertext, $i, $block_size) ^ $xor;
                    }
                    $key = $xor;
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                    if ($start = strlen($ciphertext) % $block_size) {
                         $buffer['xor'] = substr($key, $start) . $buffer['xor'];
                    }
                }
                break;
            case CRYPT_MODE_STREAM:
                $plaintext = $this->_decryptBlock($ciphertext);
                break;
        }
        return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
    }

    /**
     * Pad "packets".
     *
     * Block ciphers working by encrypting between their specified [$this->]block_size at a time
     * If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to
     * pad the input so that it is of the proper length.
     *
     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,
     * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
     * transmitted separately)
     *
     * @see Crypt_Base::disablePadding()
     * @access public
     */
    function enablePadding()
    {
        $this->padding = true;
    }

    /**
     * Do not pad packets.
     *
     * @see Crypt_Base::enablePadding()
     * @access public
     */
    function disablePadding()
    {
        $this->padding = false;
    }

    /**
     * Treat consecutive "packets" as if they are a continuous buffer.
     *
     * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
     * will yield different outputs:
     *
     * <code>
     *    echo $rijndael->encrypt(substr($plaintext,  0, 16));
     *    echo $rijndael->encrypt(substr($plaintext, 16, 16));
     * </code>
     * <code>
     *    echo $rijndael->encrypt($plaintext);
     * </code>
     *
     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
     * another, as demonstrated with the following:
     *
     * <code>
     *    $rijndael->encrypt(substr($plaintext, 0, 16));
     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
     * </code>
     * <code>
     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
     * </code>
     *
     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
     *
     * Put another way, when the continuous buffer is enabled, the state of the Crypt_*() object changes after each
     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
     * however, they are also less intuitive and more likely to cause you problems.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see Crypt_Base::disableContinuousBuffer()
     * @access public
     */
    function enableContinuousBuffer()
    {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }

        $this->continuousBuffer = true;
    }

    /**
     * Treat consecutive packets as if they are a discontinuous buffer.
     *
     * The default behavior.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see Crypt_Base::enableContinuousBuffer()
     * @access public
     */
    function disableContinuousBuffer()
    {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }
        if (!$this->continuousBuffer) {
            return;
        }

        $this->continuousBuffer = false;
        $this->changed = true;
    }

    /**
     * Encrypts a block
     *
     * Note: Must extend by the child Crypt_* class
     *
     * @access private
     * @param String $in
     * @return String
     */
    function _encryptBlock($in)
    {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=')  ? __METHOD__ : __FUNCTION__)  . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }

    /**
     * Decrypts a block
     *
     * Note: Must extend by the child Crypt_* class
     *
     * @access private
     * @param String $in
     * @return String
     */
    function _decryptBlock($in)
    {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=')  ? __METHOD__ : __FUNCTION__)  . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }

    /**
     * Setup the key (expansion)
     *
     * Only used if $engine == CRYPT_MODE_INTERNAL
     *
     * Note: Must extend by the child Crypt_* class
     *
     * @see Crypt_Base::_setup()
     * @access private
     */
    function _setupKey()
    {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=')  ? __METHOD__ : __FUNCTION__)  . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }

    /**
     * Setup the CRYPT_MODE_INTERNAL $engine
     *
     * (re)init, if necessary, the internal cipher $engine and flush all $buffers
     * Used (only) if $engine == CRYPT_MODE_INTERNAL
     *
     * _setup() will be called each time if $changed === true
     * typically this happens when using one or more of following public methods:
     *
     * - setKey()
     *
     * - setIV()
     *
     * - disableContinuousBuffer()
     *
     * - First run of encrypt() / decrypt() with no init-settings
     *
     * Internally: _setup() is called always before(!) en/decryption.
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see setKey()
     * @see setIV()
     * @see disableContinuousBuffer()
     * @access private
     */
    function _setup()
    {
        $this->_clearBuffers();
        $this->_setupKey();

        if ($this->use_inline_crypt) {
            $this->_setupInlineCrypt();
        }
    }

    /**
     * Setup the CRYPT_MODE_MCRYPT $engine
     *
     * (re)init, if necessary, the (ext)mcrypt resources and flush all $buffers
     * Used (only) if $engine = CRYPT_MODE_MCRYPT
     *
     * _setupMcrypt() will be called each time if $changed === true
     * typically this happens when using one or more of following public methods:
     *
     * - setKey()
     *
     * - setIV()
     *
     * - disableContinuousBuffer()
     *
     * - First run of encrypt() / decrypt()
     *
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @see setKey()
     * @see setIV()
     * @see disableContinuousBuffer()
     * @access private
     */
    function _setupMcrypt()
    {
        $this->_clearBuffers();
        $this->enchanged = $this->dechanged = true;

        if (!isset($this->enmcrypt)) {
            static $mcrypt_modes = array(
                CRYPT_MODE_CTR    => 'ctr',
                CRYPT_MODE_ECB    => MCRYPT_MODE_ECB,
                CRYPT_MODE_CBC    => MCRYPT_MODE_CBC,
                CRYPT_MODE_CFB    => 'ncfb',
                CRYPT_MODE_OFB    => MCRYPT_MODE_NOFB,
                CRYPT_MODE_STREAM => MCRYPT_MODE_STREAM,
            );

            $this->demcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');
            $this->enmcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');

            // we need the $ecb mcrypt resource (only) in MODE_CFB with enableContinuousBuffer()
            // to workaround mcrypt's broken ncfb implementation in buffered mode
            // see: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}
            if ($this->mode == CRYPT_MODE_CFB) {
                $this->ecb = mcrypt_module_open($this->cipher_name_mcrypt, '', MCRYPT_MODE_ECB, '');
            }

        } // else should mcrypt_generic_deinit be called?

        if ($this->mode == CRYPT_MODE_CFB) {
            mcrypt_generic_init($this->ecb, $this->key, str_repeat("\0", $this->block_size));
        }
    }

    /**
     * Pads a string
     *
     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.
     * $this->block_size - (strlen($text) % $this->block_size) bytes are added, each of which is equal to
     * chr($this->block_size - (strlen($text) % $this->block_size)
     *
     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
     * and padding will, hence forth, be enabled.
     *
     * @see Crypt_Base::_unpad()
     * @param String $text
     * @access private
     * @return String
     */
    function _pad($text)
    {
        $length = strlen($text);

        if (!$this->padding) {
            if ($length % $this->block_size == 0) {
                return $text;
            } else {
                user_error("The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})");
                $this->padding = true;
            }
        }

        $pad = $this->block_size - ($length % $this->block_size);

        return str_pad($text, $length + $pad, chr($pad));
    }

    /**
     * Unpads a string.
     *
     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
     * and false will be returned.
     *
     * @see Crypt_Base::_pad()
     * @param String $text
     * @access private
     * @return String
     */
    function _unpad($text)
    {
        if (!$this->padding) {
            return $text;
        }

        $length = ord($text[strlen($text) - 1]);

        if (!$length || $length > $this->block_size) {
            return false;
        }

        return substr($text, 0, -$length);
    }

    /**
     * Clears internal buffers
     *
     * Clearing/resetting the internal buffers is done everytime
     * after disableContinuousBuffer() or on cipher $engine (re)init
     * ie after setKey() or setIV()
     *
     * Note: Could, but not must, extend by the child Crypt_* class
     *
     * @access public
     */
    function _clearBuffers()
    {
        $this->enbuffer = array('encrypted'  => '', 'xor' => '', 'pos' => 0, 'enmcrypt_init' => true);
        $this->debuffer = array('ciphertext' => '', 'xor' => '', 'pos' => 0, 'demcrypt_init' => true);

        // mcrypt's handling of invalid's $iv:
        // $this->encryptIV = $this->decryptIV = strlen($this->iv) == $this->block_size ? $this->iv : str_repeat("\0", $this->block_size);
        $this->encryptIV = $this->decryptIV = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, "\0");
    }

    /**
     * String Shift
     *
     * Inspired by array_shift
     *
     * @param String $string
     * @param optional Integer $index
     * @access private
     * @return String
     */
    function _stringShift(&$string, $index = 1)
    {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }

    /**
     * Generate CTR XOR encryption key
     *
     * Encrypt the output of this and XOR it against the ciphertext / plaintext to get the
     * plaintext / ciphertext in CTR mode.
     *
     * @see Crypt_Base::decrypt()
     * @see Crypt_Base::encrypt()
     * @param String $iv
     * @param Integer $length
     * @access private
     * @return String $xor
     */
    function _generateXor(&$iv, $length)
    {
        $xor = '';
        $block_size = $this->block_size;
        $num_blocks = floor(($length + ($block_size - 1)) / $block_size);
        for ($i = 0; $i < $num_blocks; $i++) {
            $xor.= $iv;
            for ($j = 4; $j <= $block_size; $j+= 4) {
                $temp = substr($iv, -$j, 4);
                switch ($temp) {
                    case "\xFF\xFF\xFF\xFF":
                        $iv = substr_replace($iv, "\x00\x00\x00\x00", -$j, 4);
                        break;
                    case "\x7F\xFF\xFF\xFF":
                        $iv = substr_replace($iv, "\x80\x00\x00\x00", -$j, 4);
                        break 2;
                    default:
                        extract(unpack('Ncount', $temp));
                        $iv = substr_replace($iv, pack('N', $count + 1), -$j, 4);
                        break 2;
                }
            }
        }

        return $xor;
    }

    /**
     * Setup the performance-optimized function for de/encrypt()
     *
     * Stores the created (or existing) callback function-name
     * in $this->inline_crypt
     *
     * Internally for phpseclib developers:
     *
     *     _setupInlineCrypt() would be called only if:
     *
     *     - $engine == CRYPT_MODE_INTERNAL and
     *
     *     - $use_inline_crypt === true
     *
     *     - each time on _setup(), after(!) _setupKey()
     *
     *
     *     This ensures that _setupInlineCrypt() has always a
     *     full ready2go initializated internal cipher $engine state
     *     where, for example, the keys allready expanded,
     *     keys/block_size calculated and such.
     *
     *     It is, each time if called, the responsibility of _setupInlineCrypt():
     *
     *     - to set $this->inline_crypt to a valid and fully working callback function
     *       as a (faster) replacement for encrypt() / decrypt()
     *
     *     - NOT to create unlimited callback functions (for memory reasons!)
     *       no matter how often _setupInlineCrypt() would be called. At some
     *       point of amount they must be generic re-useable.
     *
     *     - the code of _setupInlineCrypt() it self,
     *       and the generated callback code,
     *       must be, in following order:
     *       - 100% safe
     *       - 100% compatible to encrypt()/decrypt()
     *       - using only php5+ features/lang-constructs/php-extensions if
     *         compatibility (down to php4) or fallback is provided
     *       - readable/maintainable/understandable/commented and... not-cryptic-styled-code :-)
     *       - >= 10% faster than encrypt()/decrypt() [which is, by the way,
     *         the reason for the existence of _setupInlineCrypt() :-)]
     *       - memory-nice
     *       - short (as good as possible)
     *
     * Note: - _setupInlineCrypt() is using _createInlineCryptFunction() to create the full callback function code.
     *       - In case of using inline crypting, _setupInlineCrypt() must extend by the child Crypt_* class.
     *       - The following variable names are reserved:
     *         - $_*  (all variable names prefixed with an underscore)
     *         - $self (object reference to it self. Do not use $this, but $self instead)
     *         - $in (the content of $in has to en/decrypt by the generated code)
     *       - The callback function should not use the 'return' statement, but en/decrypt'ing the content of $in only
     *
     *
     * @see Crypt_Base::_setup()
     * @see Crypt_Base::_createInlineCryptFunction()
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @access private
     */
    function _setupInlineCrypt()
    {
        // If a Crypt_* class providing inline crypting it must extend _setupInlineCrypt()

        // If, for any reason, an extending Crypt_Base() Crypt_* class
        // not using inline crypting then it must be ensured that: $this->use_inline_crypt = false
        // ie in the class var declaration of $use_inline_crypt in general for the Crypt_* class,
        // in the constructor at object instance-time
        // or, if it's runtime-specific, at runtime

        $this->use_inline_crypt = false;
    }

    /**
     * Creates the performance-optimized function for en/decrypt()
     *
     * Internally for phpseclib developers:
     *
     *    _createInlineCryptFunction():
     *
     *    - merge the $cipher_code [setup'ed by _setupInlineCrypt()]
     *      with the current [$this->]mode of operation code
     *
     *    - create the $inline function, which called by encrypt() / decrypt()
     *      as its replacement to speed up the en/decryption operations.
     *
     *    - return the name of the created $inline callback function
     *
     *    - used to speed up en/decryption
     *
     *
     *
     *    The main reason why can speed up things [up to 50%] this way are:
     *
     *    - using variables more effective then regular.
     *      (ie no use of expensive arrays but integers $k_0, $k_1 ...
     *      or even, for example, the pure $key[] values hardcoded)
     *
     *    - avoiding 1000's of function calls of ie _encryptBlock()
     *      but inlining the crypt operations.
     *      in the mode of operation for() loop.
     *
     *    - full loop unroll the (sometimes key-dependent) rounds
     *      avoiding this way ++$i counters and runtime-if's etc...
     *
     *    The basic code architectur of the generated $inline en/decrypt()
     *    lambda function, in pseudo php, is:
     *
     *    <code>
     *    +----------------------------------------------------------------------------------------------+
     *    | callback $inline = create_function:                                                          |
     *    | lambda_function_0001_crypt_ECB($action, $text)                                               |
     *    | {                                                                                            |
     *    |     INSERT PHP CODE OF:                                                                      |
     *    |     $cipher_code['init_crypt'];                  // general init code.                       |
     *    |                                                  // ie: $sbox'es declarations used for       |
     *    |                                                  //     encrypt and decrypt'ing.             |
     *    |                                                                                              |
     *    |     switch ($action) {                                                                       |
     *    |         case 'encrypt':                                                                      |
     *    |             INSERT PHP CODE OF:                                                              |
     *    |             $cipher_code['init_encrypt'];       // encrypt sepcific init code.               |
     *    |                                                    ie: specified $key or $box                |
     *    |                                                        declarations for encrypt'ing.         |
     *    |                                                                                              |
     *    |             foreach ($ciphertext) {                                                          |
     *    |                 $in = $block_size of $ciphertext;                                            |
     *    |                                                                                              |
     *    |                 INSERT PHP CODE OF:                                                          |
     *    |                 $cipher_code['encrypt_block'];  // encrypt's (string) $in, which is always:  |
     *    |                                                 // strlen($in) == $this->block_size          |
     *    |                                                 // here comes the cipher algorithm in action |
     *    |                                                 // for encryption.                           |
     *    |                                                 // $cipher_code['encrypt_block'] has to      |
     *    |                                                 // encrypt the content of the $in variable   |
     *    |                                                                                              |
     *    |                 $plaintext .= $in;                                                           |
     *    |             }                                                                                |
     *    |             return $plaintext;                                                               |
     *    |                                                                                              |
     *    |         case 'decrypt':                                                                      |
     *    |             INSERT PHP CODE OF:                                                              |
     *    |             $cipher_code['init_decrypt'];       // decrypt sepcific init code                |
     *    |                                                    ie: specified $key or $box                |
     *    |                                                        declarations for decrypt'ing.         |
     *    |             foreach ($plaintext) {                                                           |
     *    |                 $in = $block_size of $plaintext;                                             |
     *    |                                                                                              |
     *    |                 INSERT PHP CODE OF:                                                          |
     *    |                 $cipher_code['decrypt_block'];  // decrypt's (string) $in, which is always   |
     *    |                                                 // strlen($in) == $this->block_size          |
     *    |                                                 // here comes the cipher algorithm in action |
     *    |                                                 // for decryption.                           |
     *    |                                                 // $cipher_code['decrypt_block'] has to      |
     *    |                                                 // decrypt the content of the $in variable   |
     *    |                 $ciphertext .= $in;                                                          |
     *    |             }                                                                                |
     *    |             return $ciphertext;                                                              |
     *    |     }                                                                                        |
     *    | }                                                                                            |
     *    +----------------------------------------------------------------------------------------------+
     *    </code>
     *
     *    See also the Crypt_*::_setupInlineCrypt()'s for
     *    productive inline $cipher_code's how they works.
     *
     *    Structure of:
     *    <code>
     *    $cipher_code = array(
     *        'init_crypt'    => (string) '', // optional
     *        'init_encrypt'  => (string) '', // optional
     *        'init_decrypt'  => (string) '', // optional
     *        'encrypt_block' => (string) '', // required
     *        'decrypt_block' => (string) ''  // required
     *    );
     *    </code>
     *
     * @see Crypt_Base::_setupInlineCrypt()
     * @see Crypt_Base::encrypt()
     * @see Crypt_Base::decrypt()
     * @param Array $cipher_code
     * @access private
     * @return String (the name of the created callback function)
     */
    function _createInlineCryptFunction($cipher_code)
    {
        $block_size = $this->block_size;

        // optional
        $init_crypt    = isset($cipher_code['init_crypt'])    ? $cipher_code['init_crypt']    : '';
        $init_encrypt  = isset($cipher_code['init_encrypt'])  ? $cipher_code['init_encrypt']  : '';
        $init_decrypt  = isset($cipher_code['init_decrypt'])  ? $cipher_code['init_decrypt']  : '';
        // required
        $encrypt_block = $cipher_code['encrypt_block'];
        $decrypt_block = $cipher_code['decrypt_block'];

        // Generating mode of operation inline code,
        // merged with the $cipher_code algorithm
        // for encrypt- and decryption.
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    $_text = $self->_pad($_text);
                    $_plaintext_len = strlen($_text);

                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                        $in = substr($_text, $_i, '.$block_size.');
                        '.$encrypt_block.'
                        $_ciphertext.= $in;
                    }

                    return $_ciphertext;
                    ';

                $decrypt = $init_decrypt . '
                    $_plaintext = "";
                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));
                    $_ciphertext_len = strlen($_text);

                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                        $in = substr($_text, $_i, '.$block_size.');
                        '.$decrypt_block.'
                        $_plaintext.= $in;
                    }

                    return $self->_unpad($_plaintext);
                    ';
                break;
            case CRYPT_MODE_CTR:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    $_plaintext_len = strlen($_text);
                    $_xor = $self->encryptIV;
                    $_buffer = &$self->enbuffer;

                    if (strlen($_buffer["encrypted"])) {
                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            if (strlen($_block) > strlen($_buffer["encrypted"])) {
                                $in = $self->_generateXor($_xor, '.$block_size.');
                                '.$encrypt_block.'
                                $_buffer["encrypted"].= $in;
                            }
                            $_key = $self->_stringShift($_buffer["encrypted"], '.$block_size.');
                            $_ciphertext.= $_block ^ $_key;
                        }
                    } else {
                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            $in = $self->_generateXor($_xor, '.$block_size.');
                            '.$encrypt_block.'
                            $_key = $in;
                            $_ciphertext.= $_block ^ $_key;
                        }
                    }
                    if ($self->continuousBuffer) {
                        $self->encryptIV = $_xor;
                        if ($_start = $_plaintext_len % '.$block_size.') {
                            $_buffer["encrypted"] = substr($_key, $_start) . $_buffer["encrypted"];
                        }
                    }

                    return $_ciphertext;
                ';

                $decrypt = $init_encrypt . '
                    $_plaintext = "";
                    $_ciphertext_len = strlen($_text);
                    $_xor = $self->decryptIV;
                    $_buffer = &$self->debuffer;

                    if (strlen($_buffer["ciphertext"])) {
                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            if (strlen($_block) > strlen($_buffer["ciphertext"])) {
                                $in = $self->_generateXor($_xor, '.$block_size.');
                                '.$encrypt_block.'
                                $_buffer["ciphertext"].= $in;
                            }
                            $_key = $self->_stringShift($_buffer["ciphertext"], '.$block_size.');
                            $_plaintext.= $_block ^ $_key;
                        }
                    } else {
                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            $in = $self->_generateXor($_xor, '.$block_size.');
                            '.$encrypt_block.'
                            $_key = $in;
                            $_plaintext.= $_block ^ $_key;
                        }
                    }
                    if ($self->continuousBuffer) {
                        $self->decryptIV = $_xor;
                        if ($_start = $_ciphertext_len % '.$block_size.') {
                            $_buffer["ciphertext"] = substr($_key, $_start) . $_buffer["ciphertext"];
                        }
                    }

                    return $_plaintext;
                    ';
                break;
            case CRYPT_MODE_CFB:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    $_buffer = &$self->enbuffer;

                    if ($self->continuousBuffer) {
                        $_iv = &$self->encryptIV;
                        $_pos = &$_buffer["pos"];
                    } else {
                        $_iv = $self->encryptIV;
                        $_pos = 0;
                    }
                    $_len = strlen($_text);
                    $_i = 0;
                    if ($_pos) {
                        $_orig_pos = $_pos;
                        $_max = '.$block_size.' - $_pos;
                        if ($_len >= $_max) {
                            $_i = $_max;
                            $_len-= $_max;
                            $_pos = 0;
                        } else {
                            $_i = $_len;
                            $_pos+= $_len;
                            $_len = 0;
                        }
                        $_ciphertext = substr($_iv, $_orig_pos) ^ $_text;
                        $_iv = substr_replace($_iv, $_ciphertext, $_orig_pos, $_i);
                    }
                    while ($_len >= '.$block_size.') {
                        $in = $_iv;
                        '.$encrypt_block.';
                        $_iv = $in ^ substr($_text, $_i, '.$block_size.');
                        $_ciphertext.= $_iv;
                        $_len-= '.$block_size.';
                        $_i+= '.$block_size.';
                    }
                    if ($_len) {
                        $in = $_iv;
                        '.$encrypt_block.'
                        $_iv = $in;
                        $_block = $_iv ^ substr($_text, $_i);
                        $_iv = substr_replace($_iv, $_block, 0, $_len);
                        $_ciphertext.= $_block;
                        $_pos = $_len;
                    }
                    return $_ciphertext;
                ';

                $decrypt = $init_encrypt . '
                    $_plaintext = "";
                    $_buffer = &$self->debuffer;

                    if ($self->continuousBuffer) {
                        $_iv = &$self->decryptIV;
                        $_pos = &$_buffer["pos"];
                    } else {
                        $_iv = $self->decryptIV;
                        $_pos = 0;
                    }
                    $_len = strlen($_text);
                    $_i = 0;
                    if ($_pos) {
                        $_orig_pos = $_pos;
                        $_max = '.$block_size.' - $_pos;
                        if ($_len >= $_max) {
                            $_i = $_max;
                            $_len-= $_max;
                            $_pos = 0;
                        } else {
                            $_i = $_len;
                            $_pos+= $_len;
                            $_len = 0;
                        }
                        $_plaintext = substr($_iv, $_orig_pos) ^ $_text;
                        $_iv = substr_replace($_iv, substr($_text, 0, $_i), $_orig_pos, $_i);
                    }
                    while ($_len >= '.$block_size.') {
                        $in = $_iv;
                        '.$encrypt_block.'
                        $_iv = $in;
                        $cb = substr($_text, $_i, '.$block_size.');
                        $_plaintext.= $_iv ^ $cb;
                        $_iv = $cb;
                        $_len-= '.$block_size.';
                        $_i+= '.$block_size.';
                    }
                    if ($_len) {
                        $in = $_iv;
                        '.$encrypt_block.'
                        $_iv = $in;
                        $_plaintext.= $_iv ^ substr($_text, $_i);
                        $_iv = substr_replace($_iv, substr($_text, $_i), 0, $_len);
                        $_pos = $_len;
                    }

                    return $_plaintext;
                    ';
                break;
            case CRYPT_MODE_OFB:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    $_plaintext_len = strlen($_text);
                    $_xor = $self->encryptIV;
                    $_buffer = &$self->enbuffer;

                    if (strlen($_buffer["xor"])) {
                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            if (strlen($_block) > strlen($_buffer["xor"])) {
                                $in = $_xor;
                                '.$encrypt_block.'
                                $_xor = $in;
                                $_buffer["xor"].= $_xor;
                            }
                            $_key = $self->_stringShift($_buffer["xor"], '.$block_size.');
                            $_ciphertext.= $_block ^ $_key;
                        }
                    } else {
                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                            $in = $_xor;
                            '.$encrypt_block.'
                            $_xor = $in;
                            $_ciphertext.= substr($_text, $_i, '.$block_size.') ^ $_xor;
                        }
                        $_key = $_xor;
                    }
                    if ($self->continuousBuffer) {
                        $self->encryptIV = $_xor;
                        if ($_start = $_plaintext_len % '.$block_size.') {
                             $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"];
                        }
                    }
                    return $_ciphertext;
                    ';

                $decrypt = $init_encrypt . '
                    $_plaintext = "";
                    $_ciphertext_len = strlen($_text);
                    $_xor = $self->decryptIV;
                    $_buffer = &$self->debuffer;

                    if (strlen($_buffer["xor"])) {
                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                            $_block = substr($_text, $_i, '.$block_size.');
                            if (strlen($_block) > strlen($_buffer["xor"])) {
                                $in = $_xor;
                                '.$encrypt_block.'
                                $_xor = $in;
                                $_buffer["xor"].= $_xor;
                            }
                            $_key = $self->_stringShift($_buffer["xor"], '.$block_size.');
                            $_plaintext.= $_block ^ $_key;
                        }
                    } else {
                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                            $in = $_xor;
                            '.$encrypt_block.'
                            $_xor = $in;
                            $_plaintext.= substr($_text, $_i, '.$block_size.') ^ $_xor;
                        }
                        $_key = $_xor;
                    }
                    if ($self->continuousBuffer) {
                        $self->decryptIV = $_xor;
                        if ($_start = $_ciphertext_len % '.$block_size.') {
                             $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"];
                        }
                    }
                    return $_plaintext;
                    ';
                break;
            case CRYPT_MODE_STREAM:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    '.$encrypt_block.'
                    return $_ciphertext;
                    ';
                $decrypt = $init_decrypt . '
                    $_plaintext = "";
                    '.$decrypt_block.'
                    return $_plaintext;
                    ';
                break;
            // case CRYPT_MODE_CBC:
            default:
                $encrypt = $init_encrypt . '
                    $_ciphertext = "";
                    $_text = $self->_pad($_text);
                    $_plaintext_len = strlen($_text);

                    $in = $self->encryptIV;

                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
                        $in = substr($_text, $_i, '.$block_size.') ^ $in;
                        '.$encrypt_block.'
                        $_ciphertext.= $in;
                    }

                    if ($self->continuousBuffer) {
                        $self->encryptIV = $in;
                    }

                    return $_ciphertext;
                    ';

                $decrypt = $init_decrypt . '
                    $_plaintext = "";
                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));
                    $_ciphertext_len = strlen($_text);

                    $_iv = $self->decryptIV;

                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
                        $in = $_block = substr($_text, $_i, '.$block_size.');
                        '.$decrypt_block.'
                        $_plaintext.= $in ^ $_iv;
                        $_iv = $_block;
                    }

                    if ($self->continuousBuffer) {
                        $self->decryptIV = $_iv;
                    }

                    return $self->_unpad($_plaintext);
                    ';
                break;
        }

        // Create the $inline function and return its name as string. Ready to run!
        return create_function('$_action, &$self, $_text', $init_crypt . 'if ($_action == "encrypt") { ' . $encrypt . ' } else { ' . $decrypt . ' }');
    }

    /**
     * Holds the lambda_functions table (classwide)
     *
     * Each name of the lambda function, created from
     * _setupInlineCrypt() && _createInlineCryptFunction()
     * is stored, classwide (!), here for reusing.
     *
     * The string-based index of $function is a classwide
     * uniqe value representing, at least, the $mode of
     * operation (or more... depends of the optimizing level)
     * for which $mode the lambda function was created.
     *
     * @access private
     * @return &Array
     */
    function &_getLambdaFunctions()
    {
        static $functions = array();
        return $functions;
    }
}

}
if (!class_exists('Crypt_Hash')) {
    
/**
 * Pure-PHP implementations of keyed-hash message authentication codes (HMACs) and various cryptographic hashing functions.
 *
 * Uses hash() or mhash() if available and an internal implementation, otherwise.  Currently supports the following:
 *
 * md2, md5, md5-96, sha1, sha1-96, sha256, sha256-96, sha384, and sha512, sha512-96
 *
 * If {@link Crypt_Hash::setKey() setKey()} is called, {@link Crypt_Hash::hash() hash()} will return the HMAC as opposed to
 * the hash.  If no valid algorithm is provided, sha1 will be used.
 *
 * PHP versions 4 and 5
 *
 * {@internal The variable names are the same as those in
 * {@link http://tools.ietf.org/html/rfc2104#section-2 RFC2104}.}}
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/Hash.php';
 *
 *    $hash = new Crypt_Hash('sha1');
 *
 *    $hash->setKey('abcdefg');
 *
 *    echo base64_encode($hash->hash('abcdefg'));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_Hash
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**#@+
 * @access private
 * @see Crypt_Hash::Crypt_Hash()
 */
/**
 * Toggles the internal implementation
 */
define('CRYPT_HASH_MODE_INTERNAL', 1);
/**
 * Toggles the mhash() implementation, which has been deprecated on PHP 5.3.0+.
 */
define('CRYPT_HASH_MODE_MHASH',    2);
/**
 * Toggles the hash() implementation, which works on PHP 5.1.2+.
 */
define('CRYPT_HASH_MODE_HASH',     3);
/**#@-*/

/**
 * Pure-PHP implementations of keyed-hash message authentication codes (HMACs) and various cryptographic hashing functions.
 *
 * @package Crypt_Hash
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_Hash
{
    /**
     * Hash Parameter
     *
     * @see Crypt_Hash::setHash()
     * @var Integer
     * @access private
     */
    var $hashParam;

    /**
     * Byte-length of compression blocks / key (Internal HMAC)
     *
     * @see Crypt_Hash::setAlgorithm()
     * @var Integer
     * @access private
     */
    var $b;

    /**
     * Byte-length of hash output (Internal HMAC)
     *
     * @see Crypt_Hash::setHash()
     * @var Integer
     * @access private
     */
    var $l = false;

    /**
     * Hash Algorithm
     *
     * @see Crypt_Hash::setHash()
     * @var String
     * @access private
     */
    var $hash;

    /**
     * Key
     *
     * @see Crypt_Hash::setKey()
     * @var String
     * @access private
     */
    var $key = false;

    /**
     * Outer XOR (Internal HMAC)
     *
     * @see Crypt_Hash::setKey()
     * @var String
     * @access private
     */
    var $opad;

    /**
     * Inner XOR (Internal HMAC)
     *
     * @see Crypt_Hash::setKey()
     * @var String
     * @access private
     */
    var $ipad;

    /**
     * Default Constructor.
     *
     * @param optional String $hash
     * @return Crypt_Hash
     * @access public
     */
    function Crypt_Hash($hash = 'sha1')
    {
        if ( !defined('CRYPT_HASH_MODE') ) {
            switch (true) {
                case extension_loaded('hash'):
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_HASH);
                    break;
                case extension_loaded('mhash'):
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_MHASH);
                    break;
                default:
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_INTERNAL);
            }
        }

        $this->setHash($hash);
    }

    /**
     * Sets the key for HMACs
     *
     * Keys can be of any length.
     *
     * @access public
     * @param optional String $key
     */
    function setKey($key = false)
    {
        $this->key = $key;
    }

    /**
     * Gets the hash function.
     *
     * As set by the constructor or by the setHash() method.
     *
     * @access public
     * @return String
     */
    function getHash()
    {
        return $this->hashParam;
    }

    /**
     * Sets the hash function.
     *
     * @access public
     * @param String $hash
     */
    function setHash($hash)
    {
        $this->hashParam = $hash = strtolower($hash);
        switch ($hash) {
            case 'md5-96':
            case 'sha1-96':
            case 'sha256-96':
            case 'sha512-96':
                $hash = substr($hash, 0, -3);
                $this->l = 12; // 96 / 8 = 12
                break;
            case 'md2':
            case 'md5':
                $this->l = 16;
                break;
            case 'sha1':
                $this->l = 20;
                break;
            case 'sha256':
                $this->l = 32;
                break;
            case 'sha384':
                $this->l = 48;
                break;
            case 'sha512':
                $this->l = 64;
        }

        switch ($hash) {
            case 'md2':
                $mode = CRYPT_HASH_MODE == CRYPT_HASH_MODE_HASH && in_array('md2', hash_algos()) ?
                    CRYPT_HASH_MODE_HASH : CRYPT_HASH_MODE_INTERNAL;
                break;
            case 'sha384':
            case 'sha512':
                $mode = CRYPT_HASH_MODE == CRYPT_HASH_MODE_MHASH ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;
                break;
            default:
                $mode = CRYPT_HASH_MODE;
        }

        switch ( $mode ) {
            case CRYPT_HASH_MODE_MHASH:
                switch ($hash) {
                    case 'md5':
                        $this->hash = MHASH_MD5;
                        break;
                    case 'sha256':
                        $this->hash = MHASH_SHA256;
                        break;
                    case 'sha1':
                    default:
                        $this->hash = MHASH_SHA1;
                }
                return;
            case CRYPT_HASH_MODE_HASH:
                switch ($hash) {
                    case 'md5':
                        $this->hash = 'md5';
                        return;
                    case 'md2':
                    case 'sha256':
                    case 'sha384':
                    case 'sha512':
                        $this->hash = $hash;
                        return;
                    case 'sha1':
                    default:
                        $this->hash = 'sha1';
                }
                return;
        }

        switch ($hash) {
            case 'md2':
                 $this->b = 16;
                 $this->hash = array($this, '_md2');
                 break;
            case 'md5':
                 $this->b = 64;
                 $this->hash = array($this, '_md5');
                 break;
            case 'sha256':
                 $this->b = 64;
                 $this->hash = array($this, '_sha256');
                 break;
            case 'sha384':
            case 'sha512':
                 $this->b = 128;
                 $this->hash = array($this, '_sha512');
                 break;
            case 'sha1':
            default:
                 $this->b = 64;
                 $this->hash = array($this, '_sha1');
        }

        $this->ipad = str_repeat(chr(0x36), $this->b);
        $this->opad = str_repeat(chr(0x5C), $this->b);
    }

    /**
     * Compute the HMAC.
     *
     * @access public
     * @param String $text
     * @return String
     */
    function hash($text)
    {
        $mode = is_array($this->hash) ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;

        if (!empty($this->key) || is_string($this->key)) {
            switch ( $mode ) {
                case CRYPT_HASH_MODE_MHASH:
                    $output = mhash($this->hash, $text, $this->key);
                    break;
                case CRYPT_HASH_MODE_HASH:
                    $output = hash_hmac($this->hash, $text, $this->key, true);
                    break;
                case CRYPT_HASH_MODE_INTERNAL:
                    /* "Applications that use keys longer than B bytes will first hash the key using H and then use the
                        resultant L byte string as the actual key to HMAC."

                        -- http://tools.ietf.org/html/rfc2104#section-2 */
                    $key = strlen($this->key) > $this->b ? call_user_func($this->hash, $this->key) : $this->key;

                    $key    = str_pad($key, $this->b, chr(0));      // step 1
                    $temp   = $this->ipad ^ $key;                   // step 2
                    $temp  .= $text;                                // step 3
                    $temp   = call_user_func($this->hash, $temp);   // step 4
                    $output = $this->opad ^ $key;                   // step 5
                    $output.= $temp;                                // step 6
                    $output = call_user_func($this->hash, $output); // step 7
            }
        } else {
            switch ( $mode ) {
                case CRYPT_HASH_MODE_MHASH:
                    $output = mhash($this->hash, $text);
                    break;
                case CRYPT_HASH_MODE_HASH:
                    $output = hash($this->hash, $text, true);
                    break;
                case CRYPT_HASH_MODE_INTERNAL:
                    $output = call_user_func($this->hash, $text);
            }
        }

        return substr($output, 0, $this->l);
    }

    /**
     * Returns the hash length (in bytes)
     *
     * @access public
     * @return Integer
     */
    function getLength()
    {
        return $this->l;
    }

    /**
     * Wrapper for MD5
     *
     * @access private
     * @param String $m
     */
    function _md5($m)
    {
        return pack('H*', md5($m));
    }

    /**
     * Wrapper for SHA1
     *
     * @access private
     * @param String $m
     */
    function _sha1($m)
    {
        return pack('H*', sha1($m));
    }

    /**
     * Pure-PHP implementation of MD2
     *
     * See {@link http://tools.ietf.org/html/rfc1319 RFC1319}.
     *
     * @access private
     * @param String $m
     */
    function _md2($m)
    {
        static $s = array(
             41,  46,  67, 201, 162, 216, 124,   1,  61,  54,  84, 161, 236, 240, 6,
             19,  98, 167,   5, 243, 192, 199, 115, 140, 152, 147,  43, 217, 188,
             76, 130, 202,  30, 155,  87,  60, 253, 212, 224,  22, 103,  66, 111, 24,
            138,  23, 229,  18, 190,  78, 196, 214, 218, 158, 222,  73, 160, 251,
            245, 142, 187,  47, 238, 122, 169, 104, 121, 145,  21, 178,   7,  63,
            148, 194,  16, 137,  11,  34,  95,  33, 128, 127,  93, 154,  90, 144, 50,
             39,  53,  62, 204, 231, 191, 247, 151,   3, 255,  25,  48, 179,  72, 165,
            181, 209, 215,  94, 146,  42, 172,  86, 170, 198,  79, 184,  56, 210,
            150, 164, 125, 182, 118, 252, 107, 226, 156, 116,   4, 241,  69, 157,
            112,  89, 100, 113, 135,  32, 134,  91, 207, 101, 230,  45, 168,   2, 27,
             96,  37, 173, 174, 176, 185, 246,  28,  70,  97, 105,  52,  64, 126, 15,
             85,  71, 163,  35, 221,  81, 175,  58, 195,  92, 249, 206, 186, 197,
            234,  38,  44,  83,  13, 110, 133,  40, 132,   9, 211, 223, 205, 244, 65,
            129,  77,  82, 106, 220,  55, 200, 108, 193, 171, 250,  36, 225, 123,
              8,  12, 189, 177,  74, 120, 136, 149, 139, 227,  99, 232, 109, 233,
            203, 213, 254,  59,   0,  29,  57, 242, 239, 183,  14, 102,  88, 208, 228,
            166, 119, 114, 248, 235, 117,  75,  10,  49,  68,  80, 180, 143, 237,
             31,  26, 219, 153, 141,  51, 159,  17, 131, 20
        );

        // Step 1. Append Padding Bytes
        $pad = 16 - (strlen($m) & 0xF);
        $m.= str_repeat(chr($pad), $pad);

        $length = strlen($m);

        // Step 2. Append Checksum
        $c = str_repeat(chr(0), 16);
        $l = chr(0);
        for ($i = 0; $i < $length; $i+= 16) {
            for ($j = 0; $j < 16; $j++) {
                // RFC1319 incorrectly states that C[j] should be set to S[c xor L]
                //$c[$j] = chr($s[ord($m[$i + $j] ^ $l)]);
                // per <http://www.rfc-editor.org/errata_search.php?rfc=1319>, however, C[j] should be set to S[c xor L] xor C[j]
                $c[$j] = chr($s[ord($m[$i + $j] ^ $l)] ^ ord($c[$j]));
                $l = $c[$j];
            }
        }
        $m.= $c;

        $length+= 16;

        // Step 3. Initialize MD Buffer
        $x = str_repeat(chr(0), 48);

        // Step 4. Process Message in 16-Byte Blocks
        for ($i = 0; $i < $length; $i+= 16) {
            for ($j = 0; $j < 16; $j++) {
                $x[$j + 16] = $m[$i + $j];
                $x[$j + 32] = $x[$j + 16] ^ $x[$j];
            }
            $t = chr(0);
            for ($j = 0; $j < 18; $j++) {
                for ($k = 0; $k < 48; $k++) {
                    $x[$k] = $t = $x[$k] ^ chr($s[ord($t)]);
                    //$t = $x[$k] = $x[$k] ^ chr($s[ord($t)]);
                }
                $t = chr(ord($t) + $j);
            }
        }

        // Step 5. Output
        return substr($x, 0, 16);
    }

    /**
     * Pure-PHP implementation of SHA256
     *
     * See {@link http://en.wikipedia.org/wiki/SHA_hash_functions#SHA-256_.28a_SHA-2_variant.29_pseudocode SHA-256 (a SHA-2 variant) pseudocode - Wikipedia}.
     *
     * @access private
     * @param String $m
     */
    function _sha256($m)
    {
        if (extension_loaded('suhosin')) {
            return pack('H*', sha256($m));
        }

        // Initialize variables
        $hash = array(
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
        );
        // Initialize table of round constants
        // (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
        static $k = array(
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
        );

        // Pre-processing
        $length = strlen($m);
        // to round to nearest 56 mod 64, we'll add 64 - (length + (64 - 56)) % 64
        $m.= str_repeat(chr(0), 64 - (($length + 8) & 0x3F));
        $m[$length] = chr(0x80);
        // we don't support hashing strings 512MB long
        $m.= pack('N2', 0, $length << 3);

        // Process the message in successive 512-bit chunks
        $chunks = str_split($m, 64);
        foreach ($chunks as $chunk) {
            $w = array();
            for ($i = 0; $i < 16; $i++) {
                extract(unpack('Ntemp', $this->_string_shift($chunk, 4)));
                $w[] = $temp;
            }

            // Extend the sixteen 32-bit words into sixty-four 32-bit words
            for ($i = 16; $i < 64; $i++) {
                $s0 = $this->_rightRotate($w[$i - 15],  7) ^
                      $this->_rightRotate($w[$i - 15], 18) ^
                      $this->_rightShift( $w[$i - 15],  3);
                $s1 = $this->_rightRotate($w[$i - 2], 17) ^
                      $this->_rightRotate($w[$i - 2], 19) ^
                      $this->_rightShift( $w[$i - 2], 10);
                $w[$i] = $this->_add($w[$i - 16], $s0, $w[$i - 7], $s1);

            }

            // Initialize hash value for this chunk
            list($a, $b, $c, $d, $e, $f, $g, $h) = $hash;

            // Main loop
            for ($i = 0; $i < 64; $i++) {
                $s0 = $this->_rightRotate($a,  2) ^
                      $this->_rightRotate($a, 13) ^
                      $this->_rightRotate($a, 22);
                $maj = ($a & $b) ^
                       ($a & $c) ^
                       ($b & $c);
                $t2 = $this->_add($s0, $maj);

                $s1 = $this->_rightRotate($e,  6) ^
                      $this->_rightRotate($e, 11) ^
                      $this->_rightRotate($e, 25);
                $ch = ($e & $f) ^
                      ($this->_not($e) & $g);
                $t1 = $this->_add($h, $s1, $ch, $k[$i], $w[$i]);

                $h = $g;
                $g = $f;
                $f = $e;
                $e = $this->_add($d, $t1);
                $d = $c;
                $c = $b;
                $b = $a;
                $a = $this->_add($t1, $t2);
            }

            // Add this chunk's hash to result so far
            $hash = array(
                $this->_add($hash[0], $a),
                $this->_add($hash[1], $b),
                $this->_add($hash[2], $c),
                $this->_add($hash[3], $d),
                $this->_add($hash[4], $e),
                $this->_add($hash[5], $f),
                $this->_add($hash[6], $g),
                $this->_add($hash[7], $h)
            );
        }

        // Produce the final hash value (big-endian)
        return pack('N8', $hash[0], $hash[1], $hash[2], $hash[3], $hash[4], $hash[5], $hash[6], $hash[7]);
    }

    /**
     * Pure-PHP implementation of SHA384 and SHA512
     *
     * @access private
     * @param String $m
     */
    function _sha512($m)
    {
        if (!class_exists('Math_BigInteger')) {
            include_once 'Math/BigInteger.php';
        }

        static $init384, $init512, $k;

        if (!isset($k)) {
            // Initialize variables
            $init384 = array( // initial values for SHA384
                'cbbb9d5dc1059ed8', '629a292a367cd507', '9159015a3070dd17', '152fecd8f70e5939',
                '67332667ffc00b31', '8eb44a8768581511', 'db0c2e0d64f98fa7', '47b5481dbefa4fa4'
            );
            $init512 = array( // initial values for SHA512
                '6a09e667f3bcc908', 'bb67ae8584caa73b', '3c6ef372fe94f82b', 'a54ff53a5f1d36f1',
                '510e527fade682d1', '9b05688c2b3e6c1f', '1f83d9abfb41bd6b', '5be0cd19137e2179'
            );

            for ($i = 0; $i < 8; $i++) {
                $init384[$i] = new Math_BigInteger($init384[$i], 16);
                $init384[$i]->setPrecision(64);
                $init512[$i] = new Math_BigInteger($init512[$i], 16);
                $init512[$i]->setPrecision(64);
            }

            // Initialize table of round constants
            // (first 64 bits of the fractional parts of the cube roots of the first 80 primes 2..409)
            $k = array(
                '428a2f98d728ae22', '7137449123ef65cd', 'b5c0fbcfec4d3b2f', 'e9b5dba58189dbbc',
                '3956c25bf348b538', '59f111f1b605d019', '923f82a4af194f9b', 'ab1c5ed5da6d8118',
                'd807aa98a3030242', '12835b0145706fbe', '243185be4ee4b28c', '550c7dc3d5ffb4e2',
                '72be5d74f27b896f', '80deb1fe3b1696b1', '9bdc06a725c71235', 'c19bf174cf692694',
                'e49b69c19ef14ad2', 'efbe4786384f25e3', '0fc19dc68b8cd5b5', '240ca1cc77ac9c65',
                '2de92c6f592b0275', '4a7484aa6ea6e483', '5cb0a9dcbd41fbd4', '76f988da831153b5',
                '983e5152ee66dfab', 'a831c66d2db43210', 'b00327c898fb213f', 'bf597fc7beef0ee4',
                'c6e00bf33da88fc2', 'd5a79147930aa725', '06ca6351e003826f', '142929670a0e6e70',
                '27b70a8546d22ffc', '2e1b21385c26c926', '4d2c6dfc5ac42aed', '53380d139d95b3df',
                '650a73548baf63de', '766a0abb3c77b2a8', '81c2c92e47edaee6', '92722c851482353b',
                'a2bfe8a14cf10364', 'a81a664bbc423001', 'c24b8b70d0f89791', 'c76c51a30654be30',
                'd192e819d6ef5218', 'd69906245565a910', 'f40e35855771202a', '106aa07032bbd1b8',
                '19a4c116b8d2d0c8', '1e376c085141ab53', '2748774cdf8eeb99', '34b0bcb5e19b48a8',
                '391c0cb3c5c95a63', '4ed8aa4ae3418acb', '5b9cca4f7763e373', '682e6ff3d6b2b8a3',
                '748f82ee5defb2fc', '78a5636f43172f60', '84c87814a1f0ab72', '8cc702081a6439ec',
                '90befffa23631e28', 'a4506cebde82bde9', 'bef9a3f7b2c67915', 'c67178f2e372532b',
                'ca273eceea26619c', 'd186b8c721c0c207', 'eada7dd6cde0eb1e', 'f57d4f7fee6ed178',
                '06f067aa72176fba', '0a637dc5a2c898a6', '113f9804bef90dae', '1b710b35131c471b',
                '28db77f523047d84', '32caab7b40c72493', '3c9ebe0a15c9bebc', '431d67c49c100d4c',
                '4cc5d4becb3e42b6', '597f299cfc657e2a', '5fcb6fab3ad6faec', '6c44198c4a475817'
            );

            for ($i = 0; $i < 80; $i++) {
                $k[$i] = new Math_BigInteger($k[$i], 16);
            }
        }

        $hash = $this->l == 48 ? $init384 : $init512;

        // Pre-processing
        $length = strlen($m);
        // to round to nearest 112 mod 128, we'll add 128 - (length + (128 - 112)) % 128
        $m.= str_repeat(chr(0), 128 - (($length + 16) & 0x7F));
        $m[$length] = chr(0x80);
        // we don't support hashing strings 512MB long
        $m.= pack('N4', 0, 0, 0, $length << 3);

        // Process the message in successive 1024-bit chunks
        $chunks = str_split($m, 128);
        foreach ($chunks as $chunk) {
            $w = array();
            for ($i = 0; $i < 16; $i++) {
                $temp = new Math_BigInteger($this->_string_shift($chunk, 8), 256);
                $temp->setPrecision(64);
                $w[] = $temp;
            }

            // Extend the sixteen 32-bit words into eighty 32-bit words
            for ($i = 16; $i < 80; $i++) {
                $temp = array(
                          $w[$i - 15]->bitwise_rightRotate(1),
                          $w[$i - 15]->bitwise_rightRotate(8),
                          $w[$i - 15]->bitwise_rightShift(7)
                );
                $s0 = $temp[0]->bitwise_xor($temp[1]);
                $s0 = $s0->bitwise_xor($temp[2]);
                $temp = array(
                          $w[$i - 2]->bitwise_rightRotate(19),
                          $w[$i - 2]->bitwise_rightRotate(61),
                          $w[$i - 2]->bitwise_rightShift(6)
                );
                $s1 = $temp[0]->bitwise_xor($temp[1]);
                $s1 = $s1->bitwise_xor($temp[2]);
                $w[$i] = $w[$i - 16]->copy();
                $w[$i] = $w[$i]->add($s0);
                $w[$i] = $w[$i]->add($w[$i - 7]);
                $w[$i] = $w[$i]->add($s1);
            }

            // Initialize hash value for this chunk
            $a = $hash[0]->copy();
            $b = $hash[1]->copy();
            $c = $hash[2]->copy();
            $d = $hash[3]->copy();
            $e = $hash[4]->copy();
            $f = $hash[5]->copy();
            $g = $hash[6]->copy();
            $h = $hash[7]->copy();

            // Main loop
            for ($i = 0; $i < 80; $i++) {
                $temp = array(
                    $a->bitwise_rightRotate(28),
                    $a->bitwise_rightRotate(34),
                    $a->bitwise_rightRotate(39)
                );
                $s0 = $temp[0]->bitwise_xor($temp[1]);
                $s0 = $s0->bitwise_xor($temp[2]);
                $temp = array(
                    $a->bitwise_and($b),
                    $a->bitwise_and($c),
                    $b->bitwise_and($c)
                );
                $maj = $temp[0]->bitwise_xor($temp[1]);
                $maj = $maj->bitwise_xor($temp[2]);
                $t2 = $s0->add($maj);

                $temp = array(
                    $e->bitwise_rightRotate(14),
                    $e->bitwise_rightRotate(18),
                    $e->bitwise_rightRotate(41)
                );
                $s1 = $temp[0]->bitwise_xor($temp[1]);
                $s1 = $s1->bitwise_xor($temp[2]);
                $temp = array(
                    $e->bitwise_and($f),
                    $g->bitwise_and($e->bitwise_not())
                );
                $ch = $temp[0]->bitwise_xor($temp[1]);
                $t1 = $h->add($s1);
                $t1 = $t1->add($ch);
                $t1 = $t1->add($k[$i]);
                $t1 = $t1->add($w[$i]);

                $h = $g->copy();
                $g = $f->copy();
                $f = $e->copy();
                $e = $d->add($t1);
                $d = $c->copy();
                $c = $b->copy();
                $b = $a->copy();
                $a = $t1->add($t2);
            }

            // Add this chunk's hash to result so far
            $hash = array(
                $hash[0]->add($a),
                $hash[1]->add($b),
                $hash[2]->add($c),
                $hash[3]->add($d),
                $hash[4]->add($e),
                $hash[5]->add($f),
                $hash[6]->add($g),
                $hash[7]->add($h)
            );
        }

        // Produce the final hash value (big-endian)
        // (Crypt_Hash::hash() trims the output for hashes but not for HMACs.  as such, we trim the output here)
        $temp = $hash[0]->toBytes() . $hash[1]->toBytes() . $hash[2]->toBytes() . $hash[3]->toBytes() .
                $hash[4]->toBytes() . $hash[5]->toBytes();
        if ($this->l != 48) {
            $temp.= $hash[6]->toBytes() . $hash[7]->toBytes();
        }

        return $temp;
    }

    /**
     * Right Rotate
     *
     * @access private
     * @param Integer $int
     * @param Integer $amt
     * @see _sha256()
     * @return Integer
     */
    function _rightRotate($int, $amt)
    {
        $invamt = 32 - $amt;
        $mask = (1 << $invamt) - 1;
        return (($int << $invamt) & 0xFFFFFFFF) | (($int >> $amt) & $mask);
    }

    /**
     * Right Shift
     *
     * @access private
     * @param Integer $int
     * @param Integer $amt
     * @see _sha256()
     * @return Integer
     */
    function _rightShift($int, $amt)
    {
        $mask = (1 << (32 - $amt)) - 1;
        return ($int >> $amt) & $mask;
    }

    /**
     * Not
     *
     * @access private
     * @param Integer $int
     * @see _sha256()
     * @return Integer
     */
    function _not($int)
    {
        return ~$int & 0xFFFFFFFF;
    }

    /**
     * Add
     *
     * _sha256() adds multiple unsigned 32-bit integers.  Since PHP doesn't support unsigned integers and since the
     * possibility of overflow exists, care has to be taken.  Math_BigInteger() could be used but this should be faster.
     *
     * @param Integer $...
     * @return Integer
     * @see _sha256()
     * @access private
     */
    function _add()
    {
        static $mod;
        if (!isset($mod)) {
            $mod = pow(2, 32);
        }

        $result = 0;
        $arguments = func_get_args();
        foreach ($arguments as $argument) {
            $result+= $argument < 0 ? ($argument & 0x7FFFFFFF) + 0x80000000 : $argument;
        }

        return fmod($result, $mod);
    }

    /**
     * String Shift
     *
     * Inspired by array_shift
     *
     * @param String $string
     * @param optional Integer $index
     * @return String
     * @access private
     */
    function _string_shift(&$string, $index = 1)
    {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }
}

}
if (!class_exists('Crypt_Rijndael')) {
    
/**
 * Pure-PHP implementation of Rijndael.
 *
 * Uses mcrypt, if available/possible, and an internal implementation, otherwise.
 *
 * PHP versions 4 and 5
 *
 * If {@link Crypt_Rijndael::setBlockLength() setBlockLength()} isn't called, it'll be assumed to be 128 bits.  If
 * {@link Crypt_Rijndael::setKeyLength() setKeyLength()} isn't called, it'll be calculated from
 * {@link Crypt_Rijndael::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's
 * 136-bits it'll be null-padded to 192-bits and 192 bits will be the key length until
 * {@link Crypt_Rijndael::setKey() setKey()} is called, again, at which point, it'll be recalculated.
 *
 * Not all Rijndael implementations may support 160-bits or 224-bits as the block length / key length.  mcrypt, for example,
 * does not.  AES, itself, only supports block lengths of 128 and key lengths of 128, 192, and 256.
 * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=10 Rijndael-ammended.pdf#page=10} defines the
 * algorithm for block lengths of 192 and 256 but not for block lengths / key lengths of 160 and 224.  Indeed, 160 and 224
 * are first defined as valid key / block lengths in
 * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=44 Rijndael-ammended.pdf#page=44}:
 * Extensions: Other block and Cipher Key lengths.
 * Note: Use of 160/224-bit Keys must be explicitly set by setKeyLength(160) respectively setKeyLength(224).
 *
 * {@internal The variable names are the same as those in
 * {@link http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf#page=10 fips-197.pdf#page=10}.}}
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/Rijndael.php';
 *
 *    $rijndael = new Crypt_Rijndael();
 *
 *    $rijndael->setKey('abcdefghijklmnop');
 *
 *    $size = 10 * 1024;
 *    $plaintext = '';
 *    for ($i = 0; $i < $size; $i++) {
 *        $plaintext.= 'a';
 *    }
 *
 *    echo $rijndael->decrypt($rijndael->encrypt($plaintext));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_Rijndael
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVIII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**
 * Include Crypt_Base
 *
 * Base cipher class
 */
if (!class_exists('Crypt_Base')) {
    include_once 'Base.php';
}

/**#@+
 * @access public
 * @see Crypt_Rijndael::encrypt()
 * @see Crypt_Rijndael::decrypt()
 */
/**
 * Encrypt / decrypt using the Counter mode.
 *
 * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
 */
define('CRYPT_RIJNDAEL_MODE_CTR', CRYPT_MODE_CTR);
/**
 * Encrypt / decrypt using the Electronic Code Book mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
 */
define('CRYPT_RIJNDAEL_MODE_ECB', CRYPT_MODE_ECB);
/**
 * Encrypt / decrypt using the Code Book Chaining mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
 */
define('CRYPT_RIJNDAEL_MODE_CBC', CRYPT_MODE_CBC);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
 */
define('CRYPT_RIJNDAEL_MODE_CFB', CRYPT_MODE_CFB);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
 */
define('CRYPT_RIJNDAEL_MODE_OFB', CRYPT_MODE_OFB);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_Base::Crypt_Base()
 */
/**
 * Toggles the internal implementation
 */
define('CRYPT_RIJNDAEL_MODE_INTERNAL', CRYPT_MODE_INTERNAL);
/**
 * Toggles the mcrypt implementation
 */
define('CRYPT_RIJNDAEL_MODE_MCRYPT', CRYPT_MODE_MCRYPT);
/**#@-*/

/**
 * Pure-PHP implementation of Rijndael.
 *
 * @package Crypt_Rijndael
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_Rijndael extends Crypt_Base
{
    /**
     * The default password key_size used by setPassword()
     *
     * @see Crypt_Base::password_key_size
     * @see Crypt_Base::setPassword()
     * @var Integer
     * @access private
     */
    var $password_key_size = 16;

    /**
     * The namespace used by the cipher for its constants.
     *
     * @see Crypt_Base::const_namespace
     * @var String
     * @access private
     */
    var $const_namespace = 'RIJNDAEL';

    /**
     * The mcrypt specific name of the cipher
     *
     * Mcrypt is useable for 128/192/256-bit $block_size/$key_size. For 160/224 not.
     * Crypt_Rijndael determines automatically whether mcrypt is useable
     * or not for the current $block_size/$key_size.
     * In case of, $cipher_name_mcrypt will be set dynamically at run time accordingly.
     *
     * @see Crypt_Base::cipher_name_mcrypt
     * @see Crypt_Base::engine
     * @see _setupEngine()
     * @var String
     * @access private
     */
    var $cipher_name_mcrypt = 'rijndael-128';

    /**
     * The default salt used by setPassword()
     *
     * @see Crypt_Base::password_default_salt
     * @see Crypt_Base::setPassword()
     * @var String
     * @access private
     */
    var $password_default_salt = 'phpseclib';

    /**
     * Has the key length explicitly been set or should it be derived from the key, itself?
     *
     * @see setKeyLength()
     * @var Boolean
     * @access private
     */
    var $explicit_key_length = false;

    /**
     * The Key Schedule
     *
     * @see _setup()
     * @var Array
     * @access private
     */
    var $w;

    /**
     * The Inverse Key Schedule
     *
     * @see _setup()
     * @var Array
     * @access private
     */
    var $dw;

    /**
     * The Block Length divided by 32
     *
     * @see setBlockLength()
     * @var Integer
     * @access private
     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4.  Exists in conjunction with $block_size
     *    because the encryption / decryption / key schedule creation requires this number and not $block_size.  We could
     *    derive this from $block_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
     *    of that, we'll just precompute it once.
     *
     */
    var $Nb = 4;

    /**
     * The Key Length
     *
     * @see setKeyLength()
     * @var Integer
     * @access private
     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk
     *    because the encryption / decryption / key schedule creation requires this number and not $key_size.  We could
     *    derive this from $key_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
     *    of that, we'll just precompute it once.
     */
    var $key_size = 16;

    /**
     * The Key Length divided by 32
     *
     * @see setKeyLength()
     * @var Integer
     * @access private
     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4
     */
    var $Nk = 4;

    /**
     * The Number of Rounds
     *
     * @var Integer
     * @access private
     * @internal The max value is 14, the min value is 10.
     */
    var $Nr;

    /**
     * Shift offsets
     *
     * @var Array
     * @access private
     */
    var $c;

    /**
     * Holds the last used key- and block_size information
     *
     * @var Array
     * @access private
     */
    var $kl;

    /**
     * Precomputed mixColumns table
     *
     * According to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=19> (section 5.2.1),
     * precomputed tables can be used in the mixColumns phase.  in that example, they're assigned t0...t3, so
     * those are the names we'll use.
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $t0 = array(
        0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D, 0xFFF2F20D, 0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554,
        0x60303050, 0x02010103, 0xCE6767A9, 0x562B2B7D, 0xE7FEFE19, 0xB5D7D762, 0x4DABABE6, 0xEC76769A,
        0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87, 0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B,
        0x41ADADEC, 0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA, 0x239C9CBF, 0x53A4A4F7, 0xE4727296, 0x9BC0C05B,
        0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE, 0x4C26266A, 0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F,
        0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108, 0xE2717193, 0xABD8D873, 0x62313153, 0x2A15153F,
        0x0804040C, 0x95C7C752, 0x46232365, 0x9DC3C35E, 0x30181828, 0x379696A1, 0x0A05050F, 0x2F9A9AB5,
        0x0E070709, 0x24121236, 0x1B80809B, 0xDFE2E23D, 0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F,
        0x1209091B, 0x1D83839E, 0x582C2C74, 0x341A1A2E, 0x361B1B2D, 0xDC6E6EB2, 0xB45A5AEE, 0x5BA0A0FB,
        0xA45252F6, 0x763B3B4D, 0xB7D6D661, 0x7DB3B3CE, 0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497,
        0xA65353F5, 0xB9D1D168, 0x00000000, 0xC1EDED2C, 0x40202060, 0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED,
        0xD46A6ABE, 0x8DCBCB46, 0x67BEBED9, 0x7239394B, 0x944A4ADE, 0x984C4CD4, 0xB05858E8, 0x85CFCF4A,
        0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16, 0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594,
        0x8A4545CF, 0xE9F9F910, 0x04020206, 0xFE7F7F81, 0xA05050F0, 0x783C3C44, 0x259F9FBA, 0x4BA8A8E3,
        0xA25151F3, 0x5DA3A3FE, 0x804040C0, 0x058F8F8A, 0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504,
        0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163, 0x20101030, 0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D,
        0x81CDCD4C, 0x180C0C14, 0x26131335, 0xC3ECEC2F, 0xBE5F5FE1, 0x359797A2, 0x884444CC, 0x2E171739,
        0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47, 0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395,
        0xC06060A0, 0x19818198, 0x9E4F4FD1, 0xA3DCDC7F, 0x44222266, 0x542A2A7E, 0x3B9090AB, 0x0B888883,
        0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3, 0x2814143C, 0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76,
        0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E, 0x924949DB, 0x0C06060A, 0x4824246C, 0xB85C5CE4,
        0x9FC2C25D, 0xBDD3D36E, 0x43ACACEF, 0xC46262A6, 0x399191A8, 0x319595A4, 0xD3E4E437, 0xF279798B,
        0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7, 0x018D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0,
        0xD86C6CB4, 0xAC5656FA, 0xF3F4F407, 0xCFEAEA25, 0xCA6565AF, 0xF47A7A8E, 0x47AEAEE9, 0x10080818,
        0x6FBABAD5, 0xF0787888, 0x4A25256F, 0x5C2E2E72, 0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651,
        0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21, 0x964B4BDD, 0x61BDBDDC, 0x0D8B8B86, 0x0F8A8A85,
        0xE0707090, 0x7C3E3E42, 0x71B5B5C4, 0xCC6666AA, 0x904848D8, 0x06030305, 0xF7F6F601, 0x1C0E0E12,
        0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0, 0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9,
        0xD9E1E138, 0xEBF8F813, 0x2B9898B3, 0x22111133, 0xD26969BB, 0xA9D9D970, 0x078E8E89, 0x339494A7,
        0x2D9B9BB6, 0x3C1E1E22, 0x15878792, 0xC9E9E920, 0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A,
        0x038C8C8F, 0x59A1A1F8, 0x09898980, 0x1A0D0D17, 0x65BFBFDA, 0xD7E6E631, 0x844242C6, 0xD06868B8,
        0x824141C3, 0x299999B0, 0x5A2D2D77, 0x1E0F0F11, 0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6, 0x2C16163A
    );

    /**
     * Precomputed mixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $t1 = array(
        0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B, 0x0DFFF2F2, 0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5,
        0x50603030, 0x03020101, 0xA9CE6767, 0x7D562B2B, 0x19E7FEFE, 0x62B5D7D7, 0xE64DABAB, 0x9AEC7676,
        0x458FCACA, 0x9D1F8282, 0x4089C9C9, 0x87FA7D7D, 0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0x0BFBF0F0,
        0xEC41ADAD, 0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF, 0xBF239C9C, 0xF753A4A4, 0x96E47272, 0x5B9BC0C0,
        0xC275B7B7, 0x1CE1FDFD, 0xAE3D9393, 0x6A4C2626, 0x5A6C3636, 0x417E3F3F, 0x02F5F7F7, 0x4F83CCCC,
        0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x08F9F1F1, 0x93E27171, 0x73ABD8D8, 0x53623131, 0x3F2A1515,
        0x0C080404, 0x5295C7C7, 0x65462323, 0x5E9DC3C3, 0x28301818, 0xA1379696, 0x0F0A0505, 0xB52F9A9A,
        0x090E0707, 0x36241212, 0x9B1B8080, 0x3DDFE2E2, 0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575,
        0x1B120909, 0x9E1D8383, 0x74582C2C, 0x2E341A1A, 0x2D361B1B, 0xB2DC6E6E, 0xEEB45A5A, 0xFB5BA0A0,
        0xF6A45252, 0x4D763B3B, 0x61B7D6D6, 0xCE7DB3B3, 0x7B522929, 0x3EDDE3E3, 0x715E2F2F, 0x97138484,
        0xF5A65353, 0x68B9D1D1, 0x00000000, 0x2CC1EDED, 0x60402020, 0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B,
        0xBED46A6A, 0x468DCBCB, 0xD967BEBE, 0x4B723939, 0xDE944A4A, 0xD4984C4C, 0xE8B05858, 0x4A85CFCF,
        0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA, 0x16EDFBFB, 0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585,
        0xCF8A4545, 0x10E9F9F9, 0x06040202, 0x81FE7F7F, 0xF0A05050, 0x44783C3C, 0xBA259F9F, 0xE34BA8A8,
        0xF3A25151, 0xFE5DA3A3, 0xC0804040, 0x8A058F8F, 0xAD3F9292, 0xBC219D9D, 0x48703838, 0x04F1F5F5,
        0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121, 0x30201010, 0x1AE5FFFF, 0x0EFDF3F3, 0x6DBFD2D2,
        0x4C81CDCD, 0x14180C0C, 0x35261313, 0x2FC3ECEC, 0xE1BE5F5F, 0xA2359797, 0xCC884444, 0x392E1717,
        0x5793C4C4, 0xF255A7A7, 0x82FC7E7E, 0x477A3D3D, 0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373,
        0xA0C06060, 0x98198181, 0xD19E4F4F, 0x7FA3DCDC, 0x66442222, 0x7E542A2A, 0xAB3B9090, 0x830B8888,
        0xCA8C4646, 0x29C7EEEE, 0xD36BB8B8, 0x3C281414, 0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B, 0x76ADDBDB,
        0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A, 0xDB924949, 0x0A0C0606, 0x6C482424, 0xE4B85C5C,
        0x5D9FC2C2, 0x6EBDD3D3, 0xEF43ACAC, 0xA6C46262, 0xA8399191, 0xA4319595, 0x37D3E4E4, 0x8BF27979,
        0x32D5E7E7, 0x438BC8C8, 0x596E3737, 0xB7DA6D6D, 0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9,
        0xB4D86C6C, 0xFAAC5656, 0x07F3F4F4, 0x25CFEAEA, 0xAFCA6565, 0x8EF47A7A, 0xE947AEAE, 0x18100808,
        0xD56FBABA, 0x88F07878, 0x6F4A2525, 0x725C2E2E, 0x24381C1C, 0xF157A6A6, 0xC773B4B4, 0x5197C6C6,
        0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F, 0xDD964B4B, 0xDC61BDBD, 0x860D8B8B, 0x850F8A8A,
        0x90E07070, 0x427C3E3E, 0xC471B5B5, 0xAACC6666, 0xD8904848, 0x05060303, 0x01F7F6F6, 0x121C0E0E,
        0xA3C26161, 0x5F6A3535, 0xF9AE5757, 0xD069B9B9, 0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E,
        0x38D9E1E1, 0x13EBF8F8, 0xB32B9898, 0x33221111, 0xBBD26969, 0x70A9D9D9, 0x89078E8E, 0xA7339494,
        0xB62D9B9B, 0x223C1E1E, 0x92158787, 0x20C9E9E9, 0x4987CECE, 0xFFAA5555, 0x78502828, 0x7AA5DFDF,
        0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D, 0xDA65BFBF, 0x31D7E6E6, 0xC6844242, 0xB8D06868,
        0xC3824141, 0xB0299999, 0x775A2D2D, 0x111E0F0F, 0xCB7BB0B0, 0xFCA85454, 0xD66DBBBB, 0x3A2C1616
    );

    /**
     * Precomputed mixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $t2 = array(
        0x63A5C663, 0x7C84F87C, 0x7799EE77, 0x7B8DF67B, 0xF20DFFF2, 0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5,
        0x30506030, 0x01030201, 0x67A9CE67, 0x2B7D562B, 0xFE19E7FE, 0xD762B5D7, 0xABE64DAB, 0x769AEC76,
        0xCA458FCA, 0x829D1F82, 0xC94089C9, 0x7D87FA7D, 0xFA15EFFA, 0x59EBB259, 0x47C98E47, 0xF00BFBF0,
        0xADEC41AD, 0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF, 0x9CBF239C, 0xA4F753A4, 0x7296E472, 0xC05B9BC0,
        0xB7C275B7, 0xFD1CE1FD, 0x93AE3D93, 0x266A4C26, 0x365A6C36, 0x3F417E3F, 0xF702F5F7, 0xCC4F83CC,
        0x345C6834, 0xA5F451A5, 0xE534D1E5, 0xF108F9F1, 0x7193E271, 0xD873ABD8, 0x31536231, 0x153F2A15,
        0x040C0804, 0xC75295C7, 0x23654623, 0xC35E9DC3, 0x18283018, 0x96A13796, 0x050F0A05, 0x9AB52F9A,
        0x07090E07, 0x12362412, 0x809B1B80, 0xE23DDFE2, 0xEB26CDEB, 0x27694E27, 0xB2CD7FB2, 0x759FEA75,
        0x091B1209, 0x839E1D83, 0x2C74582C, 0x1A2E341A, 0x1B2D361B, 0x6EB2DC6E, 0x5AEEB45A, 0xA0FB5BA0,
        0x52F6A452, 0x3B4D763B, 0xD661B7D6, 0xB3CE7DB3, 0x297B5229, 0xE33EDDE3, 0x2F715E2F, 0x84971384,
        0x53F5A653, 0xD168B9D1, 0x00000000, 0xED2CC1ED, 0x20604020, 0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B,
        0x6ABED46A, 0xCB468DCB, 0xBED967BE, 0x394B7239, 0x4ADE944A, 0x4CD4984C, 0x58E8B058, 0xCF4A85CF,
        0xD06BBBD0, 0xEF2AC5EF, 0xAAE54FAA, 0xFB16EDFB, 0x43C58643, 0x4DD79A4D, 0x33556633, 0x85941185,
        0x45CF8A45, 0xF910E9F9, 0x02060402, 0x7F81FE7F, 0x50F0A050, 0x3C44783C, 0x9FBA259F, 0xA8E34BA8,
        0x51F3A251, 0xA3FE5DA3, 0x40C08040, 0x8F8A058F, 0x92AD3F92, 0x9DBC219D, 0x38487038, 0xF504F1F5,
        0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA, 0x21634221, 0x10302010, 0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2,
        0xCD4C81CD, 0x0C14180C, 0x13352613, 0xEC2FC3EC, 0x5FE1BE5F, 0x97A23597, 0x44CC8844, 0x17392E17,
        0xC45793C4, 0xA7F255A7, 0x7E82FC7E, 0x3D477A3D, 0x64ACC864, 0x5DE7BA5D, 0x192B3219, 0x7395E673,
        0x60A0C060, 0x81981981, 0x4FD19E4F, 0xDC7FA3DC, 0x22664422, 0x2A7E542A, 0x90AB3B90, 0x88830B88,
        0x46CA8C46, 0xEE29C7EE, 0xB8D36BB8, 0x143C2814, 0xDE79A7DE, 0x5EE2BC5E, 0x0B1D160B, 0xDB76ADDB,
        0xE03BDBE0, 0x32566432, 0x3A4E743A, 0x0A1E140A, 0x49DB9249, 0x060A0C06, 0x246C4824, 0x5CE4B85C,
        0xC25D9FC2, 0xD36EBDD3, 0xACEF43AC, 0x62A6C462, 0x91A83991, 0x95A43195, 0xE437D3E4, 0x798BF279,
        0xE732D5E7, 0xC8438BC8, 0x37596E37, 0x6DB7DA6D, 0x8D8C018D, 0xD564B1D5, 0x4ED29C4E, 0xA9E049A9,
        0x6CB4D86C, 0x56FAAC56, 0xF407F3F4, 0xEA25CFEA, 0x65AFCA65, 0x7A8EF47A, 0xAEE947AE, 0x08181008,
        0xBAD56FBA, 0x7888F078, 0x256F4A25, 0x2E725C2E, 0x1C24381C, 0xA6F157A6, 0xB4C773B4, 0xC65197C6,
        0xE823CBE8, 0xDD7CA1DD, 0x749CE874, 0x1F213E1F, 0x4BDD964B, 0xBDDC61BD, 0x8B860D8B, 0x8A850F8A,
        0x7090E070, 0x3E427C3E, 0xB5C471B5, 0x66AACC66, 0x48D89048, 0x03050603, 0xF601F7F6, 0x0E121C0E,
        0x61A3C261, 0x355F6A35, 0x57F9AE57, 0xB9D069B9, 0x86911786, 0xC15899C1, 0x1D273A1D, 0x9EB9279E,
        0xE138D9E1, 0xF813EBF8, 0x98B32B98, 0x11332211, 0x69BBD269, 0xD970A9D9, 0x8E89078E, 0x94A73394,
        0x9BB62D9B, 0x1E223C1E, 0x87921587, 0xE920C9E9, 0xCE4987CE, 0x55FFAA55, 0x28785028, 0xDF7AA5DF,
        0x8C8F038C, 0xA1F859A1, 0x89800989, 0x0D171A0D, 0xBFDA65BF, 0xE631D7E6, 0x42C68442, 0x68B8D068,
        0x41C38241, 0x99B02999, 0x2D775A2D, 0x0F111E0F, 0xB0CB7BB0, 0x54FCA854, 0xBBD66DBB, 0x163A2C16
    );

    /**
     * Precomputed mixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $t3 = array(
        0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,
        0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,
        0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,
        0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,
        0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,
        0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,
        0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,
        0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,
        0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,
        0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,
        0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,
        0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,
        0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,
        0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,
        0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,
        0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,
        0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,
        0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,
        0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,
        0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,
        0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,
        0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,
        0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,
        0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,
        0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,
        0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,
        0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,
        0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,
        0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,
        0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,
        0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,
        0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C
    );

    /**
     * Precomputed invMixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $dt0 = array(
        0x51F4A750, 0x7E416553, 0x1A17A4C3, 0x3A275E96, 0x3BAB6BCB, 0x1F9D45F1, 0xACFA58AB, 0x4BE30393,
        0x2030FA55, 0xAD766DF6, 0x88CC7691, 0xF5024C25, 0x4FE5D7FC, 0xC52ACBD7, 0x26354480, 0xB562A38F,
        0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1, 0xC32F7502, 0x814CF012, 0x8D4697A3, 0x6BD3F9C6,
        0x038F5FE7, 0x15929C95, 0xBF6D7AEB, 0x955259DA, 0xD4BE832D, 0x587421D3, 0x49E06929, 0x8EC9C844,
        0x75C2896A, 0xF48E7978, 0x99583E6B, 0x27B971DD, 0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4,
        0x63DF4A18, 0xE51A3182, 0x97513360, 0x62537F45, 0xB16477E0, 0xBB6BAE84, 0xFE81A01C, 0xF9082B94,
        0x70486858, 0x8F45FD19, 0x94DE6C87, 0x527BF8B7, 0xAB73D323, 0x724B02E2, 0xE31F8F57, 0x6655AB2A,
        0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5, 0x302887F2, 0x23BFA5B2, 0x02036ABA, 0xED16825C,
        0x8ACF1C2B, 0xA779B492, 0xF307F2F0, 0x4E69E2A1, 0x65DAF4CD, 0x0605BED5, 0xD134621F, 0xC4A6FE8A,
        0x342E539D, 0xA2F355A0, 0x058AE132, 0xA4F6EB75, 0x0B83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051,
        0x3E218AF9, 0x96DD063D, 0xDD3E05AE, 0x4DE6BD46, 0x91548DB5, 0x71C45D05, 0x0406D46F, 0x605015FF,
        0x1998FB24, 0xD6BDE997, 0x894043CC, 0x67D99E77, 0xB0E842BD, 0x07898B88, 0xE7195B38, 0x79C8EEDB,
        0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0x00000000, 0x09808683, 0x322BED48, 0x1E1170AC, 0x6C5A724E,
        0xFD0EFFFB, 0x0F853856, 0x3DAED51E, 0x362D3927, 0x0A0FD964, 0x685CA621, 0x9B5B54D1, 0x24362E3A,
        0x0C0A67B1, 0x9357E70F, 0xB4EE96D2, 0x1B9B919E, 0x80C0C54F, 0x61DC20A2, 0x5A774B69, 0x1C121A16,
        0xE293BA0A, 0xC0A02AE5, 0x3C22E043, 0x121B171D, 0x0E090D0B, 0xF28BC7AD, 0x2DB6A8B9, 0x141EA9C8,
        0x57F11985, 0xAF75074C, 0xEE99DDBB, 0xA37F60FD, 0xF701269F, 0x5C72F5BC, 0x44663BC5, 0x5BFB7E34,
        0x8B432976, 0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163, 0xD731DCCA, 0x42638510, 0x13972240, 0x84C61120,
        0x854A247D, 0xD2BB3DF8, 0xAEF93211, 0xC729A16D, 0x1D9E2F4B, 0xDCB230F3, 0x0D8652EC, 0x77C1E3D0,
        0x2BB3166C, 0xA970B999, 0x119448FA, 0x47E96422, 0xA8FC8CC4, 0xA0F03F1A, 0x567D2CD8, 0x223390EF,
        0x87494EC7, 0xD938D1C1, 0x8CCAA2FE, 0x98D40B36, 0xA6F581CF, 0xA57ADE28, 0xDAB78E26, 0x3FADBFA4,
        0x2C3A9DE4, 0x5078920D, 0x6A5FCC9B, 0x547E4662, 0xF68D13C2, 0x90D8B8E8, 0x2E39F75E, 0x82C3AFF5,
        0x9F5D80BE, 0x69D0937C, 0x6FD52DA9, 0xCF2512B3, 0xC8AC993B, 0x10187DA7, 0xE89C636E, 0xDB3BBB7B,
        0xCD267809, 0x6E5918F4, 0xEC9AB701, 0x834F9AA8, 0xE6956E65, 0xAAFFE67E, 0x21BCCF08, 0xEF15E8E6,
        0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4, 0x29B07CD6, 0x31A4B2AF, 0x2A3F2331, 0xC6A59430, 0x35A266C0,
        0x744EBC37, 0xFC82CAA6, 0xE090D0B0, 0x33A7D815, 0xF104984A, 0x41ECDAF7, 0x7FCD500E, 0x1791F62F,
        0x764DD68D, 0x43EFB04D, 0xCCAA4D54, 0xE49604DF, 0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8, 0x4665517F,
        0x9D5EEA04, 0x018C355D, 0xFA877473, 0xFB0B412E, 0xB3671D5A, 0x92DBD252, 0xE9105633, 0x6DD64713,
        0x9AD7618C, 0x37A10C7A, 0x59F8148E, 0xEB133C89, 0xCEA927EE, 0xB761C935, 0xE11CE5ED, 0x7A47B13C,
        0x9CD2DF59, 0x55F2733F, 0x1814CE79, 0x73C737BF, 0x53F7CDEA, 0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86,
        0xCAAFF381, 0xB968C43E, 0x3824342C, 0xC2A3405F, 0x161DC372, 0xBCE2250C, 0x283C498B, 0xFF0D9541,
        0x39A80171, 0x080CB3DE, 0xD8B4E49C, 0x6456C190, 0x7BCB8461, 0xD532B670, 0x486C5C74, 0xD0B85742
    );

    /**
     * Precomputed invMixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $dt1 = array(
        0x5051F4A7, 0x537E4165, 0xC31A17A4, 0x963A275E, 0xCB3BAB6B, 0xF11F9D45, 0xABACFA58, 0x934BE303,
        0x552030FA, 0xF6AD766D, 0x9188CC76, 0x25F5024C, 0xFC4FE5D7, 0xD7C52ACB, 0x80263544, 0x8FB562A3,
        0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0, 0x02C32F75, 0x12814CF0, 0xA38D4697, 0xC66BD3F9,
        0xE7038F5F, 0x9515929C, 0xEBBF6D7A, 0xDA955259, 0x2DD4BE83, 0xD3587421, 0x2949E069, 0x448EC9C8,
        0x6A75C289, 0x78F48E79, 0x6B99583E, 0xDD27B971, 0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A,
        0x1863DF4A, 0x82E51A31, 0x60975133, 0x4562537F, 0xE0B16477, 0x84BB6BAE, 0x1CFE81A0, 0x94F9082B,
        0x58704868, 0x198F45FD, 0x8794DE6C, 0xB7527BF8, 0x23AB73D3, 0xE2724B02, 0x57E31F8F, 0x2A6655AB,
        0x07B2EB28, 0x032FB5C2, 0x9A86C57B, 0xA5D33708, 0xF2302887, 0xB223BFA5, 0xBA02036A, 0x5CED1682,
        0x2B8ACF1C, 0x92A779B4, 0xF0F307F2, 0xA14E69E2, 0xCD65DAF4, 0xD50605BE, 0x1FD13462, 0x8AC4A6FE,
        0x9D342E53, 0xA0A2F355, 0x32058AE1, 0x75A4F6EB, 0x390B83EC, 0xAA4060EF, 0x065E719F, 0x51BD6E10,
        0xF93E218A, 0x3D96DD06, 0xAEDD3E05, 0x464DE6BD, 0xB591548D, 0x0571C45D, 0x6F0406D4, 0xFF605015,
        0x241998FB, 0x97D6BDE9, 0xCC894043, 0x7767D99E, 0xBDB0E842, 0x8807898B, 0x38E7195B, 0xDB79C8EE,
        0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0x00000000, 0x83098086, 0x48322BED, 0xAC1E1170, 0x4E6C5A72,
        0xFBFD0EFF, 0x560F8538, 0x1E3DAED5, 0x27362D39, 0x640A0FD9, 0x21685CA6, 0xD19B5B54, 0x3A24362E,
        0xB10C0A67, 0x0F9357E7, 0xD2B4EE96, 0x9E1B9B91, 0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A,
        0x0AE293BA, 0xE5C0A02A, 0x433C22E0, 0x1D121B17, 0x0B0E090D, 0xADF28BC7, 0xB92DB6A8, 0xC8141EA9,
        0x8557F119, 0x4CAF7507, 0xBBEE99DD, 0xFDA37F60, 0x9FF70126, 0xBC5C72F5, 0xC544663B, 0x345BFB7E,
        0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1, 0xCAD731DC, 0x10426385, 0x40139722, 0x2084C611,
        0x7D854A24, 0xF8D2BB3D, 0x11AEF932, 0x6DC729A1, 0x4B1D9E2F, 0xF3DCB230, 0xEC0D8652, 0xD077C1E3,
        0x6C2BB316, 0x99A970B9, 0xFA119448, 0x2247E964, 0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390,
        0xC787494E, 0xC1D938D1, 0xFE8CCAA2, 0x3698D40B, 0xCFA6F581, 0x28A57ADE, 0x26DAB78E, 0xA43FADBF,
        0xE42C3A9D, 0x0D507892, 0x9B6A5FCC, 0x62547E46, 0xC2F68D13, 0xE890D8B8, 0x5E2E39F7, 0xF582C3AF,
        0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512, 0x3BC8AC99, 0xA710187D, 0x6EE89C63, 0x7BDB3BBB,
        0x09CD2678, 0xF46E5918, 0x01EC9AB7, 0xA8834F9A, 0x65E6956E, 0x7EAAFFE6, 0x0821BCCF, 0xE6EF15E8,
        0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09, 0xD629B07C, 0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266,
        0x37744EBC, 0xA6FC82CA, 0xB0E090D0, 0x1533A7D8, 0x4AF10498, 0xF741ECDA, 0x0E7FCD50, 0x2F1791F6,
        0x8D764DD6, 0x4D43EFB0, 0x54CCAA4D, 0xDFE49604, 0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F, 0x7F466551,
        0x049D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41, 0x5AB3671D, 0x5292DBD2, 0x33E91056, 0x136DD647,
        0x8C9AD761, 0x7A37A10C, 0x8E59F814, 0x89EB133C, 0xEECEA927, 0x35B761C9, 0xEDE11CE5, 0x3C7A47B1,
        0x599CD2DF, 0x3F55F273, 0x791814CE, 0xBF73C737, 0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB,
        0x81CAAFF3, 0x3EB968C4, 0x2C382434, 0x5FC2A340, 0x72161DC3, 0x0CBCE225, 0x8B283C49, 0x41FF0D95,
        0x7139A801, 0xDE080CB3, 0x9CD8B4E4, 0x906456C1, 0x617BCB84, 0x70D532B6, 0x74486C5C, 0x42D0B857
    );

    /**
     * Precomputed invMixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $dt2 = array(
        0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27, 0x6BCB3BAB, 0x45F11F9D, 0x58ABACFA, 0x03934BE3,
        0xFA552030, 0x6DF6AD76, 0x769188CC, 0x4C25F502, 0xD7FC4FE5, 0xCBD7C52A, 0x44802635, 0xA38FB562,
        0x5A49DEB1, 0x1B6725BA, 0x0E9845EA, 0xC0E15DFE, 0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3,
        0x5FE7038F, 0x9C951592, 0x7AEBBF6D, 0x59DA9552, 0x832DD4BE, 0x21D35874, 0x692949E0, 0xC8448EC9,
        0x896A75C2, 0x7978F48E, 0x3E6B9958, 0x71DD27B9, 0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE,
        0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253, 0x77E0B164, 0xAE84BB6B, 0xA01CFE81, 0x2B94F908,
        0x68587048, 0xFD198F45, 0x6C8794DE, 0xF8B7527B, 0xD323AB73, 0x02E2724B, 0x8F57E31F, 0xAB2A6655,
        0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x08A5D337, 0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16,
        0x1C2B8ACF, 0xB492A779, 0xF2F0F307, 0xE2A14E69, 0xF4CD65DA, 0xBED50605, 0x621FD134, 0xFE8AC4A6,
        0x539D342E, 0x55A0A2F3, 0xE132058A, 0xEB75A4F6, 0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E,
        0x8AF93E21, 0x063D96DD, 0x05AEDD3E, 0xBD464DE6, 0x8DB59154, 0x5D0571C4, 0xD46F0406, 0x15FF6050,
        0xFB241998, 0xE997D6BD, 0x43CC8940, 0x9E7767D9, 0x42BDB0E8, 0x8B880789, 0x5B38E719, 0xEEDB79C8,
        0x0A47A17C, 0x0FE97C42, 0x1EC9F884, 0x00000000, 0x86830980, 0xED48322B, 0x70AC1E11, 0x724E6C5A,
        0xFFFBFD0E, 0x38560F85, 0xD51E3DAE, 0x3927362D, 0xD9640A0F, 0xA621685C, 0x54D19B5B, 0x2E3A2436,
        0x67B10C0A, 0xE70F9357, 0x96D2B4EE, 0x919E1B9B, 0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12,
        0xBA0AE293, 0x2AE5C0A0, 0xE0433C22, 0x171D121B, 0x0D0B0E09, 0xC7ADF28B, 0xA8B92DB6, 0xA9C8141E,
        0x198557F1, 0x074CAF75, 0xDDBBEE99, 0x60FDA37F, 0x269FF701, 0xF5BC5C72, 0x3BC54466, 0x7E345BFB,
        0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4, 0xDCCAD731, 0x85104263, 0x22401397, 0x112084C6,
        0x247D854A, 0x3DF8D2BB, 0x3211AEF9, 0xA16DC729, 0x2F4B1D9E, 0x30F3DCB2, 0x52EC0D86, 0xE3D077C1,
        0x166C2BB3, 0xB999A970, 0x48FA1194, 0x642247E9, 0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233,
        0x4EC78749, 0xD1C1D938, 0xA2FE8CCA, 0x0B3698D4, 0x81CFA6F5, 0xDE28A57A, 0x8E26DAB7, 0xBFA43FAD,
        0x9DE42C3A, 0x920D5078, 0xCC9B6A5F, 0x4662547E, 0x13C2F68D, 0xB8E890D8, 0xF75E2E39, 0xAFF582C3,
        0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25, 0x993BC8AC, 0x7DA71018, 0x636EE89C, 0xBB7BDB3B,
        0x7809CD26, 0x18F46E59, 0xB701EC9A, 0x9AA8834F, 0x6E65E695, 0xE67EAAFF, 0xCF0821BC, 0xE8E6EF15,
        0x9BD9BAE7, 0x36CE4A6F, 0x09D4EA9F, 0x7CD629B0, 0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2,
        0xBC37744E, 0xCAA6FC82, 0xD0B0E090, 0xD81533A7, 0x984AF104, 0xDAF741EC, 0x500E7FCD, 0xF62F1791,
        0xD68D764D, 0xB04D43EF, 0x4D54CCAA, 0x04DFE496, 0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C, 0x517F4665,
        0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B, 0x1D5AB367, 0xD25292DB, 0x5633E910, 0x47136DD6,
        0x618C9AD7, 0x0C7A37A1, 0x148E59F8, 0x3C89EB13, 0x27EECEA9, 0xC935B761, 0xE5EDE11C, 0xB13C7A47,
        0xDF599CD2, 0x733F55F2, 0xCE791814, 0x37BF73C7, 0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844,
        0xF381CAAF, 0xC43EB968, 0x342C3824, 0x405FC2A3, 0xC372161D, 0x250CBCE2, 0x498B283C, 0x9541FF0D,
        0x017139A8, 0xB3DE080C, 0xE49CD8B4, 0xC1906456, 0x84617BCB, 0xB670D532, 0x5C74486C, 0x5742D0B8
    );

    /**
     * Precomputed invMixColumns table
     *
     * @see Crypt_Rijndael:_encryptBlock()
     * @see Crypt_Rijndael:_decryptBlock()
     * @var Array
     * @access private
     */
    var $dt3 = array(
        0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,
        0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,
        0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,
        0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,
        0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,
        0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,
        0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,
        0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,
        0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,
        0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,
        0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,
        0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,
        0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,
        0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,
        0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,
        0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,
        0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,
        0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,
        0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,
        0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,
        0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,
        0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,
        0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,
        0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,
        0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,
        0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,
        0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,
        0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,
        0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,
        0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,
        0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,
        0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0
    );

    /**
     * The SubByte S-Box
     *
     * @see Crypt_Rijndael::_encryptBlock()
     * @var Array
     * @access private
     */
    var $sbox = array(
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    );

    /**
     * The inverse SubByte S-Box
     *
     * @see Crypt_Rijndael::_decryptBlock()
     * @var Array
     * @access private
     */
    var $isbox = array(
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    );

    /**
     * Sets the key.
     *
     * Keys can be of any length.  Rijndael, itself, requires the use of a key that's between 128-bits and 256-bits long and
     * whose length is a multiple of 32.  If the key is less than 256-bits and the key length isn't set, we round the length
     * up to the closest valid key length, padding $key with null bytes.  If the key is more than 256-bits, we trim the
     * excess bits.
     *
     * If the key is not explicitly set, it'll be assumed to be all null bytes.
     *
     * Note: 160/224-bit keys must explicitly set by setKeyLength(), otherwise they will be round/pad up to 192/256 bits.
     *
     * @see Crypt_Base:setKey()
     * @see setKeyLength()
     * @access public
     * @param String $key
     */
    function setKey($key)
    {
        parent::setKey($key);

        if (!$this->explicit_key_length) {
            $length = strlen($key);
            switch (true) {
                case $length <= 16:
                    $this->key_size = 16;
                    break;
                case $length <= 20:
                    $this->key_size = 20;
                    break;
                case $length <= 24:
                    $this->key_size = 24;
                    break;
                case $length <= 28:
                    $this->key_size = 28;
                    break;
                default:
                    $this->key_size = 32;
            }
            $this->_setupEngine();
        }
    }

    /**
     * Sets the key length
     *
     * Valid key lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to
     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
     *
     * Note: phpseclib extends Rijndael (and AES) for using 160- and 224-bit keys but they are officially not defined
     *       and the most (if not all) implementations are not able using 160/224-bit keys but round/pad them up to
     *       192/256 bits as, for example, mcrypt will do.
     *
     *       That said, if you want be compatible with other Rijndael and AES implementations,
     *       you should not setKeyLength(160) or setKeyLength(224).
     *
     * Additional: In case of 160- and 224-bit keys, phpseclib will/can, for that reason, not use
     *             the mcrypt php extension, even if available.
     *             This results then in slower encryption.
     *
     * @access public
     * @param Integer $length
     */
    function setKeyLength($length)
    {
        switch (true) {
            case $length == 160:
                $this->key_size = 20;
                break;
            case $length == 224:
                $this->key_size = 28;
                break;
            case $length <= 128:
                $this->key_size = 16;
                break;
            case $length <= 192:
                $this->key_size = 24;
                break;
            default:
                $this->key_size = 32;
        }

        $this->explicit_key_length = true;
        $this->changed = true;
        $this->_setupEngine();
    }

    /**
     * Sets the block length
     *
     * Valid block lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to
     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
     *
     * @access public
     * @param Integer $length
     */
    function setBlockLength($length)
    {
        $length >>= 5;
        if ($length > 8) {
            $length = 8;
        } else if ($length < 4) {
            $length = 4;
        }
        $this->Nb = $length;
        $this->block_size = $length << 2;
        $this->changed = true;
        $this->_setupEngine();
    }

    /**
     * Setup the fastest possible $engine
     *
     * Determines if the mcrypt (MODE_MCRYPT) $engine available
     * and usable for the current $block_size and $key_size.
     *
     * If not, the slower MODE_INTERNAL $engine will be set.
     *
     * @see setKey()
     * @see setKeyLength()
     * @see setBlockLength()
     * @access private
     */
    function _setupEngine()
    {
        if (constant('CRYPT_' . $this->const_namespace . '_MODE') == CRYPT_MODE_INTERNAL) {
            // No mcrypt support at all for rijndael
            return;
        }

        // The required mcrypt module name for the current $block_size of rijndael
        $cipher_name_mcrypt = 'rijndael-' . ($this->block_size << 3);

        // Determining the availibility/usability of $cipher_name_mcrypt
        switch (true) {
            case $this->key_size % 8: // mcrypt is not usable for 160/224-bit keys, only for 128/192/256-bit keys
            case !in_array($cipher_name_mcrypt, mcrypt_list_algorithms()): // $cipher_name_mcrypt is not available for the current $block_size
                $engine = CRYPT_MODE_INTERNAL;
                break;
            default:
                $engine = CRYPT_MODE_MCRYPT;
        }

        if ($this->engine == $engine && $this->cipher_name_mcrypt == $cipher_name_mcrypt) {
            // allready set, so we not unnecessary close $this->enmcrypt/demcrypt/ecb
            return;
        }

        // Set the $engine
        $this->engine = $engine;
        $this->cipher_name_mcrypt = $cipher_name_mcrypt;

        if ($this->enmcrypt) {
            // Closing the current mcrypt resource(s). _mcryptSetup() will, if needed,
            // (re)open them with the module named in $this->cipher_name_mcrypt
            mcrypt_module_close($this->enmcrypt);
            mcrypt_module_close($this->demcrypt);
            $this->enmcrypt = null;
            $this->demcrypt = null;

            if ($this->ecb) {
                mcrypt_module_close($this->ecb);
                $this->ecb = null;
            }
        }
    }

    /**
     * Setup the CRYPT_MODE_MCRYPT $engine
     *
     * @see Crypt_Base::_setupMcrypt()
     * @access private
     */
    function _setupMcrypt()
    {
        $this->key = str_pad(substr($this->key, 0, $this->key_size), $this->key_size, "\0");
        parent::_setupMcrypt();
    }

    /**
     * Encrypts a block
     *
     * @access private
     * @param String $in
     * @return String
     */
    function _encryptBlock($in)
    {
        static $t0, $t1, $t2, $t3, $sbox;
        if (!$t0) {
            for ($i = 0; $i < 256; ++$i) {
                $t0[] = (int)$this->t0[$i];
                $t1[] = (int)$this->t1[$i];
                $t2[] = (int)$this->t2[$i];
                $t3[] = (int)$this->t3[$i];
                $sbox[] = (int)$this->sbox[$i];
            }
        }

        $state = array();
        $words = unpack('N*', $in);

        $c = $this->c;
        $w = $this->w;
        $Nb = $this->Nb;
        $Nr = $this->Nr;

        // addRoundKey
        $i = -1;
        foreach ($words as $word) {
            $state[] = $word ^ $w[0][++$i];
        }

        // fips-197.pdf#page=19, "Figure 5. Pseudo Code for the Cipher", states that this loop has four components -
        // subBytes, shiftRows, mixColumns, and addRoundKey. fips-197.pdf#page=30, "Implementation Suggestions Regarding
        // Various Platforms" suggests that performs enhanced implementations are described in Rijndael-ammended.pdf.
        // Rijndael-ammended.pdf#page=20, "Implementation aspects / 32-bit processor", discusses such an optimization.
        // Unfortunately, the description given there is not quite correct.  Per aes.spec.v316.pdf#page=19 [1],
        // equation (7.4.7) is supposed to use addition instead of subtraction, so we'll do that here, as well.

        // [1] http://fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.v316.pdf
        $temp = array();
        for ($round = 1; $round < $Nr; ++$round) {
            $i = 0; // $c[0] == 0
            $j = $c[1];
            $k = $c[2];
            $l = $c[3];

            while ($i < $Nb) {
                $temp[$i] = $t0[$state[$i] >> 24 & 0x000000FF] ^
                            $t1[$state[$j] >> 16 & 0x000000FF] ^
                            $t2[$state[$k] >>  8 & 0x000000FF] ^
                            $t3[$state[$l]       & 0x000000FF] ^
                            $w[$round][$i];
                ++$i;
                $j = ($j + 1) % $Nb;
                $k = ($k + 1) % $Nb;
                $l = ($l + 1) % $Nb;
            }
            $state = $temp;
        }

        // subWord
        for ($i = 0; $i < $Nb; ++$i) {
            $state[$i] =   $sbox[$state[$i]       & 0x000000FF]        |
                          ($sbox[$state[$i] >>  8 & 0x000000FF] <<  8) |
                          ($sbox[$state[$i] >> 16 & 0x000000FF] << 16) |
                          ($sbox[$state[$i] >> 24 & 0x000000FF] << 24);
        }

        // shiftRows + addRoundKey
        $i = 0; // $c[0] == 0
        $j = $c[1];
        $k = $c[2];
        $l = $c[3];
        while ($i < $Nb) {
            $temp[$i] = ($state[$i] & 0xFF000000) ^
                        ($state[$j] & 0x00FF0000) ^
                        ($state[$k] & 0x0000FF00) ^
                        ($state[$l] & 0x000000FF) ^
                         $w[$Nr][$i];
            ++$i;
            $j = ($j + 1) % $Nb;
            $k = ($k + 1) % $Nb;
            $l = ($l + 1) % $Nb;
        }

        switch ($Nb) {
            case 8:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
            case 7:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
            case 6:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
            case 5:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
            default:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
        }
    }

    /**
     * Decrypts a block
     *
     * @access private
     * @param String $in
     * @return String
     */
    function _decryptBlock($in)
    {
        static $dt0, $dt1, $dt2, $dt3, $isbox;
        if (!$dt0) {
            for ($i = 0; $i < 256; ++$i) {
                $dt0[] = (int)$this->dt0[$i];
                $dt1[] = (int)$this->dt1[$i];
                $dt2[] = (int)$this->dt2[$i];
                $dt3[] = (int)$this->dt3[$i];
                $isbox[] = (int)$this->isbox[$i];
            }
        }

        $state = array();
        $words = unpack('N*', $in);

        $c  = $this->c;
        $dw = $this->dw;
        $Nb = $this->Nb;
        $Nr = $this->Nr;

        // addRoundKey
        $i = -1;
        foreach ($words as $word) {
            $state[] = $word ^ $dw[$Nr][++$i];
        }

        $temp = array();
        for ($round = $Nr - 1; $round > 0; --$round) {
            $i = 0; // $c[0] == 0
            $j = $Nb - $c[1];
            $k = $Nb - $c[2];
            $l = $Nb - $c[3];

            while ($i < $Nb) {
                $temp[$i] = $dt0[$state[$i] >> 24 & 0x000000FF] ^
                            $dt1[$state[$j] >> 16 & 0x000000FF] ^
                            $dt2[$state[$k] >>  8 & 0x000000FF] ^
                            $dt3[$state[$l]       & 0x000000FF] ^
                            $dw[$round][$i];
                ++$i;
                $j = ($j + 1) % $Nb;
                $k = ($k + 1) % $Nb;
                $l = ($l + 1) % $Nb;
            }
            $state = $temp;
        }

        // invShiftRows + invSubWord + addRoundKey
        $i = 0; // $c[0] == 0
        $j = $Nb - $c[1];
        $k = $Nb - $c[2];
        $l = $Nb - $c[3];

        while ($i < $Nb) {
            $word = ($state[$i] & 0xFF000000) |
                    ($state[$j] & 0x00FF0000) |
                    ($state[$k] & 0x0000FF00) |
                    ($state[$l] & 0x000000FF);

            $temp[$i] = $dw[0][$i] ^ ($isbox[$word       & 0x000000FF]        |
                                     ($isbox[$word >>  8 & 0x000000FF] <<  8) |
                                     ($isbox[$word >> 16 & 0x000000FF] << 16) |
                                     ($isbox[$word >> 24 & 0x000000FF] << 24));
            ++$i;
            $j = ($j + 1) % $Nb;
            $k = ($k + 1) % $Nb;
            $l = ($l + 1) % $Nb;
        }

        switch ($Nb) {
            case 8:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
            case 7:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
            case 6:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
            case 5:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
            default:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
        }
    }

    /**
     * Setup the key (expansion)
     *
     * @see Crypt_Base::_setupKey()
     * @access private
     */
    function _setupKey()
    {
        // Each number in $rcon is equal to the previous number multiplied by two in Rijndael's finite field.
        // See http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse
        static $rcon = array(0,
            0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
            0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000,
            0x6C000000, 0xD8000000, 0xAB000000, 0x4D000000, 0x9A000000,
            0x2F000000, 0x5E000000, 0xBC000000, 0x63000000, 0xC6000000,
            0x97000000, 0x35000000, 0x6A000000, 0xD4000000, 0xB3000000,
            0x7D000000, 0xFA000000, 0xEF000000, 0xC5000000, 0x91000000
        );

        $this->key = str_pad(substr($this->key, 0, $this->key_size), $this->key_size, "\0");

        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->key_size === $this->kl['key_size'] && $this->block_size === $this->kl['block_size']) {
            // already expanded
            return;
        }
        $this->kl = array('key' => $this->key, 'key_size' => $this->key_size, 'block_size' => $this->block_size);

        $this->Nk = $this->key_size >> 2;
        // see Rijndael-ammended.pdf#page=44
        $this->Nr = max($this->Nk, $this->Nb) + 6;

        // shift offsets for Nb = 5, 7 are defined in Rijndael-ammended.pdf#page=44,
        //     "Table 8: Shift offsets in Shiftrow for the alternative block lengths"
        // shift offsets for Nb = 4, 6, 8 are defined in Rijndael-ammended.pdf#page=14,
        //     "Table 2: Shift offsets for different block lengths"
        switch ($this->Nb) {
            case 4:
            case 5:
            case 6:
                $this->c = array(0, 1, 2, 3);
                break;
            case 7:
                $this->c = array(0, 1, 2, 4);
                break;
            case 8:
                $this->c = array(0, 1, 3, 4);
        }

        $w = array_values(unpack('N*words', $this->key));

        $length = $this->Nb * ($this->Nr + 1);
        for ($i = $this->Nk; $i < $length; $i++) {
            $temp = $w[$i - 1];
            if ($i % $this->Nk == 0) {
                // according to <http://php.net/language.types.integer>, "the size of an integer is platform-dependent".
                // on a 32-bit machine, it's 32-bits, and on a 64-bit machine, it's 64-bits. on a 32-bit machine,
                // 0xFFFFFFFF << 8 == 0xFFFFFF00, but on a 64-bit machine, it equals 0xFFFFFFFF00. as such, doing 'and'
                // with 0xFFFFFFFF (or 0xFFFFFF00) on a 32-bit machine is unnecessary, but on a 64-bit machine, it is.
                $temp = (($temp << 8) & 0xFFFFFF00) | (($temp >> 24) & 0x000000FF); // rotWord
                $temp = $this->_subWord($temp) ^ $rcon[$i / $this->Nk];
            } else if ($this->Nk > 6 && $i % $this->Nk == 4) {
                $temp = $this->_subWord($temp);
            }
            $w[$i] = $w[$i - $this->Nk] ^ $temp;
        }

        // convert the key schedule from a vector of $Nb * ($Nr + 1) length to a matrix with $Nr + 1 rows and $Nb columns
        // and generate the inverse key schedule.  more specifically,
        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=23> (section 5.3.3),
        // "The key expansion for the Inverse Cipher is defined as follows:
        //        1. Apply the Key Expansion.
        //        2. Apply InvMixColumn to all Round Keys except the first and the last one."
        // also, see fips-197.pdf#page=27, "5.3.5 Equivalent Inverse Cipher"
        $temp = $this->w = $this->dw = array();
        for ($i = $row = $col = 0; $i < $length; $i++, $col++) {
            if ($col == $this->Nb) {
                if ($row == 0) {
                    $this->dw[0] = $this->w[0];
                } else {
                    // subWord + invMixColumn + invSubWord = invMixColumn
                    $j = 0;
                    while ($j < $this->Nb) {
                        $dw = $this->_subWord($this->w[$row][$j]);
                        $temp[$j] = $this->dt0[$dw >> 24 & 0x000000FF] ^
                                    $this->dt1[$dw >> 16 & 0x000000FF] ^
                                    $this->dt2[$dw >>  8 & 0x000000FF] ^
                                    $this->dt3[$dw       & 0x000000FF];
                        $j++;
                    }
                    $this->dw[$row] = $temp;
                }

                $col = 0;
                $row++;
            }
            $this->w[$row][$col] = $w[$i];
        }

        $this->dw[$row] = $this->w[$row];

        // In case of $this->use_inline_crypt === true we have to use 1-dim key arrays (both ascending)
        if ($this->use_inline_crypt) {
            $this->dw = array_reverse($this->dw);
            $w  = array_pop($this->w);
            $dw = array_pop($this->dw);
            foreach ($this->w as $r => $wr) {
                foreach ($wr as $c => $wc) {
                    $w[]  = $wc;
                    $dw[] = $this->dw[$r][$c];
                }
            }
            $this->w  = $w;
            $this->dw = $dw;
        }
    }

    /**
     * Performs S-Box substitutions
     *
     * @access private
     * @param Integer $word
     */
    function _subWord($word)
    {
        $sbox = $this->sbox;

        return  $sbox[$word       & 0x000000FF]        |
               ($sbox[$word >>  8 & 0x000000FF] <<  8) |
               ($sbox[$word >> 16 & 0x000000FF] << 16) |
               ($sbox[$word >> 24 & 0x000000FF] << 24);
    }

    /**
     * Setup the performance-optimized function for de/encrypt()
     *
     * @see Crypt_Base::_setupInlineCrypt()
     * @access private
     */
    function _setupInlineCrypt()
    {
        // Note: _setupInlineCrypt() will be called only if $this->changed === true
        // So here we are'nt under the same heavy timing-stress as we are in _de/encryptBlock() or de/encrypt().
        // However...the here generated function- $code, stored as php callback in $this->inline_crypt, must work as fast as even possible.

        $lambda_functions =& Crypt_Rijndael::_getLambdaFunctions();

        // The first 10 generated $lambda_functions will use the key-words hardcoded for better performance.
        // For memory reason we limit those ultra-optimized functions.
        // After that, we use pure (extracted) integer vars for the key-words which is faster than accessing them via array.
        if (count($lambda_functions) < 10) {
            $w  = $this->w;
            $dw = $this->dw;
            $init_encrypt = '';
            $init_decrypt = '';
        } else {
            for ($i = 0, $cw = count($this->w); $i < $cw; ++$i) {
                $w[]  = '$w['  . $i . ']';
                $dw[] = '$dw[' . $i . ']';
            }
            $init_encrypt = '$w = $self->w;';
            $init_decrypt = '$dw = $self->dw;';
        }

        $code_hash = md5(str_pad("Crypt_Rijndael, {$this->mode}, {$this->block_size}, ", 32, "\0") . implode(',', $w));

        if (!isset($lambda_functions[$code_hash])) {
            $Nr = $this->Nr;
            $Nb = $this->Nb;
            $c  = $this->c;

            // Generating encrypt code:
            $init_encrypt.= '
                static $t0, $t1, $t2, $t3, $sbox;
                if (!$t0) {
                    for ($i = 0; $i < 256; ++$i) {
                        $t0[$i]    = (int)$self->t0[$i];
                        $t1[$i]    = (int)$self->t1[$i];
                        $t2[$i]    = (int)$self->t2[$i];
                        $t3[$i]    = (int)$self->t3[$i];
                        $sbox[$i]  = (int)$self->sbox[$i];
                    }
                }
            ';

            $s  = 'e';
            $e  = 's';
            $wc = $Nb - 1;

            // Preround: addRoundKey
            $encrypt_block = '$in = unpack("N*", $in);'."\n";
            for ($i = 0; $i < $Nb; ++$i) {
                $encrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$w[++$wc].";\n";
            }

            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey
            for ($round = 1; $round < $Nr; ++$round) {
                list($s, $e) = array($e, $s);
                for ($i = 0; $i < $Nb; ++$i) {
                    $encrypt_block.=
                        '$'.$e.$i.' =
                        $t0[($'.$s.$i                  .' >> 24) & 0xff] ^
                        $t1[($'.$s.(($i + $c[1]) % $Nb).' >> 16) & 0xff] ^
                        $t2[($'.$s.(($i + $c[2]) % $Nb).' >>  8) & 0xff] ^
                        $t3[ $'.$s.(($i + $c[3]) % $Nb).'        & 0xff] ^
                        '.$w[++$wc].";\n";
                }
            }

            // Finalround: subWord + shiftRows + addRoundKey
            for ($i = 0; $i < $Nb; ++$i) {
                $encrypt_block.=
                    '$'.$e.$i.' =
                     $sbox[ $'.$e.$i.'        & 0xff]        |
                    ($sbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |
                    ($sbox[($'.$e.$i.' >> 16) & 0xff] << 16) |
                    ($sbox[($'.$e.$i.' >> 24) & 0xff] << 24);'."\n";
            }
            $encrypt_block .= '$in = pack("N*"'."\n";
            for ($i = 0; $i < $Nb; ++$i) {
                $encrypt_block.= ',
                    ($'.$e.$i                  .' & 0xFF000000) ^
                    ($'.$e.(($i + $c[1]) % $Nb).' & 0x00FF0000) ^
                    ($'.$e.(($i + $c[2]) % $Nb).' & 0x0000FF00) ^
                    ($'.$e.(($i + $c[3]) % $Nb).' & 0x000000FF) ^
                    '.$w[$i]."\n";
            }
            $encrypt_block .= ');';

            // Generating decrypt code:
            $init_decrypt.= '
                static $dt0, $dt1, $dt2, $dt3, $isbox;
                if (!$dt0) {
                    for ($i = 0; $i < 256; ++$i) {
                        $dt0[$i]   = (int)$self->dt0[$i];
                        $dt1[$i]   = (int)$self->dt1[$i];
                        $dt2[$i]   = (int)$self->dt2[$i];
                        $dt3[$i]   = (int)$self->dt3[$i];
                        $isbox[$i] = (int)$self->isbox[$i];
                    }
                }
            ';

            $s  = 'e';
            $e  = 's';
            $wc = $Nb - 1;

            // Preround: addRoundKey
            $decrypt_block = '$in = unpack("N*", $in);'."\n";
            for ($i = 0; $i < $Nb; ++$i) {
                $decrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$dw[++$wc].';'."\n";
            }

            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey
            for ($round = 1; $round < $Nr; ++$round) {
                list($s, $e) = array($e, $s);
                for ($i = 0; $i < $Nb; ++$i) {
                    $decrypt_block.=
                        '$'.$e.$i.' =
                        $dt0[($'.$s.$i                        .' >> 24) & 0xff] ^
                        $dt1[($'.$s.(($Nb + $i - $c[1]) % $Nb).' >> 16) & 0xff] ^
                        $dt2[($'.$s.(($Nb + $i - $c[2]) % $Nb).' >>  8) & 0xff] ^
                        $dt3[ $'.$s.(($Nb + $i - $c[3]) % $Nb).'        & 0xff] ^
                        '.$dw[++$wc].";\n";
                }
            }

            // Finalround: subWord + shiftRows + addRoundKey
            for ($i = 0; $i < $Nb; ++$i) {
                $decrypt_block.=
                    '$'.$e.$i.' =
                     $isbox[ $'.$e.$i.'        & 0xff]        |
                    ($isbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |
                    ($isbox[($'.$e.$i.' >> 16) & 0xff] << 16) |
                    ($isbox[($'.$e.$i.' >> 24) & 0xff] << 24);'."\n";
            }
            $decrypt_block .= '$in = pack("N*"'."\n";
            for ($i = 0; $i < $Nb; ++$i) {
                $decrypt_block.= ',
                    ($'.$e.$i.                        ' & 0xFF000000) ^
                    ($'.$e.(($Nb + $i - $c[1]) % $Nb).' & 0x00FF0000) ^
                    ($'.$e.(($Nb + $i - $c[2]) % $Nb).' & 0x0000FF00) ^
                    ($'.$e.(($Nb + $i - $c[3]) % $Nb).' & 0x000000FF) ^
                    '.$dw[$i]."\n";
            }
            $decrypt_block .= ');';

            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
                array(
                   'init_crypt'    => '',
                   'init_encrypt'  => $init_encrypt,
                   'init_decrypt'  => $init_decrypt,
                   'encrypt_block' => $encrypt_block,
                   'decrypt_block' => $decrypt_block
                )
            );
        }
        $this->inline_crypt = $lambda_functions[$code_hash];
    }
}

}
if (!class_exists('Crypt_AES')) {
    
/**
 * Pure-PHP implementation of AES.
 *
 * Uses mcrypt, if available/possible, and an internal implementation, otherwise.
 *
 * PHP versions 4 and 5
 *
 * If {@link Crypt_AES::setKeyLength() setKeyLength()} isn't called, it'll be calculated from
 * {@link Crypt_AES::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 136-bits
 * it'll be null-padded to 192-bits and 192 bits will be the key length until {@link Crypt_AES::setKey() setKey()}
 * is called, again, at which point, it'll be recalculated.
 *
 * Since Crypt_AES extends Crypt_Rijndael, some functions are available to be called that, in the context of AES, don't
 * make a whole lot of sense.  {@link Crypt_AES::setBlockLength() setBlockLength()}, for instance.  Calling that function,
 * however possible, won't do anything (AES has a fixed block length whereas Rijndael has a variable one).
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/AES.php';
 *
 *    $aes = new Crypt_AES();
 *
 *    $aes->setKey('abcdefghijklmnop');
 *
 *    $size = 10 * 1024;
 *    $plaintext = '';
 *    for ($i = 0; $i < $size; $i++) {
 *        $plaintext.= 'a';
 *    }
 *
 *    echo $aes->decrypt($aes->encrypt($plaintext));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_AES
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVIII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**
 * Include Crypt_Rijndael
 */
if (!class_exists('Crypt_Rijndael')) {
    include_once 'Rijndael.php';
}

/**#@+
 * @access public
 * @see Crypt_AES::encrypt()
 * @see Crypt_AES::decrypt()
 */
/**
 * Encrypt / decrypt using the Counter mode.
 *
 * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
 */
define('CRYPT_AES_MODE_CTR', CRYPT_MODE_CTR);
/**
 * Encrypt / decrypt using the Electronic Code Book mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
 */
define('CRYPT_AES_MODE_ECB', CRYPT_MODE_ECB);
/**
 * Encrypt / decrypt using the Code Book Chaining mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
 */
define('CRYPT_AES_MODE_CBC', CRYPT_MODE_CBC);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
 */
define('CRYPT_AES_MODE_CFB', CRYPT_MODE_CFB);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
 */
define('CRYPT_AES_MODE_OFB', CRYPT_MODE_OFB);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_Base::Crypt_Base()
 */
/**
 * Toggles the internal implementation
 */
define('CRYPT_AES_MODE_INTERNAL', CRYPT_MODE_INTERNAL);
/**
 * Toggles the mcrypt implementation
 */
define('CRYPT_AES_MODE_MCRYPT', CRYPT_MODE_MCRYPT);
/**#@-*/

/**
 * Pure-PHP implementation of AES.
 *
 * @package Crypt_AES
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_AES extends Crypt_Rijndael
{
    /**
     * The namespace used by the cipher for its constants.
     *
     * @see Crypt_Base::const_namespace
     * @var String
     * @access private
     */
    var $const_namespace = 'AES';

    /**
     * Dummy function
     *
     * Since Crypt_AES extends Crypt_Rijndael, this function is, technically, available, but it doesn't do anything.
     *
     * @see Crypt_Rijndael::setBlockLength()
     * @access public
     * @param Integer $length
     */
    function setBlockLength($length)
    {
        return;
    }

    /**
     * Sets the key length
     *
     * Valid key lengths are 128, 192, and 256.  If the length is less than 128, it will be rounded up to
     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
     *
     * @see Crypt_Rijndael:setKeyLength()
     * @access public
     * @param Integer $length
     */
    function setKeyLength($length)
    {
        switch ($length) {
            case 160:
                $length = 192;
                break;
            case 224:
                $length = 256;
        }
        parent::setKeyLength($length);
    }

    /**
     * Sets the key.
     *
     * Rijndael supports five different key lengths, AES only supports three.
     *
     * @see Crypt_Rijndael:setKey()
     * @see setKeyLength()
     * @access public
     * @param String $key
     */
    function setKey($key)
    {
        parent::setKey($key);

        if (!$this->explicit_key_length) {
            $length = strlen($key);
            switch (true) {
                case $length <= 16:
                    $this->key_size = 16;
                    break;
                case $length <= 24:
                    $this->key_size = 24;
                    break;
                default:
                    $this->key_size = 32;
            }
            $this->_setupEngine();
        }
    }
}

}
if (!class_exists('Crypt_DES')) {
    
/**
 * Pure-PHP implementation of DES.
 *
 * Uses mcrypt, if available, and an internal implementation, otherwise.
 *
 * PHP versions 4 and 5
 *
 * Useful resources are as follows:
 *
 *  - {@link http://en.wikipedia.org/wiki/DES_supplementary_material Wikipedia: DES supplementary material}
 *  - {@link http://www.itl.nist.gov/fipspubs/fip46-2.htm FIPS 46-2 - (DES), Data Encryption Standard}
 *  - {@link http://www.cs.eku.edu/faculty/styer/460/Encrypt/JS-DES.html JavaScript DES Example}
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/DES.php';
 *
 *    $des = new Crypt_DES();
 *
 *    $des->setKey('abcdefgh');
 *
 *    $size = 10 * 1024;
 *    $plaintext = '';
 *    for ($i = 0; $i < $size; $i++) {
 *        $plaintext.= 'a';
 *    }
 *
 *    echo $des->decrypt($des->encrypt($plaintext));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_DES
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**
 * Include Crypt_Base
 *
 * Base cipher class
 */
if (!class_exists('Crypt_Base')) {
    include_once 'Base.php';
}

/**#@+
 * @access private
 * @see Crypt_DES::_setupKey()
 * @see Crypt_DES::_processBlock()
 */
/**
 * Contains $keys[CRYPT_DES_ENCRYPT]
 */
define('CRYPT_DES_ENCRYPT', 0);
/**
 * Contains $keys[CRYPT_DES_DECRYPT]
 */
define('CRYPT_DES_DECRYPT', 1);
/**#@-*/

/**#@+
 * @access public
 * @see Crypt_DES::encrypt()
 * @see Crypt_DES::decrypt()
 */
/**
 * Encrypt / decrypt using the Counter mode.
 *
 * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
 */
define('CRYPT_DES_MODE_CTR', CRYPT_MODE_CTR);
/**
 * Encrypt / decrypt using the Electronic Code Book mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
 */
define('CRYPT_DES_MODE_ECB', CRYPT_MODE_ECB);
/**
 * Encrypt / decrypt using the Code Book Chaining mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
 */
define('CRYPT_DES_MODE_CBC', CRYPT_MODE_CBC);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
 */
define('CRYPT_DES_MODE_CFB', CRYPT_MODE_CFB);
/**
 * Encrypt / decrypt using the Cipher Feedback mode.
 *
 * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
 */
define('CRYPT_DES_MODE_OFB', CRYPT_MODE_OFB);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_Base::Crypt_Base()
 */
/**
 * Toggles the internal implementation
 */
define('CRYPT_DES_MODE_INTERNAL', CRYPT_MODE_INTERNAL);
/**
 * Toggles the mcrypt implementation
 */
define('CRYPT_DES_MODE_MCRYPT', CRYPT_MODE_MCRYPT);
/**#@-*/

/**
 * Pure-PHP implementation of DES.
 *
 * @package Crypt_DES
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_DES extends Crypt_Base
{
    /**
     * Block Length of the cipher
     *
     * @see Crypt_Base::block_size
     * @var Integer
     * @access private
     */
    var $block_size = 8;

    /**
     * The Key
     *
     * @see Crypt_Base::key
     * @see setKey()
     * @var String
     * @access private
     */
    var $key = "\0\0\0\0\0\0\0\0";

    /**
     * The default password key_size used by setPassword()
     *
     * @see Crypt_Base::password_key_size
     * @see Crypt_Base::setPassword()
     * @var Integer
     * @access private
     */
    var $password_key_size = 8;

    /**
     * The namespace used by the cipher for its constants.
     *
     * @see Crypt_Base::const_namespace
     * @var String
     * @access private
     */
    var $const_namespace = 'DES';

    /**
     * The mcrypt specific name of the cipher
     *
     * @see Crypt_Base::cipher_name_mcrypt
     * @var String
     * @access private
     */
    var $cipher_name_mcrypt = 'des';

    /**
     * Optimizing value while CFB-encrypting
     *
     * @see Crypt_Base::cfb_init_len
     * @var Integer
     * @access private
     */
    var $cfb_init_len = 500;

    /**
     * Switch for DES/3DES encryption
     *
     * Used only if $engine == CRYPT_DES_MODE_INTERNAL
     *
     * @see Crypt_DES::_setupKey()
     * @see Crypt_DES::_processBlock()
     * @var Integer
     * @access private
     */
    var $des_rounds = 1;

    /**
     * max possible size of $key
     *
     * @see Crypt_DES::setKey()
     * @var String
     * @access private
     */
    var $key_size_max = 8;

    /**
     * The Key Schedule
     *
     * @see Crypt_DES::_setupKey()
     * @var Array
     * @access private
     */
    var $keys;

    /**
     * Shuffle table.
     *
     * For each byte value index, the entry holds an 8-byte string
     * with each byte containing all bits in the same state as the
     * corresponding bit in the index value.
     *
     * @see Crypt_DES::_processBlock()
     * @see Crypt_DES::_setupKey()
     * @var Array
     * @access private
     */
    var $shuffle = array(
        "\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\xFF",
        "\x00\x00\x00\x00\x00\x00\xFF\x00", "\x00\x00\x00\x00\x00\x00\xFF\xFF",
        "\x00\x00\x00\x00\x00\xFF\x00\x00", "\x00\x00\x00\x00\x00\xFF\x00\xFF",
        "\x00\x00\x00\x00\x00\xFF\xFF\x00", "\x00\x00\x00\x00\x00\xFF\xFF\xFF",
        "\x00\x00\x00\x00\xFF\x00\x00\x00", "\x00\x00\x00\x00\xFF\x00\x00\xFF",
        "\x00\x00\x00\x00\xFF\x00\xFF\x00", "\x00\x00\x00\x00\xFF\x00\xFF\xFF",
        "\x00\x00\x00\x00\xFF\xFF\x00\x00", "\x00\x00\x00\x00\xFF\xFF\x00\xFF",
        "\x00\x00\x00\x00\xFF\xFF\xFF\x00", "\x00\x00\x00\x00\xFF\xFF\xFF\xFF",
        "\x00\x00\x00\xFF\x00\x00\x00\x00", "\x00\x00\x00\xFF\x00\x00\x00\xFF",
        "\x00\x00\x00\xFF\x00\x00\xFF\x00", "\x00\x00\x00\xFF\x00\x00\xFF\xFF",
        "\x00\x00\x00\xFF\x00\xFF\x00\x00", "\x00\x00\x00\xFF\x00\xFF\x00\xFF",
        "\x00\x00\x00\xFF\x00\xFF\xFF\x00", "\x00\x00\x00\xFF\x00\xFF\xFF\xFF",
        "\x00\x00\x00\xFF\xFF\x00\x00\x00", "\x00\x00\x00\xFF\xFF\x00\x00\xFF",
        "\x00\x00\x00\xFF\xFF\x00\xFF\x00", "\x00\x00\x00\xFF\xFF\x00\xFF\xFF",
        "\x00\x00\x00\xFF\xFF\xFF\x00\x00", "\x00\x00\x00\xFF\xFF\xFF\x00\xFF",
        "\x00\x00\x00\xFF\xFF\xFF\xFF\x00", "\x00\x00\x00\xFF\xFF\xFF\xFF\xFF",
        "\x00\x00\xFF\x00\x00\x00\x00\x00", "\x00\x00\xFF\x00\x00\x00\x00\xFF",
        "\x00\x00\xFF\x00\x00\x00\xFF\x00", "\x00\x00\xFF\x00\x00\x00\xFF\xFF",
        "\x00\x00\xFF\x00\x00\xFF\x00\x00", "\x00\x00\xFF\x00\x00\xFF\x00\xFF",
        "\x00\x00\xFF\x00\x00\xFF\xFF\x00", "\x00\x00\xFF\x00\x00\xFF\xFF\xFF",
        "\x00\x00\xFF\x00\xFF\x00\x00\x00", "\x00\x00\xFF\x00\xFF\x00\x00\xFF",
        "\x00\x00\xFF\x00\xFF\x00\xFF\x00", "\x00\x00\xFF\x00\xFF\x00\xFF\xFF",
        "\x00\x00\xFF\x00\xFF\xFF\x00\x00", "\x00\x00\xFF\x00\xFF\xFF\x00\xFF",
        "\x00\x00\xFF\x00\xFF\xFF\xFF\x00", "\x00\x00\xFF\x00\xFF\xFF\xFF\xFF",
        "\x00\x00\xFF\xFF\x00\x00\x00\x00", "\x00\x00\xFF\xFF\x00\x00\x00\xFF",
        "\x00\x00\xFF\xFF\x00\x00\xFF\x00", "\x00\x00\xFF\xFF\x00\x00\xFF\xFF",
        "\x00\x00\xFF\xFF\x00\xFF\x00\x00", "\x00\x00\xFF\xFF\x00\xFF\x00\xFF",
        "\x00\x00\xFF\xFF\x00\xFF\xFF\x00", "\x00\x00\xFF\xFF\x00\xFF\xFF\xFF",
        "\x00\x00\xFF\xFF\xFF\x00\x00\x00", "\x00\x00\xFF\xFF\xFF\x00\x00\xFF",
        "\x00\x00\xFF\xFF\xFF\x00\xFF\x00", "\x00\x00\xFF\xFF\xFF\x00\xFF\xFF",
        "\x00\x00\xFF\xFF\xFF\xFF\x00\x00", "\x00\x00\xFF\xFF\xFF\xFF\x00\xFF",
        "\x00\x00\xFF\xFF\xFF\xFF\xFF\x00", "\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF",
        "\x00\xFF\x00\x00\x00\x00\x00\x00", "\x00\xFF\x00\x00\x00\x00\x00\xFF",
        "\x00\xFF\x00\x00\x00\x00\xFF\x00", "\x00\xFF\x00\x00\x00\x00\xFF\xFF",
        "\x00\xFF\x00\x00\x00\xFF\x00\x00", "\x00\xFF\x00\x00\x00\xFF\x00\xFF",
        "\x00\xFF\x00\x00\x00\xFF\xFF\x00", "\x00\xFF\x00\x00\x00\xFF\xFF\xFF",
        "\x00\xFF\x00\x00\xFF\x00\x00\x00", "\x00\xFF\x00\x00\xFF\x00\x00\xFF",
        "\x00\xFF\x00\x00\xFF\x00\xFF\x00", "\x00\xFF\x00\x00\xFF\x00\xFF\xFF",
        "\x00\xFF\x00\x00\xFF\xFF\x00\x00", "\x00\xFF\x00\x00\xFF\xFF\x00\xFF",
        "\x00\xFF\x00\x00\xFF\xFF\xFF\x00", "\x00\xFF\x00\x00\xFF\xFF\xFF\xFF",
        "\x00\xFF\x00\xFF\x00\x00\x00\x00", "\x00\xFF\x00\xFF\x00\x00\x00\xFF",
        "\x00\xFF\x00\xFF\x00\x00\xFF\x00", "\x00\xFF\x00\xFF\x00\x00\xFF\xFF",
        "\x00\xFF\x00\xFF\x00\xFF\x00\x00", "\x00\xFF\x00\xFF\x00\xFF\x00\xFF",
        "\x00\xFF\x00\xFF\x00\xFF\xFF\x00", "\x00\xFF\x00\xFF\x00\xFF\xFF\xFF",
        "\x00\xFF\x00\xFF\xFF\x00\x00\x00", "\x00\xFF\x00\xFF\xFF\x00\x00\xFF",
        "\x00\xFF\x00\xFF\xFF\x00\xFF\x00", "\x00\xFF\x00\xFF\xFF\x00\xFF\xFF",
        "\x00\xFF\x00\xFF\xFF\xFF\x00\x00", "\x00\xFF\x00\xFF\xFF\xFF\x00\xFF",
        "\x00\xFF\x00\xFF\xFF\xFF\xFF\x00", "\x00\xFF\x00\xFF\xFF\xFF\xFF\xFF",
        "\x00\xFF\xFF\x00\x00\x00\x00\x00", "\x00\xFF\xFF\x00\x00\x00\x00\xFF",
        "\x00\xFF\xFF\x00\x00\x00\xFF\x00", "\x00\xFF\xFF\x00\x00\x00\xFF\xFF",
        "\x00\xFF\xFF\x00\x00\xFF\x00\x00", "\x00\xFF\xFF\x00\x00\xFF\x00\xFF",
        "\x00\xFF\xFF\x00\x00\xFF\xFF\x00", "\x00\xFF\xFF\x00\x00\xFF\xFF\xFF",
        "\x00\xFF\xFF\x00\xFF\x00\x00\x00", "\x00\xFF\xFF\x00\xFF\x00\x00\xFF",
        "\x00\xFF\xFF\x00\xFF\x00\xFF\x00", "\x00\xFF\xFF\x00\xFF\x00\xFF\xFF",
        "\x00\xFF\xFF\x00\xFF\xFF\x00\x00", "\x00\xFF\xFF\x00\xFF\xFF\x00\xFF",
        "\x00\xFF\xFF\x00\xFF\xFF\xFF\x00", "\x00\xFF\xFF\x00\xFF\xFF\xFF\xFF",
        "\x00\xFF\xFF\xFF\x00\x00\x00\x00", "\x00\xFF\xFF\xFF\x00\x00\x00\xFF",
        "\x00\xFF\xFF\xFF\x00\x00\xFF\x00", "\x00\xFF\xFF\xFF\x00\x00\xFF\xFF",
        "\x00\xFF\xFF\xFF\x00\xFF\x00\x00", "\x00\xFF\xFF\xFF\x00\xFF\x00\xFF",
        "\x00\xFF\xFF\xFF\x00\xFF\xFF\x00", "\x00\xFF\xFF\xFF\x00\xFF\xFF\xFF",
        "\x00\xFF\xFF\xFF\xFF\x00\x00\x00", "\x00\xFF\xFF\xFF\xFF\x00\x00\xFF",
        "\x00\xFF\xFF\xFF\xFF\x00\xFF\x00", "\x00\xFF\xFF\xFF\xFF\x00\xFF\xFF",
        "\x00\xFF\xFF\xFF\xFF\xFF\x00\x00", "\x00\xFF\xFF\xFF\xFF\xFF\x00\xFF",
        "\x00\xFF\xFF\xFF\xFF\xFF\xFF\x00", "\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
        "\xFF\x00\x00\x00\x00\x00\x00\x00", "\xFF\x00\x00\x00\x00\x00\x00\xFF",
        "\xFF\x00\x00\x00\x00\x00\xFF\x00", "\xFF\x00\x00\x00\x00\x00\xFF\xFF",
        "\xFF\x00\x00\x00\x00\xFF\x00\x00", "\xFF\x00\x00\x00\x00\xFF\x00\xFF",
        "\xFF\x00\x00\x00\x00\xFF\xFF\x00", "\xFF\x00\x00\x00\x00\xFF\xFF\xFF",
        "\xFF\x00\x00\x00\xFF\x00\x00\x00", "\xFF\x00\x00\x00\xFF\x00\x00\xFF",
        "\xFF\x00\x00\x00\xFF\x00\xFF\x00", "\xFF\x00\x00\x00\xFF\x00\xFF\xFF",
        "\xFF\x00\x00\x00\xFF\xFF\x00\x00", "\xFF\x00\x00\x00\xFF\xFF\x00\xFF",
        "\xFF\x00\x00\x00\xFF\xFF\xFF\x00", "\xFF\x00\x00\x00\xFF\xFF\xFF\xFF",
        "\xFF\x00\x00\xFF\x00\x00\x00\x00", "\xFF\x00\x00\xFF\x00\x00\x00\xFF",
        "\xFF\x00\x00\xFF\x00\x00\xFF\x00", "\xFF\x00\x00\xFF\x00\x00\xFF\xFF",
        "\xFF\x00\x00\xFF\x00\xFF\x00\x00", "\xFF\x00\x00\xFF\x00\xFF\x00\xFF",
        "\xFF\x00\x00\xFF\x00\xFF\xFF\x00", "\xFF\x00\x00\xFF\x00\xFF\xFF\xFF",
        "\xFF\x00\x00\xFF\xFF\x00\x00\x00", "\xFF\x00\x00\xFF\xFF\x00\x00\xFF",
        "\xFF\x00\x00\xFF\xFF\x00\xFF\x00", "\xFF\x00\x00\xFF\xFF\x00\xFF\xFF",
        "\xFF\x00\x00\xFF\xFF\xFF\x00\x00", "\xFF\x00\x00\xFF\xFF\xFF\x00\xFF",
        "\xFF\x00\x00\xFF\xFF\xFF\xFF\x00", "\xFF\x00\x00\xFF\xFF\xFF\xFF\xFF",
        "\xFF\x00\xFF\x00\x00\x00\x00\x00", "\xFF\x00\xFF\x00\x00\x00\x00\xFF",
        "\xFF\x00\xFF\x00\x00\x00\xFF\x00", "\xFF\x00\xFF\x00\x00\x00\xFF\xFF",
        "\xFF\x00\xFF\x00\x00\xFF\x00\x00", "\xFF\x00\xFF\x00\x00\xFF\x00\xFF",
        "\xFF\x00\xFF\x00\x00\xFF\xFF\x00", "\xFF\x00\xFF\x00\x00\xFF\xFF\xFF",
        "\xFF\x00\xFF\x00\xFF\x00\x00\x00", "\xFF\x00\xFF\x00\xFF\x00\x00\xFF",
        "\xFF\x00\xFF\x00\xFF\x00\xFF\x00", "\xFF\x00\xFF\x00\xFF\x00\xFF\xFF",
        "\xFF\x00\xFF\x00\xFF\xFF\x00\x00", "\xFF\x00\xFF\x00\xFF\xFF\x00\xFF",
        "\xFF\x00\xFF\x00\xFF\xFF\xFF\x00", "\xFF\x00\xFF\x00\xFF\xFF\xFF\xFF",
        "\xFF\x00\xFF\xFF\x00\x00\x00\x00", "\xFF\x00\xFF\xFF\x00\x00\x00\xFF",
        "\xFF\x00\xFF\xFF\x00\x00\xFF\x00", "\xFF\x00\xFF\xFF\x00\x00\xFF\xFF",
        "\xFF\x00\xFF\xFF\x00\xFF\x00\x00", "\xFF\x00\xFF\xFF\x00\xFF\x00\xFF",
        "\xFF\x00\xFF\xFF\x00\xFF\xFF\x00", "\xFF\x00\xFF\xFF\x00\xFF\xFF\xFF",
        "\xFF\x00\xFF\xFF\xFF\x00\x00\x00", "\xFF\x00\xFF\xFF\xFF\x00\x00\xFF",
        "\xFF\x00\xFF\xFF\xFF\x00\xFF\x00", "\xFF\x00\xFF\xFF\xFF\x00\xFF\xFF",
        "\xFF\x00\xFF\xFF\xFF\xFF\x00\x00", "\xFF\x00\xFF\xFF\xFF\xFF\x00\xFF",
        "\xFF\x00\xFF\xFF\xFF\xFF\xFF\x00", "\xFF\x00\xFF\xFF\xFF\xFF\xFF\xFF",
        "\xFF\xFF\x00\x00\x00\x00\x00\x00", "\xFF\xFF\x00\x00\x00\x00\x00\xFF",
        "\xFF\xFF\x00\x00\x00\x00\xFF\x00", "\xFF\xFF\x00\x00\x00\x00\xFF\xFF",
        "\xFF\xFF\x00\x00\x00\xFF\x00\x00", "\xFF\xFF\x00\x00\x00\xFF\x00\xFF",
        "\xFF\xFF\x00\x00\x00\xFF\xFF\x00", "\xFF\xFF\x00\x00\x00\xFF\xFF\xFF",
        "\xFF\xFF\x00\x00\xFF\x00\x00\x00", "\xFF\xFF\x00\x00\xFF\x00\x00\xFF",
        "\xFF\xFF\x00\x00\xFF\x00\xFF\x00", "\xFF\xFF\x00\x00\xFF\x00\xFF\xFF",
        "\xFF\xFF\x00\x00\xFF\xFF\x00\x00", "\xFF\xFF\x00\x00\xFF\xFF\x00\xFF",
        "\xFF\xFF\x00\x00\xFF\xFF\xFF\x00", "\xFF\xFF\x00\x00\xFF\xFF\xFF\xFF",
        "\xFF\xFF\x00\xFF\x00\x00\x00\x00", "\xFF\xFF\x00\xFF\x00\x00\x00\xFF",
        "\xFF\xFF\x00\xFF\x00\x00\xFF\x00", "\xFF\xFF\x00\xFF\x00\x00\xFF\xFF",
        "\xFF\xFF\x00\xFF\x00\xFF\x00\x00", "\xFF\xFF\x00\xFF\x00\xFF\x00\xFF",
        "\xFF\xFF\x00\xFF\x00\xFF\xFF\x00", "\xFF\xFF\x00\xFF\x00\xFF\xFF\xFF",
        "\xFF\xFF\x00\xFF\xFF\x00\x00\x00", "\xFF\xFF\x00\xFF\xFF\x00\x00\xFF",
        "\xFF\xFF\x00\xFF\xFF\x00\xFF\x00", "\xFF\xFF\x00\xFF\xFF\x00\xFF\xFF",
        "\xFF\xFF\x00\xFF\xFF\xFF\x00\x00", "\xFF\xFF\x00\xFF\xFF\xFF\x00\xFF",
        "\xFF\xFF\x00\xFF\xFF\xFF\xFF\x00", "\xFF\xFF\x00\xFF\xFF\xFF\xFF\xFF",
        "\xFF\xFF\xFF\x00\x00\x00\x00\x00", "\xFF\xFF\xFF\x00\x00\x00\x00\xFF",
        "\xFF\xFF\xFF\x00\x00\x00\xFF\x00", "\xFF\xFF\xFF\x00\x00\x00\xFF\xFF",
        "\xFF\xFF\xFF\x00\x00\xFF\x00\x00", "\xFF\xFF\xFF\x00\x00\xFF\x00\xFF",
        "\xFF\xFF\xFF\x00\x00\xFF\xFF\x00", "\xFF\xFF\xFF\x00\x00\xFF\xFF\xFF",
        "\xFF\xFF\xFF\x00\xFF\x00\x00\x00", "\xFF\xFF\xFF\x00\xFF\x00\x00\xFF",
        "\xFF\xFF\xFF\x00\xFF\x00\xFF\x00", "\xFF\xFF\xFF\x00\xFF\x00\xFF\xFF",
        "\xFF\xFF\xFF\x00\xFF\xFF\x00\x00", "\xFF\xFF\xFF\x00\xFF\xFF\x00\xFF",
        "\xFF\xFF\xFF\x00\xFF\xFF\xFF\x00", "\xFF\xFF\xFF\x00\xFF\xFF\xFF\xFF",
        "\xFF\xFF\xFF\xFF\x00\x00\x00\x00", "\xFF\xFF\xFF\xFF\x00\x00\x00\xFF",
        "\xFF\xFF\xFF\xFF\x00\x00\xFF\x00", "\xFF\xFF\xFF\xFF\x00\x00\xFF\xFF",
        "\xFF\xFF\xFF\xFF\x00\xFF\x00\x00", "\xFF\xFF\xFF\xFF\x00\xFF\x00\xFF",
        "\xFF\xFF\xFF\xFF\x00\xFF\xFF\x00", "\xFF\xFF\xFF\xFF\x00\xFF\xFF\xFF",
        "\xFF\xFF\xFF\xFF\xFF\x00\x00\x00", "\xFF\xFF\xFF\xFF\xFF\x00\x00\xFF",
        "\xFF\xFF\xFF\xFF\xFF\x00\xFF\x00", "\xFF\xFF\xFF\xFF\xFF\x00\xFF\xFF",
        "\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00", "\xFF\xFF\xFF\xFF\xFF\xFF\x00\xFF",
        "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    );

    /**
     * IP mapping helper table.
     *
     * Indexing this table with each source byte performs the initial bit permutation.
     *
     * @var Array
     * @access private
     */
    var $ipmap = array(
        0x00, 0x10, 0x01, 0x11, 0x20, 0x30, 0x21, 0x31,
        0x02, 0x12, 0x03, 0x13, 0x22, 0x32, 0x23, 0x33,
        0x40, 0x50, 0x41, 0x51, 0x60, 0x70, 0x61, 0x71,
        0x42, 0x52, 0x43, 0x53, 0x62, 0x72, 0x63, 0x73,
        0x04, 0x14, 0x05, 0x15, 0x24, 0x34, 0x25, 0x35,
        0x06, 0x16, 0x07, 0x17, 0x26, 0x36, 0x27, 0x37,
        0x44, 0x54, 0x45, 0x55, 0x64, 0x74, 0x65, 0x75,
        0x46, 0x56, 0x47, 0x57, 0x66, 0x76, 0x67, 0x77,
        0x80, 0x90, 0x81, 0x91, 0xA0, 0xB0, 0xA1, 0xB1,
        0x82, 0x92, 0x83, 0x93, 0xA2, 0xB2, 0xA3, 0xB3,
        0xC0, 0xD0, 0xC1, 0xD1, 0xE0, 0xF0, 0xE1, 0xF1,
        0xC2, 0xD2, 0xC3, 0xD3, 0xE2, 0xF2, 0xE3, 0xF3,
        0x84, 0x94, 0x85, 0x95, 0xA4, 0xB4, 0xA5, 0xB5,
        0x86, 0x96, 0x87, 0x97, 0xA6, 0xB6, 0xA7, 0xB7,
        0xC4, 0xD4, 0xC5, 0xD5, 0xE4, 0xF4, 0xE5, 0xF5,
        0xC6, 0xD6, 0xC7, 0xD7, 0xE6, 0xF6, 0xE7, 0xF7,
        0x08, 0x18, 0x09, 0x19, 0x28, 0x38, 0x29, 0x39,
        0x0A, 0x1A, 0x0B, 0x1B, 0x2A, 0x3A, 0x2B, 0x3B,
        0x48, 0x58, 0x49, 0x59, 0x68, 0x78, 0x69, 0x79,
        0x4A, 0x5A, 0x4B, 0x5B, 0x6A, 0x7A, 0x6B, 0x7B,
        0x0C, 0x1C, 0x0D, 0x1D, 0x2C, 0x3C, 0x2D, 0x3D,
        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
        0x4C, 0x5C, 0x4D, 0x5D, 0x6C, 0x7C, 0x6D, 0x7D,
        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
        0x88, 0x98, 0x89, 0x99, 0xA8, 0xB8, 0xA9, 0xB9,
        0x8A, 0x9A, 0x8B, 0x9B, 0xAA, 0xBA, 0xAB, 0xBB,
        0xC8, 0xD8, 0xC9, 0xD9, 0xE8, 0xF8, 0xE9, 0xF9,
        0xCA, 0xDA, 0xCB, 0xDB, 0xEA, 0xFA, 0xEB, 0xFB,
        0x8C, 0x9C, 0x8D, 0x9D, 0xAC, 0xBC, 0xAD, 0xBD,
        0x8E, 0x9E, 0x8F, 0x9F, 0xAE, 0xBE, 0xAF, 0xBF,
        0xCC, 0xDC, 0xCD, 0xDD, 0xEC, 0xFC, 0xED, 0xFD,
        0xCE, 0xDE, 0xCF, 0xDF, 0xEE, 0xFE, 0xEF, 0xFF
    );

    /**
     * Inverse IP mapping helper table.
     * Indexing this table with a byte value reverses the bit order.
     *
     * @var Array
     * @access private
     */
    var $invipmap = array(
        0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
        0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
        0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
        0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
        0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
        0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
        0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
        0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
        0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
        0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
        0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
        0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
        0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
        0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
        0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
        0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
        0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
        0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
        0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
        0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
        0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
        0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
        0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
        0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
        0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
        0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
        0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
        0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
        0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
        0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
        0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
        0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
    );

    /**
     * Pre-permuted S-box1
     *
     * Each box ($sbox1-$sbox8) has been vectorized, then each value pre-permuted using the
     * P table: concatenation can then be replaced by exclusive ORs.
     *
     * @var Array
     * @access private
     */
    var $sbox1 = array(
        0x00808200, 0x00000000, 0x00008000, 0x00808202,
        0x00808002, 0x00008202, 0x00000002, 0x00008000,
        0x00000200, 0x00808200, 0x00808202, 0x00000200,
        0x00800202, 0x00808002, 0x00800000, 0x00000002,
        0x00000202, 0x00800200, 0x00800200, 0x00008200,
        0x00008200, 0x00808000, 0x00808000, 0x00800202,
        0x00008002, 0x00800002, 0x00800002, 0x00008002,
        0x00000000, 0x00000202, 0x00008202, 0x00800000,
        0x00008000, 0x00808202, 0x00000002, 0x00808000,
        0x00808200, 0x00800000, 0x00800000, 0x00000200,
        0x00808002, 0x00008000, 0x00008200, 0x00800002,
        0x00000200, 0x00000002, 0x00800202, 0x00008202,
        0x00808202, 0x00008002, 0x00808000, 0x00800202,
        0x00800002, 0x00000202, 0x00008202, 0x00808200,
        0x00000202, 0x00800200, 0x00800200, 0x00000000,
        0x00008002, 0x00008200, 0x00000000, 0x00808002
    );

    /**
     * Pre-permuted S-box2
     *
     * @var Array
     * @access private
     */
    var $sbox2 = array(
        0x40084010, 0x40004000, 0x00004000, 0x00084010,
        0x00080000, 0x00000010, 0x40080010, 0x40004010,
        0x40000010, 0x40084010, 0x40084000, 0x40000000,
        0x40004000, 0x00080000, 0x00000010, 0x40080010,
        0x00084000, 0x00080010, 0x40004010, 0x00000000,
        0x40000000, 0x00004000, 0x00084010, 0x40080000,
        0x00080010, 0x40000010, 0x00000000, 0x00084000,
        0x00004010, 0x40084000, 0x40080000, 0x00004010,
        0x00000000, 0x00084010, 0x40080010, 0x00080000,
        0x40004010, 0x40080000, 0x40084000, 0x00004000,
        0x40080000, 0x40004000, 0x00000010, 0x40084010,
        0x00084010, 0x00000010, 0x00004000, 0x40000000,
        0x00004010, 0x40084000, 0x00080000, 0x40000010,
        0x00080010, 0x40004010, 0x40000010, 0x00080010,
        0x00084000, 0x00000000, 0x40004000, 0x00004010,
        0x40000000, 0x40080010, 0x40084010, 0x00084000
    );

    /**
     * Pre-permuted S-box3
     *
     * @var Array
     * @access private
     */
    var $sbox3 = array(
        0x00000104, 0x04010100, 0x00000000, 0x04010004,
        0x04000100, 0x00000000, 0x00010104, 0x04000100,
        0x00010004, 0x04000004, 0x04000004, 0x00010000,
        0x04010104, 0x00010004, 0x04010000, 0x00000104,
        0x04000000, 0x00000004, 0x04010100, 0x00000100,
        0x00010100, 0x04010000, 0x04010004, 0x00010104,
        0x04000104, 0x00010100, 0x00010000, 0x04000104,
        0x00000004, 0x04010104, 0x00000100, 0x04000000,
        0x04010100, 0x04000000, 0x00010004, 0x00000104,
        0x00010000, 0x04010100, 0x04000100, 0x00000000,
        0x00000100, 0x00010004, 0x04010104, 0x04000100,
        0x04000004, 0x00000100, 0x00000000, 0x04010004,
        0x04000104, 0x00010000, 0x04000000, 0x04010104,
        0x00000004, 0x00010104, 0x00010100, 0x04000004,
        0x04010000, 0x04000104, 0x00000104, 0x04010000,
        0x00010104, 0x00000004, 0x04010004, 0x00010100
    );

    /**
     * Pre-permuted S-box4
     *
     * @var Array
     * @access private
     */
    var $sbox4 = array(
        0x80401000, 0x80001040, 0x80001040, 0x00000040,
        0x00401040, 0x80400040, 0x80400000, 0x80001000,
        0x00000000, 0x00401000, 0x00401000, 0x80401040,
        0x80000040, 0x00000000, 0x00400040, 0x80400000,
        0x80000000, 0x00001000, 0x00400000, 0x80401000,
        0x00000040, 0x00400000, 0x80001000, 0x00001040,
        0x80400040, 0x80000000, 0x00001040, 0x00400040,
        0x00001000, 0x00401040, 0x80401040, 0x80000040,
        0x00400040, 0x80400000, 0x00401000, 0x80401040,
        0x80000040, 0x00000000, 0x00000000, 0x00401000,
        0x00001040, 0x00400040, 0x80400040, 0x80000000,
        0x80401000, 0x80001040, 0x80001040, 0x00000040,
        0x80401040, 0x80000040, 0x80000000, 0x00001000,
        0x80400000, 0x80001000, 0x00401040, 0x80400040,
        0x80001000, 0x00001040, 0x00400000, 0x80401000,
        0x00000040, 0x00400000, 0x00001000, 0x00401040
    );

    /**
     * Pre-permuted S-box5
     *
     * @var Array
     * @access private
     */
    var $sbox5 = array(
        0x00000080, 0x01040080, 0x01040000, 0x21000080,
        0x00040000, 0x00000080, 0x20000000, 0x01040000,
        0x20040080, 0x00040000, 0x01000080, 0x20040080,
        0x21000080, 0x21040000, 0x00040080, 0x20000000,
        0x01000000, 0x20040000, 0x20040000, 0x00000000,
        0x20000080, 0x21040080, 0x21040080, 0x01000080,
        0x21040000, 0x20000080, 0x00000000, 0x21000000,
        0x01040080, 0x01000000, 0x21000000, 0x00040080,
        0x00040000, 0x21000080, 0x00000080, 0x01000000,
        0x20000000, 0x01040000, 0x21000080, 0x20040080,
        0x01000080, 0x20000000, 0x21040000, 0x01040080,
        0x20040080, 0x00000080, 0x01000000, 0x21040000,
        0x21040080, 0x00040080, 0x21000000, 0x21040080,
        0x01040000, 0x00000000, 0x20040000, 0x21000000,
        0x00040080, 0x01000080, 0x20000080, 0x00040000,
        0x00000000, 0x20040000, 0x01040080, 0x20000080
    );

    /**
     * Pre-permuted S-box6
     *
     * @var Array
     * @access private
     */
    var $sbox6 = array(
        0x10000008, 0x10200000, 0x00002000, 0x10202008,
        0x10200000, 0x00000008, 0x10202008, 0x00200000,
        0x10002000, 0x00202008, 0x00200000, 0x10000008,
        0x00200008, 0x10002000, 0x10000000, 0x00002008,
        0x00000000, 0x00200008, 0x10002008, 0x00002000,
        0x00202000, 0x10002008, 0x00000008, 0x10200008,
        0x10200008, 0x00000000, 0x00202008, 0x10202000,
        0x00002008, 0x00202000, 0x10202000, 0x10000000,
        0x10002000, 0x00000008, 0x10200008, 0x00202000,
        0x10202008, 0x00200000, 0x00002008, 0x10000008,
        0x00200000, 0x10002000, 0x10000000, 0x00002008,
        0x10000008, 0x10202008, 0x00202000, 0x10200000,
        0x00202008, 0x10202000, 0x00000000, 0x10200008,
        0x00000008, 0x00002000, 0x10200000, 0x00202008,
        0x00002000, 0x00200008, 0x10002008, 0x00000000,
        0x10202000, 0x10000000, 0x00200008, 0x10002008
    );

    /**
     * Pre-permuted S-box7
     *
     * @var Array
     * @access private
     */
    var $sbox7 = array(
        0x00100000, 0x02100001, 0x02000401, 0x00000000,
        0x00000400, 0x02000401, 0x00100401, 0x02100400,
        0x02100401, 0x00100000, 0x00000000, 0x02000001,
        0x00000001, 0x02000000, 0x02100001, 0x00000401,
        0x02000400, 0x00100401, 0x00100001, 0x02000400,
        0x02000001, 0x02100000, 0x02100400, 0x00100001,
        0x02100000, 0x00000400, 0x00000401, 0x02100401,
        0x00100400, 0x00000001, 0x02000000, 0x00100400,
        0x02000000, 0x00100400, 0x00100000, 0x02000401,
        0x02000401, 0x02100001, 0x02100001, 0x00000001,
        0x00100001, 0x02000000, 0x02000400, 0x00100000,
        0x02100400, 0x00000401, 0x00100401, 0x02100400,
        0x00000401, 0x02000001, 0x02100401, 0x02100000,
        0x00100400, 0x00000000, 0x00000001, 0x02100401,
        0x00000000, 0x00100401, 0x02100000, 0x00000400,
        0x02000001, 0x02000400, 0x00000400, 0x00100001
    );

    /**
     * Pre-permuted S-box8
     *
     * @var Array
     * @access private
     */
    var $sbox8 = array(
        0x08000820, 0x00000800, 0x00020000, 0x08020820,
        0x08000000, 0x08000820, 0x00000020, 0x08000000,
        0x00020020, 0x08020000, 0x08020820, 0x00020800,
        0x08020800, 0x00020820, 0x00000800, 0x00000020,
        0x08020000, 0x08000020, 0x08000800, 0x00000820,
        0x00020800, 0x00020020, 0x08020020, 0x08020800,
        0x00000820, 0x00000000, 0x00000000, 0x08020020,
        0x08000020, 0x08000800, 0x00020820, 0x00020000,
        0x00020820, 0x00020000, 0x08020800, 0x00000800,
        0x00000020, 0x08020020, 0x00000800, 0x00020820,
        0x08000800, 0x00000020, 0x08000020, 0x08020000,
        0x08020020, 0x08000000, 0x00020000, 0x08000820,
        0x00000000, 0x08020820, 0x00020020, 0x08000020,
        0x08020000, 0x08000800, 0x08000820, 0x00000000,
        0x08020820, 0x00020800, 0x00020800, 0x00000820,
        0x00000820, 0x00020020, 0x08000000, 0x08020800
    );

    /**
     * Sets the key.
     *
     * Keys can be of any length.  DES, itself, uses 64-bit keys (eg. strlen($key) == 8), however, we
     * only use the first eight, if $key has more then eight characters in it, and pad $key with the
     * null byte if it is less then eight characters long.
     *
     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
     *
     * If the key is not explicitly set, it'll be assumed to be all zero's.
     *
     * @see Crypt_Base::setKey()
     * @access public
     * @param String $key
     */
    function setKey($key)
    {
        // We check/cut here only up to max length of the key.
        // Key padding to the proper length will be done in _setupKey()
        if (strlen($key) > $this->key_size_max) {
            $key = substr($key, 0, $this->key_size_max);
        }

        // Sets the key
        parent::setKey($key);
    }

    /**
     * Encrypts a block
     *
     * @see Crypt_Base::_encryptBlock()
     * @see Crypt_Base::encrypt()
     * @see Crypt_DES::encrypt()
     * @access private
     * @param String $in
     * @return String
     */
    function _encryptBlock($in)
    {
        return $this->_processBlock($in, CRYPT_DES_ENCRYPT);
    }

    /**
     * Decrypts a block
     *
     * @see Crypt_Base::_decryptBlock()
     * @see Crypt_Base::decrypt()
     * @see Crypt_DES::decrypt()
     * @access private
     * @param String $in
     * @return String
     */
    function _decryptBlock($in)
    {
        return $this->_processBlock($in, CRYPT_DES_DECRYPT);
    }

    /**
     * Encrypts or decrypts a 64-bit block
     *
     * $mode should be either CRYPT_DES_ENCRYPT or CRYPT_DES_DECRYPT.  See
     * {@link http://en.wikipedia.org/wiki/Image:Feistel.png Feistel.png} to get a general
     * idea of what this function does.
     *
     * @see Crypt_DES::_encryptBlock()
     * @see Crypt_DES::_decryptBlock()
     * @access private
     * @param String $block
     * @param Integer $mode
     * @return String
     */
    function _processBlock($block, $mode)
    {
        static $sbox1, $sbox2, $sbox3, $sbox4, $sbox5, $sbox6, $sbox7, $sbox8, $shuffleip, $shuffleinvip;
        if (!$sbox1) {
            $sbox1 = array_map("intval", $this->sbox1);
            $sbox2 = array_map("intval", $this->sbox2);
            $sbox3 = array_map("intval", $this->sbox3);
            $sbox4 = array_map("intval", $this->sbox4);
            $sbox5 = array_map("intval", $this->sbox5);
            $sbox6 = array_map("intval", $this->sbox6);
            $sbox7 = array_map("intval", $this->sbox7);
            $sbox8 = array_map("intval", $this->sbox8);
            /* Merge $shuffle with $[inv]ipmap */
            for ($i = 0; $i < 256; ++$i) {
                $shuffleip[]    =  $this->shuffle[$this->ipmap[$i]];
                $shuffleinvip[] =  $this->shuffle[$this->invipmap[$i]];
            }
        }

        $keys  = $this->keys[$mode];
        $ki    = -1;

        // Do the initial IP permutation.
        $t = unpack('Nl/Nr', $block);
        list($l, $r) = array($t['l'], $t['r']);
        $block = ($shuffleip[ $r        & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
                 ($shuffleip[($r >>  8) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
                 ($shuffleip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
                 ($shuffleip[($r >> 24) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
                 ($shuffleip[ $l        & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
                 ($shuffleip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
                 ($shuffleip[($l >> 16) & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
                 ($shuffleip[($l >> 24) & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");

        // Extract L0 and R0.
        $t = unpack('Nl/Nr', $block);
        list($l, $r) = array($t['l'], $t['r']);

        for ($des_round = 0; $des_round < $this->des_rounds; ++$des_round) {
            // Perform the 16 steps.
            for ($i = 0; $i < 16; $i++) {
                // start of "the Feistel (F) function" - see the following URL:
                // http://en.wikipedia.org/wiki/Image:Data_Encryption_Standard_InfoBox_Diagram.png
                // Merge key schedule.
                $b1 = (($r >>  3) & 0x1FFFFFFF) ^ ($r << 29) ^ $keys[++$ki];
                $b2 = (($r >> 31) & 0x00000001) ^ ($r <<  1) ^ $keys[++$ki];

                // S-box indexing.
                $t = $sbox1[($b1 >> 24) & 0x3F] ^ $sbox2[($b2 >> 24) & 0x3F] ^
                     $sbox3[($b1 >> 16) & 0x3F] ^ $sbox4[($b2 >> 16) & 0x3F] ^
                     $sbox5[($b1 >>  8) & 0x3F] ^ $sbox6[($b2 >>  8) & 0x3F] ^
                     $sbox7[ $b1        & 0x3F] ^ $sbox8[ $b2        & 0x3F] ^ $l;
                // end of "the Feistel (F) function"

                $l = $r;
                $r = $t;
            }

            // Last step should not permute L & R.
            $t = $l;
            $l = $r;
            $r = $t;
        }

        // Perform the inverse IP permutation.
        return ($shuffleinvip[($r >> 24) & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
               ($shuffleinvip[($l >> 24) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
               ($shuffleinvip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
               ($shuffleinvip[($l >> 16) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
               ($shuffleinvip[($r >>  8) & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
               ($shuffleinvip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
               ($shuffleinvip[ $r        & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
               ($shuffleinvip[ $l        & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");
    }

    /**
     * Creates the key schedule
     *
     * @see Crypt_Base::_setupKey()
     * @access private
     */
    function _setupKey()
    {
        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->des_rounds === $this->kl['des_rounds']) {
            // already expanded
            return;
        }
        $this->kl = array('key' => $this->key, 'des_rounds' => $this->des_rounds);

        static $shifts = array( // number of key bits shifted per round
            1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
        );

        static $pc1map = array(
            0x00, 0x00, 0x08, 0x08, 0x04, 0x04, 0x0C, 0x0C,
            0x02, 0x02, 0x0A, 0x0A, 0x06, 0x06, 0x0E, 0x0E,
            0x10, 0x10, 0x18, 0x18, 0x14, 0x14, 0x1C, 0x1C,
            0x12, 0x12, 0x1A, 0x1A, 0x16, 0x16, 0x1E, 0x1E,
            0x20, 0x20, 0x28, 0x28, 0x24, 0x24, 0x2C, 0x2C,
            0x22, 0x22, 0x2A, 0x2A, 0x26, 0x26, 0x2E, 0x2E,
            0x30, 0x30, 0x38, 0x38, 0x34, 0x34, 0x3C, 0x3C,
            0x32, 0x32, 0x3A, 0x3A, 0x36, 0x36, 0x3E, 0x3E,
            0x40, 0x40, 0x48, 0x48, 0x44, 0x44, 0x4C, 0x4C,
            0x42, 0x42, 0x4A, 0x4A, 0x46, 0x46, 0x4E, 0x4E,
            0x50, 0x50, 0x58, 0x58, 0x54, 0x54, 0x5C, 0x5C,
            0x52, 0x52, 0x5A, 0x5A, 0x56, 0x56, 0x5E, 0x5E,
            0x60, 0x60, 0x68, 0x68, 0x64, 0x64, 0x6C, 0x6C,
            0x62, 0x62, 0x6A, 0x6A, 0x66, 0x66, 0x6E, 0x6E,
            0x70, 0x70, 0x78, 0x78, 0x74, 0x74, 0x7C, 0x7C,
            0x72, 0x72, 0x7A, 0x7A, 0x76, 0x76, 0x7E, 0x7E,
            0x80, 0x80, 0x88, 0x88, 0x84, 0x84, 0x8C, 0x8C,
            0x82, 0x82, 0x8A, 0x8A, 0x86, 0x86, 0x8E, 0x8E,
            0x90, 0x90, 0x98, 0x98, 0x94, 0x94, 0x9C, 0x9C,
            0x92, 0x92, 0x9A, 0x9A, 0x96, 0x96, 0x9E, 0x9E,
            0xA0, 0xA0, 0xA8, 0xA8, 0xA4, 0xA4, 0xAC, 0xAC,
            0xA2, 0xA2, 0xAA, 0xAA, 0xA6, 0xA6, 0xAE, 0xAE,
            0xB0, 0xB0, 0xB8, 0xB8, 0xB4, 0xB4, 0xBC, 0xBC,
            0xB2, 0xB2, 0xBA, 0xBA, 0xB6, 0xB6, 0xBE, 0xBE,
            0xC0, 0xC0, 0xC8, 0xC8, 0xC4, 0xC4, 0xCC, 0xCC,
            0xC2, 0xC2, 0xCA, 0xCA, 0xC6, 0xC6, 0xCE, 0xCE,
            0xD0, 0xD0, 0xD8, 0xD8, 0xD4, 0xD4, 0xDC, 0xDC,
            0xD2, 0xD2, 0xDA, 0xDA, 0xD6, 0xD6, 0xDE, 0xDE,
            0xE0, 0xE0, 0xE8, 0xE8, 0xE4, 0xE4, 0xEC, 0xEC,
            0xE2, 0xE2, 0xEA, 0xEA, 0xE6, 0xE6, 0xEE, 0xEE,
            0xF0, 0xF0, 0xF8, 0xF8, 0xF4, 0xF4, 0xFC, 0xFC,
            0xF2, 0xF2, 0xFA, 0xFA, 0xF6, 0xF6, 0xFE, 0xFE
        );

        // Mapping tables for the PC-2 transformation.
        static $pc2mapc1 = array(
            0x00000000, 0x00000400, 0x00200000, 0x00200400,
            0x00000001, 0x00000401, 0x00200001, 0x00200401,
            0x02000000, 0x02000400, 0x02200000, 0x02200400,
            0x02000001, 0x02000401, 0x02200001, 0x02200401
        );
        static $pc2mapc2 = array(
            0x00000000, 0x00000800, 0x08000000, 0x08000800,
            0x00010000, 0x00010800, 0x08010000, 0x08010800,
            0x00000000, 0x00000800, 0x08000000, 0x08000800,
            0x00010000, 0x00010800, 0x08010000, 0x08010800,
            0x00000100, 0x00000900, 0x08000100, 0x08000900,
            0x00010100, 0x00010900, 0x08010100, 0x08010900,
            0x00000100, 0x00000900, 0x08000100, 0x08000900,
            0x00010100, 0x00010900, 0x08010100, 0x08010900,
            0x00000010, 0x00000810, 0x08000010, 0x08000810,
            0x00010010, 0x00010810, 0x08010010, 0x08010810,
            0x00000010, 0x00000810, 0x08000010, 0x08000810,
            0x00010010, 0x00010810, 0x08010010, 0x08010810,
            0x00000110, 0x00000910, 0x08000110, 0x08000910,
            0x00010110, 0x00010910, 0x08010110, 0x08010910,
            0x00000110, 0x00000910, 0x08000110, 0x08000910,
            0x00010110, 0x00010910, 0x08010110, 0x08010910,
            0x00040000, 0x00040800, 0x08040000, 0x08040800,
            0x00050000, 0x00050800, 0x08050000, 0x08050800,
            0x00040000, 0x00040800, 0x08040000, 0x08040800,
            0x00050000, 0x00050800, 0x08050000, 0x08050800,
            0x00040100, 0x00040900, 0x08040100, 0x08040900,
            0x00050100, 0x00050900, 0x08050100, 0x08050900,
            0x00040100, 0x00040900, 0x08040100, 0x08040900,
            0x00050100, 0x00050900, 0x08050100, 0x08050900,
            0x00040010, 0x00040810, 0x08040010, 0x08040810,
            0x00050010, 0x00050810, 0x08050010, 0x08050810,
            0x00040010, 0x00040810, 0x08040010, 0x08040810,
            0x00050010, 0x00050810, 0x08050010, 0x08050810,
            0x00040110, 0x00040910, 0x08040110, 0x08040910,
            0x00050110, 0x00050910, 0x08050110, 0x08050910,
            0x00040110, 0x00040910, 0x08040110, 0x08040910,
            0x00050110, 0x00050910, 0x08050110, 0x08050910,
            0x01000000, 0x01000800, 0x09000000, 0x09000800,
            0x01010000, 0x01010800, 0x09010000, 0x09010800,
            0x01000000, 0x01000800, 0x09000000, 0x09000800,
            0x01010000, 0x01010800, 0x09010000, 0x09010800,
            0x01000100, 0x01000900, 0x09000100, 0x09000900,
            0x01010100, 0x01010900, 0x09010100, 0x09010900,
            0x01000100, 0x01000900, 0x09000100, 0x09000900,
            0x01010100, 0x01010900, 0x09010100, 0x09010900,
            0x01000010, 0x01000810, 0x09000010, 0x09000810,
            0x01010010, 0x01010810, 0x09010010, 0x09010810,
            0x01000010, 0x01000810, 0x09000010, 0x09000810,
            0x01010010, 0x01010810, 0x09010010, 0x09010810,
            0x01000110, 0x01000910, 0x09000110, 0x09000910,
            0x01010110, 0x01010910, 0x09010110, 0x09010910,
            0x01000110, 0x01000910, 0x09000110, 0x09000910,
            0x01010110, 0x01010910, 0x09010110, 0x09010910,
            0x01040000, 0x01040800, 0x09040000, 0x09040800,
            0x01050000, 0x01050800, 0x09050000, 0x09050800,
            0x01040000, 0x01040800, 0x09040000, 0x09040800,
            0x01050000, 0x01050800, 0x09050000, 0x09050800,
            0x01040100, 0x01040900, 0x09040100, 0x09040900,
            0x01050100, 0x01050900, 0x09050100, 0x09050900,
            0x01040100, 0x01040900, 0x09040100, 0x09040900,
            0x01050100, 0x01050900, 0x09050100, 0x09050900,
            0x01040010, 0x01040810, 0x09040010, 0x09040810,
            0x01050010, 0x01050810, 0x09050010, 0x09050810,
            0x01040010, 0x01040810, 0x09040010, 0x09040810,
            0x01050010, 0x01050810, 0x09050010, 0x09050810,
            0x01040110, 0x01040910, 0x09040110, 0x09040910,
            0x01050110, 0x01050910, 0x09050110, 0x09050910,
            0x01040110, 0x01040910, 0x09040110, 0x09040910,
            0x01050110, 0x01050910, 0x09050110, 0x09050910
        );
        static $pc2mapc3 = array(
            0x00000000, 0x00000004, 0x00001000, 0x00001004,
            0x00000000, 0x00000004, 0x00001000, 0x00001004,
            0x10000000, 0x10000004, 0x10001000, 0x10001004,
            0x10000000, 0x10000004, 0x10001000, 0x10001004,
            0x00000020, 0x00000024, 0x00001020, 0x00001024,
            0x00000020, 0x00000024, 0x00001020, 0x00001024,
            0x10000020, 0x10000024, 0x10001020, 0x10001024,
            0x10000020, 0x10000024, 0x10001020, 0x10001024,
            0x00080000, 0x00080004, 0x00081000, 0x00081004,
            0x00080000, 0x00080004, 0x00081000, 0x00081004,
            0x10080000, 0x10080004, 0x10081000, 0x10081004,
            0x10080000, 0x10080004, 0x10081000, 0x10081004,
            0x00080020, 0x00080024, 0x00081020, 0x00081024,
            0x00080020, 0x00080024, 0x00081020, 0x00081024,
            0x10080020, 0x10080024, 0x10081020, 0x10081024,
            0x10080020, 0x10080024, 0x10081020, 0x10081024,
            0x20000000, 0x20000004, 0x20001000, 0x20001004,
            0x20000000, 0x20000004, 0x20001000, 0x20001004,
            0x30000000, 0x30000004, 0x30001000, 0x30001004,
            0x30000000, 0x30000004, 0x30001000, 0x30001004,
            0x20000020, 0x20000024, 0x20001020, 0x20001024,
            0x20000020, 0x20000024, 0x20001020, 0x20001024,
            0x30000020, 0x30000024, 0x30001020, 0x30001024,
            0x30000020, 0x30000024, 0x30001020, 0x30001024,
            0x20080000, 0x20080004, 0x20081000, 0x20081004,
            0x20080000, 0x20080004, 0x20081000, 0x20081004,
            0x30080000, 0x30080004, 0x30081000, 0x30081004,
            0x30080000, 0x30080004, 0x30081000, 0x30081004,
            0x20080020, 0x20080024, 0x20081020, 0x20081024,
            0x20080020, 0x20080024, 0x20081020, 0x20081024,
            0x30080020, 0x30080024, 0x30081020, 0x30081024,
            0x30080020, 0x30080024, 0x30081020, 0x30081024,
            0x00000002, 0x00000006, 0x00001002, 0x00001006,
            0x00000002, 0x00000006, 0x00001002, 0x00001006,
            0x10000002, 0x10000006, 0x10001002, 0x10001006,
            0x10000002, 0x10000006, 0x10001002, 0x10001006,
            0x00000022, 0x00000026, 0x00001022, 0x00001026,
            0x00000022, 0x00000026, 0x00001022, 0x00001026,
            0x10000022, 0x10000026, 0x10001022, 0x10001026,
            0x10000022, 0x10000026, 0x10001022, 0x10001026,
            0x00080002, 0x00080006, 0x00081002, 0x00081006,
            0x00080002, 0x00080006, 0x00081002, 0x00081006,
            0x10080002, 0x10080006, 0x10081002, 0x10081006,
            0x10080002, 0x10080006, 0x10081002, 0x10081006,
            0x00080022, 0x00080026, 0x00081022, 0x00081026,
            0x00080022, 0x00080026, 0x00081022, 0x00081026,
            0x10080022, 0x10080026, 0x10081022, 0x10081026,
            0x10080022, 0x10080026, 0x10081022, 0x10081026,
            0x20000002, 0x20000006, 0x20001002, 0x20001006,
            0x20000002, 0x20000006, 0x20001002, 0x20001006,
            0x30000002, 0x30000006, 0x30001002, 0x30001006,
            0x30000002, 0x30000006, 0x30001002, 0x30001006,
            0x20000022, 0x20000026, 0x20001022, 0x20001026,
            0x20000022, 0x20000026, 0x20001022, 0x20001026,
            0x30000022, 0x30000026, 0x30001022, 0x30001026,
            0x30000022, 0x30000026, 0x30001022, 0x30001026,
            0x20080002, 0x20080006, 0x20081002, 0x20081006,
            0x20080002, 0x20080006, 0x20081002, 0x20081006,
            0x30080002, 0x30080006, 0x30081002, 0x30081006,
            0x30080002, 0x30080006, 0x30081002, 0x30081006,
            0x20080022, 0x20080026, 0x20081022, 0x20081026,
            0x20080022, 0x20080026, 0x20081022, 0x20081026,
            0x30080022, 0x30080026, 0x30081022, 0x30081026,
            0x30080022, 0x30080026, 0x30081022, 0x30081026
        );
        static $pc2mapc4 = array(
            0x00000000, 0x00100000, 0x00000008, 0x00100008,
            0x00000200, 0x00100200, 0x00000208, 0x00100208,
            0x00000000, 0x00100000, 0x00000008, 0x00100008,
            0x00000200, 0x00100200, 0x00000208, 0x00100208,
            0x04000000, 0x04100000, 0x04000008, 0x04100008,
            0x04000200, 0x04100200, 0x04000208, 0x04100208,
            0x04000000, 0x04100000, 0x04000008, 0x04100008,
            0x04000200, 0x04100200, 0x04000208, 0x04100208,
            0x00002000, 0x00102000, 0x00002008, 0x00102008,
            0x00002200, 0x00102200, 0x00002208, 0x00102208,
            0x00002000, 0x00102000, 0x00002008, 0x00102008,
            0x00002200, 0x00102200, 0x00002208, 0x00102208,
            0x04002000, 0x04102000, 0x04002008, 0x04102008,
            0x04002200, 0x04102200, 0x04002208, 0x04102208,
            0x04002000, 0x04102000, 0x04002008, 0x04102008,
            0x04002200, 0x04102200, 0x04002208, 0x04102208,
            0x00000000, 0x00100000, 0x00000008, 0x00100008,
            0x00000200, 0x00100200, 0x00000208, 0x00100208,
            0x00000000, 0x00100000, 0x00000008, 0x00100008,
            0x00000200, 0x00100200, 0x00000208, 0x00100208,
            0x04000000, 0x04100000, 0x04000008, 0x04100008,
            0x04000200, 0x04100200, 0x04000208, 0x04100208,
            0x04000000, 0x04100000, 0x04000008, 0x04100008,
            0x04000200, 0x04100200, 0x04000208, 0x04100208,
            0x00002000, 0x00102000, 0x00002008, 0x00102008,
            0x00002200, 0x00102200, 0x00002208, 0x00102208,
            0x00002000, 0x00102000, 0x00002008, 0x00102008,
            0x00002200, 0x00102200, 0x00002208, 0x00102208,
            0x04002000, 0x04102000, 0x04002008, 0x04102008,
            0x04002200, 0x04102200, 0x04002208, 0x04102208,
            0x04002000, 0x04102000, 0x04002008, 0x04102008,
            0x04002200, 0x04102200, 0x04002208, 0x04102208,
            0x00020000, 0x00120000, 0x00020008, 0x00120008,
            0x00020200, 0x00120200, 0x00020208, 0x00120208,
            0x00020000, 0x00120000, 0x00020008, 0x00120008,
            0x00020200, 0x00120200, 0x00020208, 0x00120208,
            0x04020000, 0x04120000, 0x04020008, 0x04120008,
            0x04020200, 0x04120200, 0x04020208, 0x04120208,
            0x04020000, 0x04120000, 0x04020008, 0x04120008,
            0x04020200, 0x04120200, 0x04020208, 0x04120208,
            0x00022000, 0x00122000, 0x00022008, 0x00122008,
            0x00022200, 0x00122200, 0x00022208, 0x00122208,
            0x00022000, 0x00122000, 0x00022008, 0x00122008,
            0x00022200, 0x00122200, 0x00022208, 0x00122208,
            0x04022000, 0x04122000, 0x04022008, 0x04122008,
            0x04022200, 0x04122200, 0x04022208, 0x04122208,
            0x04022000, 0x04122000, 0x04022008, 0x04122008,
            0x04022200, 0x04122200, 0x04022208, 0x04122208,
            0x00020000, 0x00120000, 0x00020008, 0x00120008,
            0x00020200, 0x00120200, 0x00020208, 0x00120208,
            0x00020000, 0x00120000, 0x00020008, 0x00120008,
            0x00020200, 0x00120200, 0x00020208, 0x00120208,
            0x04020000, 0x04120000, 0x04020008, 0x04120008,
            0x04020200, 0x04120200, 0x04020208, 0x04120208,
            0x04020000, 0x04120000, 0x04020008, 0x04120008,
            0x04020200, 0x04120200, 0x04020208, 0x04120208,
            0x00022000, 0x00122000, 0x00022008, 0x00122008,
            0x00022200, 0x00122200, 0x00022208, 0x00122208,
            0x00022000, 0x00122000, 0x00022008, 0x00122008,
            0x00022200, 0x00122200, 0x00022208, 0x00122208,
            0x04022000, 0x04122000, 0x04022008, 0x04122008,
            0x04022200, 0x04122200, 0x04022208, 0x04122208,
            0x04022000, 0x04122000, 0x04022008, 0x04122008,
            0x04022200, 0x04122200, 0x04022208, 0x04122208
        );
        static $pc2mapd1 = array(
            0x00000000, 0x00000001, 0x08000000, 0x08000001,
            0x00200000, 0x00200001, 0x08200000, 0x08200001,
            0x00000002, 0x00000003, 0x08000002, 0x08000003,
            0x00200002, 0x00200003, 0x08200002, 0x08200003
        );
        static $pc2mapd2 = array(
            0x00000000, 0x00100000, 0x00000800, 0x00100800,
            0x00000000, 0x00100000, 0x00000800, 0x00100800,
            0x04000000, 0x04100000, 0x04000800, 0x04100800,
            0x04000000, 0x04100000, 0x04000800, 0x04100800,
            0x00000004, 0x00100004, 0x00000804, 0x00100804,
            0x00000004, 0x00100004, 0x00000804, 0x00100804,
            0x04000004, 0x04100004, 0x04000804, 0x04100804,
            0x04000004, 0x04100004, 0x04000804, 0x04100804,
            0x00000000, 0x00100000, 0x00000800, 0x00100800,
            0x00000000, 0x00100000, 0x00000800, 0x00100800,
            0x04000000, 0x04100000, 0x04000800, 0x04100800,
            0x04000000, 0x04100000, 0x04000800, 0x04100800,
            0x00000004, 0x00100004, 0x00000804, 0x00100804,
            0x00000004, 0x00100004, 0x00000804, 0x00100804,
            0x04000004, 0x04100004, 0x04000804, 0x04100804,
            0x04000004, 0x04100004, 0x04000804, 0x04100804,
            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
            0x00020000, 0x00120000, 0x00020800, 0x00120800,
            0x00020000, 0x00120000, 0x00020800, 0x00120800,
            0x04020000, 0x04120000, 0x04020800, 0x04120800,
            0x04020000, 0x04120000, 0x04020800, 0x04120800,
            0x00020004, 0x00120004, 0x00020804, 0x00120804,
            0x00020004, 0x00120004, 0x00020804, 0x00120804,
            0x04020004, 0x04120004, 0x04020804, 0x04120804,
            0x04020004, 0x04120004, 0x04020804, 0x04120804,
            0x00020000, 0x00120000, 0x00020800, 0x00120800,
            0x00020000, 0x00120000, 0x00020800, 0x00120800,
            0x04020000, 0x04120000, 0x04020800, 0x04120800,
            0x04020000, 0x04120000, 0x04020800, 0x04120800,
            0x00020004, 0x00120004, 0x00020804, 0x00120804,
            0x00020004, 0x00120004, 0x00020804, 0x00120804,
            0x04020004, 0x04120004, 0x04020804, 0x04120804,
            0x04020004, 0x04120004, 0x04020804, 0x04120804,
            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
            0x04020204, 0x04120204, 0x04020A04, 0x04120A04
        );
        static $pc2mapd3 = array(
            0x00000000, 0x00010000, 0x02000000, 0x02010000,
            0x00000020, 0x00010020, 0x02000020, 0x02010020,
            0x00040000, 0x00050000, 0x02040000, 0x02050000,
            0x00040020, 0x00050020, 0x02040020, 0x02050020,
            0x00002000, 0x00012000, 0x02002000, 0x02012000,
            0x00002020, 0x00012020, 0x02002020, 0x02012020,
            0x00042000, 0x00052000, 0x02042000, 0x02052000,
            0x00042020, 0x00052020, 0x02042020, 0x02052020,
            0x00000000, 0x00010000, 0x02000000, 0x02010000,
            0x00000020, 0x00010020, 0x02000020, 0x02010020,
            0x00040000, 0x00050000, 0x02040000, 0x02050000,
            0x00040020, 0x00050020, 0x02040020, 0x02050020,
            0x00002000, 0x00012000, 0x02002000, 0x02012000,
            0x00002020, 0x00012020, 0x02002020, 0x02012020,
            0x00042000, 0x00052000, 0x02042000, 0x02052000,
            0x00042020, 0x00052020, 0x02042020, 0x02052020,
            0x00000010, 0x00010010, 0x02000010, 0x02010010,
            0x00000030, 0x00010030, 0x02000030, 0x02010030,
            0x00040010, 0x00050010, 0x02040010, 0x02050010,
            0x00040030, 0x00050030, 0x02040030, 0x02050030,
            0x00002010, 0x00012010, 0x02002010, 0x02012010,
            0x00002030, 0x00012030, 0x02002030, 0x02012030,
            0x00042010, 0x00052010, 0x02042010, 0x02052010,
            0x00042030, 0x00052030, 0x02042030, 0x02052030,
            0x00000010, 0x00010010, 0x02000010, 0x02010010,
            0x00000030, 0x00010030, 0x02000030, 0x02010030,
            0x00040010, 0x00050010, 0x02040010, 0x02050010,
            0x00040030, 0x00050030, 0x02040030, 0x02050030,
            0x00002010, 0x00012010, 0x02002010, 0x02012010,
            0x00002030, 0x00012030, 0x02002030, 0x02012030,
            0x00042010, 0x00052010, 0x02042010, 0x02052010,
            0x00042030, 0x00052030, 0x02042030, 0x02052030,
            0x20000000, 0x20010000, 0x22000000, 0x22010000,
            0x20000020, 0x20010020, 0x22000020, 0x22010020,
            0x20040000, 0x20050000, 0x22040000, 0x22050000,
            0x20040020, 0x20050020, 0x22040020, 0x22050020,
            0x20002000, 0x20012000, 0x22002000, 0x22012000,
            0x20002020, 0x20012020, 0x22002020, 0x22012020,
            0x20042000, 0x20052000, 0x22042000, 0x22052000,
            0x20042020, 0x20052020, 0x22042020, 0x22052020,
            0x20000000, 0x20010000, 0x22000000, 0x22010000,
            0x20000020, 0x20010020, 0x22000020, 0x22010020,
            0x20040000, 0x20050000, 0x22040000, 0x22050000,
            0x20040020, 0x20050020, 0x22040020, 0x22050020,
            0x20002000, 0x20012000, 0x22002000, 0x22012000,
            0x20002020, 0x20012020, 0x22002020, 0x22012020,
            0x20042000, 0x20052000, 0x22042000, 0x22052000,
            0x20042020, 0x20052020, 0x22042020, 0x22052020,
            0x20000010, 0x20010010, 0x22000010, 0x22010010,
            0x20000030, 0x20010030, 0x22000030, 0x22010030,
            0x20040010, 0x20050010, 0x22040010, 0x22050010,
            0x20040030, 0x20050030, 0x22040030, 0x22050030,
            0x20002010, 0x20012010, 0x22002010, 0x22012010,
            0x20002030, 0x20012030, 0x22002030, 0x22012030,
            0x20042010, 0x20052010, 0x22042010, 0x22052010,
            0x20042030, 0x20052030, 0x22042030, 0x22052030,
            0x20000010, 0x20010010, 0x22000010, 0x22010010,
            0x20000030, 0x20010030, 0x22000030, 0x22010030,
            0x20040010, 0x20050010, 0x22040010, 0x22050010,
            0x20040030, 0x20050030, 0x22040030, 0x22050030,
            0x20002010, 0x20012010, 0x22002010, 0x22012010,
            0x20002030, 0x20012030, 0x22002030, 0x22012030,
            0x20042010, 0x20052010, 0x22042010, 0x22052010,
            0x20042030, 0x20052030, 0x22042030, 0x22052030
        );
        static $pc2mapd4 = array(
            0x00000000, 0x00000400, 0x01000000, 0x01000400,
            0x00000000, 0x00000400, 0x01000000, 0x01000400,
            0x00000100, 0x00000500, 0x01000100, 0x01000500,
            0x00000100, 0x00000500, 0x01000100, 0x01000500,
            0x10000000, 0x10000400, 0x11000000, 0x11000400,
            0x10000000, 0x10000400, 0x11000000, 0x11000400,
            0x10000100, 0x10000500, 0x11000100, 0x11000500,
            0x10000100, 0x10000500, 0x11000100, 0x11000500,
            0x00080000, 0x00080400, 0x01080000, 0x01080400,
            0x00080000, 0x00080400, 0x01080000, 0x01080400,
            0x00080100, 0x00080500, 0x01080100, 0x01080500,
            0x00080100, 0x00080500, 0x01080100, 0x01080500,
            0x10080000, 0x10080400, 0x11080000, 0x11080400,
            0x10080000, 0x10080400, 0x11080000, 0x11080400,
            0x10080100, 0x10080500, 0x11080100, 0x11080500,
            0x10080100, 0x10080500, 0x11080100, 0x11080500,
            0x00000008, 0x00000408, 0x01000008, 0x01000408,
            0x00000008, 0x00000408, 0x01000008, 0x01000408,
            0x00000108, 0x00000508, 0x01000108, 0x01000508,
            0x00000108, 0x00000508, 0x01000108, 0x01000508,
            0x10000008, 0x10000408, 0x11000008, 0x11000408,
            0x10000008, 0x10000408, 0x11000008, 0x11000408,
            0x10000108, 0x10000508, 0x11000108, 0x11000508,
            0x10000108, 0x10000508, 0x11000108, 0x11000508,
            0x00080008, 0x00080408, 0x01080008, 0x01080408,
            0x00080008, 0x00080408, 0x01080008, 0x01080408,
            0x00080108, 0x00080508, 0x01080108, 0x01080508,
            0x00080108, 0x00080508, 0x01080108, 0x01080508,
            0x10080008, 0x10080408, 0x11080008, 0x11080408,
            0x10080008, 0x10080408, 0x11080008, 0x11080408,
            0x10080108, 0x10080508, 0x11080108, 0x11080508,
            0x10080108, 0x10080508, 0x11080108, 0x11080508,
            0x00001000, 0x00001400, 0x01001000, 0x01001400,
            0x00001000, 0x00001400, 0x01001000, 0x01001400,
            0x00001100, 0x00001500, 0x01001100, 0x01001500,
            0x00001100, 0x00001500, 0x01001100, 0x01001500,
            0x10001000, 0x10001400, 0x11001000, 0x11001400,
            0x10001000, 0x10001400, 0x11001000, 0x11001400,
            0x10001100, 0x10001500, 0x11001100, 0x11001500,
            0x10001100, 0x10001500, 0x11001100, 0x11001500,
            0x00081000, 0x00081400, 0x01081000, 0x01081400,
            0x00081000, 0x00081400, 0x01081000, 0x01081400,
            0x00081100, 0x00081500, 0x01081100, 0x01081500,
            0x00081100, 0x00081500, 0x01081100, 0x01081500,
            0x10081000, 0x10081400, 0x11081000, 0x11081400,
            0x10081000, 0x10081400, 0x11081000, 0x11081400,
            0x10081100, 0x10081500, 0x11081100, 0x11081500,
            0x10081100, 0x10081500, 0x11081100, 0x11081500,
            0x00001008, 0x00001408, 0x01001008, 0x01001408,
            0x00001008, 0x00001408, 0x01001008, 0x01001408,
            0x00001108, 0x00001508, 0x01001108, 0x01001508,
            0x00001108, 0x00001508, 0x01001108, 0x01001508,
            0x10001008, 0x10001408, 0x11001008, 0x11001408,
            0x10001008, 0x10001408, 0x11001008, 0x11001408,
            0x10001108, 0x10001508, 0x11001108, 0x11001508,
            0x10001108, 0x10001508, 0x11001108, 0x11001508,
            0x00081008, 0x00081408, 0x01081008, 0x01081408,
            0x00081008, 0x00081408, 0x01081008, 0x01081408,
            0x00081108, 0x00081508, 0x01081108, 0x01081508,
            0x00081108, 0x00081508, 0x01081108, 0x01081508,
            0x10081008, 0x10081408, 0x11081008, 0x11081408,
            0x10081008, 0x10081408, 0x11081008, 0x11081408,
            0x10081108, 0x10081508, 0x11081108, 0x11081508,
            0x10081108, 0x10081508, 0x11081108, 0x11081508
        );

        $keys = array();
        for ($des_round = 0; $des_round < $this->des_rounds; ++$des_round) {
            // pad the key and remove extra characters as appropriate.
            $key = str_pad(substr($this->key, $des_round * 8, 8), 8, "\0");

            // Perform the PC/1 transformation and compute C and D.
            $t = unpack('Nl/Nr', $key);
            list($l, $r) = array($t['l'], $t['r']);
            $key = ($this->shuffle[$pc1map[ $r        & 0xFF]] & "\x80\x80\x80\x80\x80\x80\x80\x00") |
                   ($this->shuffle[$pc1map[($r >>  8) & 0xFF]] & "\x40\x40\x40\x40\x40\x40\x40\x00") |
                   ($this->shuffle[$pc1map[($r >> 16) & 0xFF]] & "\x20\x20\x20\x20\x20\x20\x20\x00") |
                   ($this->shuffle[$pc1map[($r >> 24) & 0xFF]] & "\x10\x10\x10\x10\x10\x10\x10\x00") |
                   ($this->shuffle[$pc1map[ $l        & 0xFF]] & "\x08\x08\x08\x08\x08\x08\x08\x00") |
                   ($this->shuffle[$pc1map[($l >>  8) & 0xFF]] & "\x04\x04\x04\x04\x04\x04\x04\x00") |
                   ($this->shuffle[$pc1map[($l >> 16) & 0xFF]] & "\x02\x02\x02\x02\x02\x02\x02\x00") |
                   ($this->shuffle[$pc1map[($l >> 24) & 0xFF]] & "\x01\x01\x01\x01\x01\x01\x01\x00");
            $key = unpack('Nc/Nd', $key);
            $c = ( $key['c'] >> 4) & 0x0FFFFFFF;
            $d = (($key['d'] >> 4) & 0x0FFFFFF0) | ($key['c'] & 0x0F);

            $keys[$des_round] = array(
                CRYPT_DES_ENCRYPT => array(),
                CRYPT_DES_DECRYPT => array_fill(0, 32, 0)
            );
            for ($i = 0, $ki = 31; $i < 16; ++$i, $ki-= 2) {
                $c <<= $shifts[$i];
                $c = ($c | ($c >> 28)) & 0x0FFFFFFF;
                $d <<= $shifts[$i];
                $d = ($d | ($d >> 28)) & 0x0FFFFFFF;

                // Perform the PC-2 transformation.
                $cp = $pc2mapc1[ $c >> 24        ] | $pc2mapc2[($c >> 16) & 0xFF] |
                      $pc2mapc3[($c >>  8) & 0xFF] | $pc2mapc4[ $c        & 0xFF];
                $dp = $pc2mapd1[ $d >> 24        ] | $pc2mapd2[($d >> 16) & 0xFF] |
                      $pc2mapd3[($d >>  8) & 0xFF] | $pc2mapd4[ $d        & 0xFF];

                // Reorder: odd bytes/even bytes. Push the result in key schedule.
                $val1 = ( $cp        & 0xFF000000) | (($cp <<  8) & 0x00FF0000) |
                        (($dp >> 16) & 0x0000FF00) | (($dp >>  8) & 0x000000FF);
                $val2 = (($cp <<  8) & 0xFF000000) | (($cp << 16) & 0x00FF0000) |
                        (($dp >>  8) & 0x0000FF00) | ( $dp        & 0x000000FF);
                $keys[$des_round][CRYPT_DES_ENCRYPT][       ] = $val1;
                $keys[$des_round][CRYPT_DES_DECRYPT][$ki - 1] = $val1;
                $keys[$des_round][CRYPT_DES_ENCRYPT][       ] = $val2;
                $keys[$des_round][CRYPT_DES_DECRYPT][$ki    ] = $val2;
            }
        }

        switch ($this->des_rounds) {
            case 3: // 3DES keys
                $this->keys = array(
                    CRYPT_DES_ENCRYPT => array_merge(
                        $keys[0][CRYPT_DES_ENCRYPT],
                        $keys[1][CRYPT_DES_DECRYPT],
                        $keys[2][CRYPT_DES_ENCRYPT]
                    ),
                    CRYPT_DES_DECRYPT => array_merge(
                        $keys[2][CRYPT_DES_DECRYPT],
                        $keys[1][CRYPT_DES_ENCRYPT],
                        $keys[0][CRYPT_DES_DECRYPT]
                    )
                );
                break;
            // case 1: // DES keys
            default:
                $this->keys = array(
                    CRYPT_DES_ENCRYPT => $keys[0][CRYPT_DES_ENCRYPT],
                    CRYPT_DES_DECRYPT => $keys[0][CRYPT_DES_DECRYPT]
                );
        }
    }

    /**
     * Setup the performance-optimized function for de/encrypt()
     *
     * @see Crypt_Base::_setupInlineCrypt()
     * @access private
     */
    function _setupInlineCrypt()
    {
        $lambda_functions =& Crypt_DES::_getLambdaFunctions();

        // Engine configuration for:
        // -  DES ($des_rounds == 1) or
        // - 3DES ($des_rounds == 3)
        $des_rounds = $this->des_rounds;

        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.
        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one
        $gen_hi_opt_code = (bool)( count($lambda_functions) < 10 );

        // Generation of a uniqe hash for our generated code
        switch (true) {
            case $gen_hi_opt_code:
                // For hi-optimized code, we create for each combination of
                // $mode, $des_rounds and $this->key its own encrypt/decrypt function.
                $code_hash = md5(str_pad("Crypt_DES, $des_rounds, {$this->mode}, ", 32, "\0") . $this->key);
                break;
            default:
                // After max 10 hi-optimized functions, we create generic
                // (still very fast.. but not ultra) functions for each $mode/$des_rounds
                // Currently 2 * 5 generic functions will be then max. possible.
                $code_hash = "Crypt_DES, $des_rounds, {$this->mode}";
        }

        // Is there a re-usable $lambda_functions in there? If not, we have to create it.
        if (!isset($lambda_functions[$code_hash])) {
            // Init code for both, encrypt and decrypt.
            $init_crypt = 'static $sbox1, $sbox2, $sbox3, $sbox4, $sbox5, $sbox6, $sbox7, $sbox8, $shuffleip, $shuffleinvip;
                if (!$sbox1) {
                    $sbox1 = array_map("intval", $self->sbox1);
                    $sbox2 = array_map("intval", $self->sbox2);
                    $sbox3 = array_map("intval", $self->sbox3);
                    $sbox4 = array_map("intval", $self->sbox4);
                    $sbox5 = array_map("intval", $self->sbox5);
                    $sbox6 = array_map("intval", $self->sbox6);
                    $sbox7 = array_map("intval", $self->sbox7);
                    $sbox8 = array_map("intval", $self->sbox8);'
                    /* Merge $shuffle with $[inv]ipmap */ . '
                    for ($i = 0; $i < 256; ++$i) {
                        $shuffleip[]    =  $self->shuffle[$self->ipmap[$i]];
                        $shuffleinvip[] =  $self->shuffle[$self->invipmap[$i]];
                    }
                }
            ';

            switch (true) {
                case $gen_hi_opt_code:
                    // In Hi-optimized code mode, we use our [3]DES key schedule as hardcoded integers.
                    // No futher initialisation of the $keys schedule is necessary.
                    // That is the extra performance boost.
                    $k = array(
                        CRYPT_DES_ENCRYPT => $this->keys[CRYPT_DES_ENCRYPT],
                        CRYPT_DES_DECRYPT => $this->keys[CRYPT_DES_DECRYPT]
                    );
                    $init_encrypt = '';
                    $init_decrypt = '';
                    break;
                default:
                    // In generic optimized code mode, we have to use, as the best compromise [currently],
                    // our key schedule as $ke/$kd arrays. (with hardcoded indexes...)
                    $k = array(
                        CRYPT_DES_ENCRYPT => array(),
                        CRYPT_DES_DECRYPT => array()
                    );
                    for ($i = 0, $c = count($this->keys[CRYPT_DES_ENCRYPT]); $i < $c; ++$i) {
                        $k[CRYPT_DES_ENCRYPT][$i] = '$ke[' . $i . ']';
                        $k[CRYPT_DES_DECRYPT][$i] = '$kd[' . $i . ']';
                    }
                    $init_encrypt = '$ke = $self->keys[CRYPT_DES_ENCRYPT];';
                    $init_decrypt = '$kd = $self->keys[CRYPT_DES_DECRYPT];';
                    break;
            }

            // Creating code for en- and decryption.
            $crypt_block = array();
            foreach (array(CRYPT_DES_ENCRYPT, CRYPT_DES_DECRYPT) as $c) {

                /* Do the initial IP permutation. */
                $crypt_block[$c] = '
                    $in = unpack("N*", $in);
                    $l  = $in[1];
                    $r  = $in[2];
                    $in = unpack("N*",
                        ($shuffleip[ $r        & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
                        ($shuffleip[($r >>  8) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
                        ($shuffleip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
                        ($shuffleip[($r >> 24) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
                        ($shuffleip[ $l        & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
                        ($shuffleip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
                        ($shuffleip[($l >> 16) & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
                        ($shuffleip[($l >> 24) & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01")
                    );
                    ' . /* Extract L0 and R0 */ '
                    $l = $in[1];
                    $r = $in[2];
                ';

                $l = '$l';
                $r = '$r';

                // Perform DES or 3DES.
                for ($ki = -1, $des_round = 0; $des_round < $des_rounds; ++$des_round) {
                    // Perform the 16 steps.
                    for ($i = 0; $i < 16; ++$i) {
                        // start of "the Feistel (F) function" - see the following URL:
                        // http://en.wikipedia.org/wiki/Image:Data_Encryption_Standard_InfoBox_Diagram.png
                        // Merge key schedule.
                        $crypt_block[$c].= '
                            $b1 = ((' . $r . ' >>  3) & 0x1FFFFFFF)  ^ (' . $r . ' << 29) ^ ' . $k[$c][++$ki] . ';
                            $b2 = ((' . $r . ' >> 31) & 0x00000001)  ^ (' . $r . ' <<  1) ^ ' . $k[$c][++$ki] . ';' .
                            /* S-box indexing. */
                            $l . ' = $sbox1[($b1 >> 24) & 0x3F] ^ $sbox2[($b2 >> 24) & 0x3F] ^
                                     $sbox3[($b1 >> 16) & 0x3F] ^ $sbox4[($b2 >> 16) & 0x3F] ^
                                     $sbox5[($b1 >>  8) & 0x3F] ^ $sbox6[($b2 >>  8) & 0x3F] ^
                                     $sbox7[ $b1        & 0x3F] ^ $sbox8[ $b2        & 0x3F] ^ ' . $l . ';
                        ';
                        // end of "the Feistel (F) function"

                        // swap L & R
                        list($l, $r) = array($r, $l);
                    }
                    list($l, $r) = array($r, $l);
                }

                // Perform the inverse IP permutation.
                $crypt_block[$c].= '$in =
                    ($shuffleinvip[($l >> 24) & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
                    ($shuffleinvip[($r >> 24) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
                    ($shuffleinvip[($l >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
                    ($shuffleinvip[($r >> 16) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
                    ($shuffleinvip[($l >>  8) & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
                    ($shuffleinvip[($r >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
                    ($shuffleinvip[ $l        & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
                    ($shuffleinvip[ $r        & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");
                ';
            }

            // Creates the inline-crypt function
            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
                array(
                   'init_crypt'    => $init_crypt,
                   'init_encrypt'  => $init_encrypt,
                   'init_decrypt'  => $init_decrypt,
                   'encrypt_block' => $crypt_block[CRYPT_DES_ENCRYPT],
                   'decrypt_block' => $crypt_block[CRYPT_DES_DECRYPT]
                )
            );
        }

        // Set the inline-crypt function as callback in: $this->inline_crypt
        $this->inline_crypt = $lambda_functions[$code_hash];
    }
}

}
if (!class_exists('Crypt_TripleDES')) {
    
/**
 * Pure-PHP implementation of Triple DES.
 *
 * Uses mcrypt, if available, and an internal implementation, otherwise.  Operates in the EDE3 mode (encrypt-decrypt-encrypt).
 *
 * PHP versions 4 and 5
 *
 * Here's a short example of how to use this library:
 * <code>
 *  *    include 'Crypt/TripleDES.php';
 *
 *    $des = new Crypt_TripleDES();
 *
 *    $des->setKey('abcdefghijklmnopqrstuvwx');
 *
 *    $size = 10 * 1024;
 *    $plaintext = '';
 *    for ($i = 0; $i < $size; $i++) {
 *        $plaintext.= 'a';
 *    }
 *
 *    echo $des->decrypt($des->encrypt($plaintext));
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_TripleDES
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMVII Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**
 * Include Crypt_DES
 */
if (!class_exists('Crypt_DES')) {
    include_once 'DES.php';
}

/**
 * Encrypt / decrypt using inner chaining
 *
 * Inner chaining is used by SSH-1 and is generally considered to be less secure then outer chaining (CRYPT_DES_MODE_CBC3).
 */
define('CRYPT_DES_MODE_3CBC', -2);

/**
 * Encrypt / decrypt using outer chaining
 *
 * Outer chaining is used by SSH-2 and when the mode is set to CRYPT_DES_MODE_CBC.
 */
define('CRYPT_DES_MODE_CBC3', CRYPT_DES_MODE_CBC);

/**
 * Pure-PHP implementation of Triple DES.
 *
 * @package Crypt_TripleDES
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_TripleDES extends Crypt_DES
{
    /**
     * The default password key_size used by setPassword()
     *
     * @see Crypt_DES::password_key_size
     * @see Crypt_Base::password_key_size
     * @see Crypt_Base::setPassword()
     * @var Integer
     * @access private
     */
    var $password_key_size = 24;

    /**
     * The default salt used by setPassword()
     *
     * @see Crypt_Base::password_default_salt
     * @see Crypt_Base::setPassword()
     * @var String
     * @access private
     */
    var $password_default_salt = 'phpseclib';

    /**
     * The namespace used by the cipher for its constants.
     *
     * @see Crypt_DES::const_namespace
     * @see Crypt_Base::const_namespace
     * @var String
     * @access private
     */
    var $const_namespace = 'DES';

    /**
     * The mcrypt specific name of the cipher
     *
     * @see Crypt_DES::cipher_name_mcrypt
     * @see Crypt_Base::cipher_name_mcrypt
     * @var String
     * @access private
     */
    var $cipher_name_mcrypt = 'tripledes';

    /**
     * Optimizing value while CFB-encrypting
     *
     * @see Crypt_Base::cfb_init_len
     * @var Integer
     * @access private
     */
    var $cfb_init_len = 750;

    /**
     * max possible size of $key
     *
     * @see Crypt_TripleDES::setKey()
     * @see Crypt_DES::setKey()
     * @var String
     * @access private
     */
    var $key_size_max = 24;

    /**
     * Internal flag whether using CRYPT_DES_MODE_3CBC or not
     *
     * @var Boolean
     * @access private
     */
    var $mode_3cbc;

    /**
     * The Crypt_DES objects
     *
     * Used only if $mode_3cbc === true
     *
     * @var Array
     * @access private
     */
    var $des;

    /**
     * Default Constructor.
     *
     * Determines whether or not the mcrypt extension should be used.
     *
     * $mode could be:
     *
     * - CRYPT_DES_MODE_ECB
     *
     * - CRYPT_DES_MODE_CBC
     *
     * - CRYPT_DES_MODE_CTR
     *
     * - CRYPT_DES_MODE_CFB
     *
     * - CRYPT_DES_MODE_OFB
     *
     * - CRYPT_DES_MODE_3CBC
     *
     * If not explicitly set, CRYPT_DES_MODE_CBC will be used.
     *
     * @see Crypt_DES::Crypt_DES()
     * @see Crypt_Base::Crypt_Base()
     * @param optional Integer $mode
     * @access public
     */
    function Crypt_TripleDES($mode = CRYPT_DES_MODE_CBC)
    {
        switch ($mode) {
            // In case of CRYPT_DES_MODE_3CBC, we init as CRYPT_DES_MODE_CBC
            // and additional flag us internally as 3CBC
            case CRYPT_DES_MODE_3CBC:
                parent::Crypt_Base(CRYPT_DES_MODE_CBC);
                $this->mode_3cbc = true;

                // This three $des'es will do the 3CBC work (if $key > 64bits)
                $this->des = array(
                    new Crypt_DES(CRYPT_DES_MODE_CBC),
                    new Crypt_DES(CRYPT_DES_MODE_CBC),
                    new Crypt_DES(CRYPT_DES_MODE_CBC),
                );

                // we're going to be doing the padding, ourselves, so disable it in the Crypt_DES objects
                $this->des[0]->disablePadding();
                $this->des[1]->disablePadding();
                $this->des[2]->disablePadding();
                break;
            // If not 3CBC, we init as usual
            default:
                parent::Crypt_Base($mode);
        }
    }

    /**
     * Sets the initialization vector. (optional)
     *
     * SetIV is not required when CRYPT_DES_MODE_ECB is being used.  If not explicitly set, it'll be assumed
     * to be all zero's.
     *
     * @see Crypt_Base::setIV()
     * @access public
     * @param String $iv
     */
    function setIV($iv)
    {
        parent::setIV($iv);
        if ($this->mode_3cbc) {
            $this->des[0]->setIV($iv);
            $this->des[1]->setIV($iv);
            $this->des[2]->setIV($iv);
        }
    }

    /**
     * Sets the key.
     *
     * Keys can be of any length.  Triple DES, itself, can use 128-bit (eg. strlen($key) == 16) or
     * 192-bit (eg. strlen($key) == 24) keys.  This function pads and truncates $key as appropriate.
     *
     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
     *
     * If the key is not explicitly set, it'll be assumed to be all null bytes.
     *
     * @access public
     * @see Crypt_DES::setKey()
     * @see Crypt_Base::setKey()
     * @param String $key
     */
    function setKey($key)
    {
        $length = strlen($key);
        if ($length > 8) {
            $key = str_pad(substr($key, 0, 24), 24, chr(0));
            // if $key is between 64 and 128-bits, use the first 64-bits as the last, per this:
            // http://php.net/function.mcrypt-encrypt#47973
            //$key = $length <= 16 ? substr_replace($key, substr($key, 0, 8), 16) : substr($key, 0, 24);
        } else {
            $key = str_pad($key, 8, chr(0));
        }
        parent::setKey($key);

        // And in case of CRYPT_DES_MODE_3CBC:
        // if key <= 64bits we not need the 3 $des to work,
        // because we will then act as regular DES-CBC with just a <= 64bit key.
        // So only if the key > 64bits (> 8 bytes) we will call setKey() for the 3 $des.
        if ($this->mode_3cbc && $length > 8) {
            $this->des[0]->setKey(substr($key,  0, 8));
            $this->des[1]->setKey(substr($key,  8, 8));
            $this->des[2]->setKey(substr($key, 16, 8));
        }
    }

    /**
     * Encrypts a message.
     *
     * @see Crypt_Base::encrypt()
     * @access public
     * @param String $plaintext
     * @return String $cipertext
     */
    function encrypt($plaintext)
    {
        // parent::en/decrypt() is able to do all the work for all modes and keylengths,
        // except for: CRYPT_DES_MODE_3CBC (inner chaining CBC) with a key > 64bits

        // if the key is smaller then 8, do what we'd normally do
        if ($this->mode_3cbc && strlen($this->key) > 8) {
            return $this->des[2]->encrypt(
                $this->des[1]->decrypt(
                    $this->des[0]->encrypt(
                        $this->_pad($plaintext)
                    )
                )
            );
        }

        return parent::encrypt($plaintext);
    }

    /**
     * Decrypts a message.
     *
     * @see Crypt_Base::decrypt()
     * @access public
     * @param String $ciphertext
     * @return String $plaintext
     */
    function decrypt($ciphertext)
    {
        if ($this->mode_3cbc && strlen($this->key) > 8) {
            return $this->_unpad(
                $this->des[0]->decrypt(
                    $this->des[1]->encrypt(
                        $this->des[2]->decrypt(
                            str_pad($ciphertext, (strlen($ciphertext) + 7) & 0xFFFFFFF8, "\0")
                        )
                    )
                )
            );
        }

        return parent::decrypt($ciphertext);
    }

    /**
     * Treat consecutive "packets" as if they are a continuous buffer.
     *
     * Say you have a 16-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
     * will yield different outputs:
     *
     * <code>
     *    echo $des->encrypt(substr($plaintext, 0, 8));
     *    echo $des->encrypt(substr($plaintext, 8, 8));
     * </code>
     * <code>
     *    echo $des->encrypt($plaintext);
     * </code>
     *
     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
     * another, as demonstrated with the following:
     *
     * <code>
     *    $des->encrypt(substr($plaintext, 0, 8));
     *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
     * </code>
     * <code>
     *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
     * </code>
     *
     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
     *
     * Put another way, when the continuous buffer is enabled, the state of the Crypt_DES() object changes after each
     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
     * however, they are also less intuitive and more likely to cause you problems.
     *
     * @see Crypt_Base::enableContinuousBuffer()
     * @see Crypt_TripleDES::disableContinuousBuffer()
     * @access public
     */
    function enableContinuousBuffer()
    {
        parent::enableContinuousBuffer();
        if ($this->mode_3cbc) {
            $this->des[0]->enableContinuousBuffer();
            $this->des[1]->enableContinuousBuffer();
            $this->des[2]->enableContinuousBuffer();
        }
    }

    /**
     * Treat consecutive packets as if they are a discontinuous buffer.
     *
     * The default behavior.
     *
     * @see Crypt_Base::disableContinuousBuffer()
     * @see Crypt_TripleDES::enableContinuousBuffer()
     * @access public
     */
    function disableContinuousBuffer()
    {
        parent::disableContinuousBuffer();
        if ($this->mode_3cbc) {
            $this->des[0]->disableContinuousBuffer();
            $this->des[1]->disableContinuousBuffer();
            $this->des[2]->disableContinuousBuffer();
        }
    }

    /**
     * Creates the key schedule
     *
     * @see Crypt_DES::_setupKey()
     * @see Crypt_Base::_setupKey()
     * @access private
     */
    function _setupKey()
    {
        switch (true) {
            // if $key <= 64bits we configure our internal pure-php cipher engine
            // to act as regular [1]DES, not as 3DES. mcrypt.so::tripledes does the same.
            case strlen($this->key) <= 8:
                $this->des_rounds = 1;
                break;

            // otherwise, if $key > 64bits, we configure our engine to work as 3DES.
            default:
                $this->des_rounds = 3;

                // (only) if 3CBC is used we have, of course, to setup the $des[0-2] keys also separately.
                if ($this->mode_3cbc) {
                    $this->des[0]->_setupKey();
                    $this->des[1]->_setupKey();
                    $this->des[2]->_setupKey();

                    // because $des[0-2] will, now, do all the work we can return here
                    // not need unnecessary stress parent::_setupKey() with our, now unused, $key.
                    return;
                }
        }
        // setup our key
        parent::_setupKey();
    }
}

}
if (!class_exists('Crypt_RSA')) {
    
/**
 * Pure-PHP PKCS#1 (v2.1) compliant implementation of RSA.
 *
 * PHP versions 4 and 5
 *
 * Here's an example of how to encrypt and decrypt text with this library:
 * <code>
 *  *    include 'Crypt/RSA.php';
 *
 *    $rsa = new Crypt_RSA();
 *    extract($rsa->createKey());
 *
 *    $plaintext = 'terrafrost';
 *
 *    $rsa->loadKey($privatekey);
 *    $ciphertext = $rsa->encrypt($plaintext);
 *
 *    $rsa->loadKey($publickey);
 *    echo $rsa->decrypt($ciphertext);
 *  * </code>
 *
 * Here's an example of how to create signatures and verify signatures with this library:
 * <code>
 *  *    include 'Crypt/RSA.php';
 *
 *    $rsa = new Crypt_RSA();
 *    extract($rsa->createKey());
 *
 *    $plaintext = 'terrafrost';
 *
 *    $rsa->loadKey($privatekey);
 *    $signature = $rsa->sign($plaintext);
 *
 *    $rsa->loadKey($publickey);
 *    echo $rsa->verify($plaintext, $signature) ? 'verified' : 'unverified';
 *  * </code>
 *
 * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @category  Crypt
 * @package   Crypt_RSA
 * @author    Jim Wigginton <terrafrost@php.net>
 * @copyright MMIX Jim Wigginton
 * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
 * @link      http://phpseclib.sourceforge.net
 */

/**
 * Include Crypt_Random
 */
// the class_exists() will only be called if the crypt_random_string function hasn't been defined and
// will trigger a call to __autoload() if you're wanting to auto-load classes
// call function_exists() a second time to stop the include_once from being called outside
// of the auto loader
if (!function_exists('crypt_random_string')) {
    include_once 'Random.php';
}

/**
 * Include Crypt_Hash
 */
if (!class_exists('Crypt_Hash')) {
    include_once 'Hash.php';
}

/**#@+
 * @access public
 * @see Crypt_RSA::encrypt()
 * @see Crypt_RSA::decrypt()
 */
/**
 * Use {@link http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding Optimal Asymmetric Encryption Padding}
 * (OAEP) for encryption / decryption.
 *
 * Uses sha1 by default.
 *
 * @see Crypt_RSA::setHash()
 * @see Crypt_RSA::setMGFHash()
 */
define('CRYPT_RSA_ENCRYPTION_OAEP',  1);
/**
 * Use PKCS#1 padding.
 *
 * Although CRYPT_RSA_ENCRYPTION_OAEP offers more security, including PKCS#1 padding is necessary for purposes of backwards
 * compatibility with protocols (like SSH-1) written before OAEP's introduction.
 */
define('CRYPT_RSA_ENCRYPTION_PKCS1', 2);
/**#@-*/

/**#@+
 * @access public
 * @see Crypt_RSA::sign()
 * @see Crypt_RSA::verify()
 * @see Crypt_RSA::setHash()
 */
/**
 * Use the Probabilistic Signature Scheme for signing
 *
 * Uses sha1 by default.
 *
 * @see Crypt_RSA::setSaltLength()
 * @see Crypt_RSA::setMGFHash()
 */
define('CRYPT_RSA_SIGNATURE_PSS',  1);
/**
 * Use the PKCS#1 scheme by default.
 *
 * Although CRYPT_RSA_SIGNATURE_PSS offers more security, including PKCS#1 signing is necessary for purposes of backwards
 * compatibility with protocols (like SSH-2) written before PSS's introduction.
 */
define('CRYPT_RSA_SIGNATURE_PKCS1', 2);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_RSA::createKey()
 */
/**
 * ASN1 Integer
 */
define('CRYPT_RSA_ASN1_INTEGER',     2);
/**
 * ASN1 Bit String
 */
define('CRYPT_RSA_ASN1_BITSTRING',   3);
/**
 * ASN1 Octet String
 */
define('CRYPT_RSA_ASN1_OCTETSTRING', 4);
/**
 * ASN1 Object Identifier
 */
define('CRYPT_RSA_ASN1_OBJECT',      6);
/**
 * ASN1 Sequence (with the constucted bit set)
 */
define('CRYPT_RSA_ASN1_SEQUENCE',   48);
/**#@-*/

/**#@+
 * @access private
 * @see Crypt_RSA::Crypt_RSA()
 */
/**
 * To use the pure-PHP implementation
 */
define('CRYPT_RSA_MODE_INTERNAL', 1);
/**
 * To use the OpenSSL library
 *
 * (if enabled; otherwise, the internal implementation will be used)
 */
define('CRYPT_RSA_MODE_OPENSSL', 2);
/**#@-*/

/**
 * Default openSSL configuration file.
 */
define('CRYPT_RSA_OPENSSL_CONFIG', dirname(__FILE__) . '/../openssl.cnf');

/**#@+
 * @access public
 * @see Crypt_RSA::createKey()
 * @see Crypt_RSA::setPrivateKeyFormat()
 */
/**
 * PKCS#1 formatted private key
 *
 * Used by OpenSSH
 */
define('CRYPT_RSA_PRIVATE_FORMAT_PKCS1', 0);
/**
 * PuTTY formatted private key
 */
define('CRYPT_RSA_PRIVATE_FORMAT_PUTTY', 1);
/**
 * XML formatted private key
 */
define('CRYPT_RSA_PRIVATE_FORMAT_XML', 2);
/**
 * PKCS#8 formatted private key
 */
define('CRYPT_RSA_PRIVATE_FORMAT_PKCS8', 3);
/**#@-*/

/**#@+
 * @access public
 * @see Crypt_RSA::createKey()
 * @see Crypt_RSA::setPublicKeyFormat()
 */
/**
 * Raw public key
 *
 * An array containing two Math_BigInteger objects.
 *
 * The exponent can be indexed with any of the following:
 *
 * 0, e, exponent, publicExponent
 *
 * The modulus can be indexed with any of the following:
 *
 * 1, n, modulo, modulus
 */
define('CRYPT_RSA_PUBLIC_FORMAT_RAW', 3);
/**
 * PKCS#1 formatted public key (raw)
 *
 * Used by File/X509.php
 *
 * Has the following header:
 *
 * -----BEGIN RSA PUBLIC KEY-----
 *
 * Analogous to ssh-keygen's pem format (as specified by -m)
 */
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS1', 4);
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW', 4);
/**
 * XML formatted public key
 */
define('CRYPT_RSA_PUBLIC_FORMAT_XML', 5);
/**
 * OpenSSH formatted public key
 *
 * Place in $HOME/.ssh/authorized_keys
 */
define('CRYPT_RSA_PUBLIC_FORMAT_OPENSSH', 6);
/**
 * PKCS#1 formatted public key (encapsulated)
 *
 * Used by PHP's openssl_public_encrypt() and openssl's rsautl (when -pubin is set)
 *
 * Has the following header:
 *
 * -----BEGIN PUBLIC KEY-----
 *
 * Analogous to ssh-keygen's pkcs8 format (as specified by -m). Although PKCS8
 * is specific to private keys it's basically creating a DER-encoded wrapper
 * for keys. This just extends that same concept to public keys (much like ssh-keygen)
 */
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS8', 7);
/**#@-*/

/**
 * Pure-PHP PKCS#1 compliant implementation of RSA.
 *
 * @package Crypt_RSA
 * @author  Jim Wigginton <terrafrost@php.net>
 * @access  public
 */
class Crypt_RSA
{
    /**
     * Precomputed Zero
     *
     * @var Array
     * @access private
     */
    var $zero;

    /**
     * Precomputed One
     *
     * @var Array
     * @access private
     */
    var $one;

    /**
     * Private Key Format
     *
     * @var Integer
     * @access private
     */
    var $privateKeyFormat = CRYPT_RSA_PRIVATE_FORMAT_PKCS1;

    /**
     * Public Key Format
     *
     * @var Integer
     * @access public
     */
    var $publicKeyFormat = CRYPT_RSA_PUBLIC_FORMAT_PKCS8;

    /**
     * Modulus (ie. n)
     *
     * @var Math_BigInteger
     * @access private
     */
    var $modulus;

    /**
     * Modulus length
     *
     * @var Math_BigInteger
     * @access private
     */
    var $k;

    /**
     * Exponent (ie. e or d)
     *
     * @var Math_BigInteger
     * @access private
     */
    var $exponent;

    /**
     * Primes for Chinese Remainder Theorem (ie. p and q)
     *
     * @var Array
     * @access private
     */
    var $primes;

    /**
     * Exponents for Chinese Remainder Theorem (ie. dP and dQ)
     *
     * @var Array
     * @access private
     */
    var $exponents;

    /**
     * Coefficients for Chinese Remainder Theorem (ie. qInv)
     *
     * @var Array
     * @access private
     */
    var $coefficients;

    /**
     * Hash name
     *
     * @var String
     * @access private
     */
    var $hashName;

    /**
     * Hash function
     *
     * @var Crypt_Hash
     * @access private
     */
    var $hash;

    /**
     * Length of hash function output
     *
     * @var Integer
     * @access private
     */
    var $hLen;

    /**
     * Length of salt
     *
     * @var Integer
     * @access private
     */
    var $sLen;

    /**
     * Hash function for the Mask Generation Function
     *
     * @var Crypt_Hash
     * @access private
     */
    var $mgfHash;

    /**
     * Length of MGF hash function output
     *
     * @var Integer
     * @access private
     */
    var $mgfHLen;

    /**
     * Encryption mode
     *
     * @var Integer
     * @access private
     */
    var $encryptionMode = CRYPT_RSA_ENCRYPTION_OAEP;

    /**
     * Signature mode
     *
     * @var Integer
     * @access private
     */
    var $signatureMode = CRYPT_RSA_SIGNATURE_PSS;

    /**
     * Public Exponent
     *
     * @var Mixed
     * @access private
     */
    var $publicExponent = false;

    /**
     * Password
     *
     * @var String
     * @access private
     */
    var $password = false;

    /**
     * Components
     *
     * For use with parsing XML formatted keys.  PHP's XML Parser functions use utilized - instead of PHP's DOM functions -
     * because PHP's XML Parser functions work on PHP4 whereas PHP's DOM functions - although surperior - don't.
     *
     * @see Crypt_RSA::_start_element_handler()
     * @var Array
     * @access private
     */
    var $components = array();

    /**
     * Current String
     *
     * For use with parsing XML formatted keys.
     *
     * @see Crypt_RSA::_character_handler()
     * @see Crypt_RSA::_stop_element_handler()
     * @var Mixed
     * @access private
     */
    var $current;

    /**
     * OpenSSL configuration file name.
     *
     * Set to null to use system configuration file.
     * @see Crypt_RSA::createKey()
     * @var Mixed
     * @Access public
     */
    var $configFile;

    /**
     * Public key comment field.
     *
     * @var String
     * @access private
     */
    var $comment = 'phpseclib-generated-key';

    /**
     * The constructor
     *
     * If you want to make use of the openssl extension, you'll need to set the mode manually, yourself.  The reason
     * Crypt_RSA doesn't do it is because OpenSSL doesn't fail gracefully.  openssl_pkey_new(), in particular, requires
     * openssl.cnf be present somewhere and, unfortunately, the only real way to find out is too late.
     *
     * @return Crypt_RSA
     * @access public
     */
    function Crypt_RSA()
    {
        if (!class_exists('Math_BigInteger')) {
            include_once 'Math/BigInteger.php';
        }

        $this->configFile = CRYPT_RSA_OPENSSL_CONFIG;

        if ( !defined('CRYPT_RSA_MODE') ) {
            switch (true) {
                // Math/BigInteger's openssl requirements are a little less stringent than Crypt/RSA's. in particular,
                // Math/BigInteger doesn't require an openssl.cfg file whereas Crypt/RSA does. so if Math/BigInteger
                // can't use OpenSSL it can be pretty trivially assumed, then, that Crypt/RSA can't either.
                case defined('MATH_BIGINTEGER_OPENSSL_DISABLE'):
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                    break;
                // openssl_pkey_get_details - which is used in the only place Crypt/RSA.php uses OpenSSL - was introduced in PHP 5.2.0
                case !function_exists('openssl_pkey_get_details'):
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                    break;
                case extension_loaded('openssl') && version_compare(PHP_VERSION, '4.2.0', '>=') && file_exists($this->configFile):
                    // some versions of XAMPP have mismatched versions of OpenSSL which causes it not to work
                    ob_start();
                    @phpinfo();
                    $content = ob_get_contents();
                    ob_end_clean();

                    preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);

                    $versions = array();
                    if (!empty($matches[1])) {
                       for ($i = 0; $i < count($matches[1]); $i++) {
                          $versions[$matches[1][$i]] = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
                       }
                    }

                    // it doesn't appear that OpenSSL versions were reported upon until PHP 5.3+
                    switch (true) {
                        case !isset($versions['Header']):
                        case !isset($versions['Library']):
                        case $versions['Header'] == $versions['Library']:
                            define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_OPENSSL);
                            break;
                        default:
                            define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                            define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
                    }
                    break;
                default:
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
            }
        }

        $this->zero = new Math_BigInteger();
        $this->one = new Math_BigInteger(1);

        $this->hash = new Crypt_Hash('sha1');
        $this->hLen = $this->hash->getLength();
        $this->hashName = 'sha1';
        $this->mgfHash = new Crypt_Hash('sha1');
        $this->mgfHLen = $this->mgfHash->getLength();
    }

    /**
     * Create public / private key pair
     *
     * Returns an array with the following three elements:
     *  - 'privatekey': The private key.
     *  - 'publickey':  The public key.
     *  - 'partialkey': A partially computed key (if the execution time exceeded $timeout).
     *                  Will need to be passed back to Crypt_RSA::createKey() as the third parameter for further processing.
     *
     * @access public
     * @param optional Integer $bits
     * @param optional Integer $timeout
     * @param optional Math_BigInteger $p
     */
    function createKey($bits = 1024, $timeout = false, $partial = array())
    {
        if (!defined('CRYPT_RSA_EXPONENT')) {
            // http://en.wikipedia.org/wiki/65537_%28number%29
            define('CRYPT_RSA_EXPONENT', '65537');
        }
        // per <http://cseweb.ucsd.edu/~hovav/dist/survey.pdf#page=5>, this number ought not result in primes smaller
        // than 256 bits. as a consequence if the key you're trying to create is 1024 bits and you've set CRYPT_RSA_SMALLEST_PRIME
        // to 384 bits then you're going to get a 384 bit prime and a 640 bit prime (384 + 1024 % 384). at least if
        // CRYPT_RSA_MODE is set to CRYPT_RSA_MODE_INTERNAL. if CRYPT_RSA_MODE is set to CRYPT_RSA_MODE_OPENSSL then
        // CRYPT_RSA_SMALLEST_PRIME is ignored (ie. multi-prime RSA support is more intended as a way to speed up RSA key
        // generation when there's a chance neither gmp nor OpenSSL are installed)
        if (!defined('CRYPT_RSA_SMALLEST_PRIME')) {
            define('CRYPT_RSA_SMALLEST_PRIME', 4096);
        }

        // OpenSSL uses 65537 as the exponent and requires RSA keys be 384 bits minimum
        if ( CRYPT_RSA_MODE == CRYPT_RSA_MODE_OPENSSL && $bits >= 384 && CRYPT_RSA_EXPONENT == 65537) {
            $config = array();
            if (isset($this->configFile)) {
                $config['config'] = $this->configFile;
            }
            $rsa = openssl_pkey_new(array('private_key_bits' => $bits) + $config);
            openssl_pkey_export($rsa, $privatekey, null, $config);
            $publickey = openssl_pkey_get_details($rsa);
            $publickey = $publickey['key'];

            $privatekey = call_user_func_array(array($this, '_convertPrivateKey'), array_values($this->_parseKey($privatekey, CRYPT_RSA_PRIVATE_FORMAT_PKCS1)));
            $publickey = call_user_func_array(array($this, '_convertPublicKey'), array_values($this->_parseKey($publickey, CRYPT_RSA_PUBLIC_FORMAT_PKCS1)));

            // clear the buffer of error strings stemming from a minimalistic openssl.cnf
            while (openssl_error_string() !== false);

            return array(
                'privatekey' => $privatekey,
                'publickey' => $publickey,
                'partialkey' => false
            );
        }

        static $e;
        if (!isset($e)) {
            $e = new Math_BigInteger(CRYPT_RSA_EXPONENT);
        }

        extract($this->_generateMinMax($bits));
        $absoluteMin = $min;
        $temp = $bits >> 1; // divide by two to see how many bits P and Q would be
        if ($temp > CRYPT_RSA_SMALLEST_PRIME) {
            $num_primes = floor($bits / CRYPT_RSA_SMALLEST_PRIME);
            $temp = CRYPT_RSA_SMALLEST_PRIME;
        } else {
            $num_primes = 2;
        }
        extract($this->_generateMinMax($temp + $bits % $temp));
        $finalMax = $max;
        extract($this->_generateMinMax($temp));

        $generator = new Math_BigInteger();

        $n = $this->one->copy();
        if (!empty($partial)) {
            extract(unserialize($partial));
        } else {
            $exponents = $coefficients = $primes = array();
            $lcm = array(
                'top' => $this->one->copy(),
                'bottom' => false
            );
        }

        $start = time();
        $i0 = count($primes) + 1;

        do {
            for ($i = $i0; $i <= $num_primes; $i++) {
                if ($timeout !== false) {
                    $timeout-= time() - $start;
                    $start = time();
                    if ($timeout <= 0) {
                        return array(
                            'privatekey' => '',
                            'publickey'  => '',
                            'partialkey' => serialize(array(
                                'primes' => $primes,
                                'coefficients' => $coefficients,
                                'lcm' => $lcm,
                                'exponents' => $exponents
                            ))
                        );
                    }
                }

                if ($i == $num_primes) {
                    list($min, $temp) = $absoluteMin->divide($n);
                    if (!$temp->equals($this->zero)) {
                        $min = $min->add($this->one); // ie. ceil()
                    }
                    $primes[$i] = $generator->randomPrime($min, $finalMax, $timeout);
                } else {
                    $primes[$i] = $generator->randomPrime($min, $max, $timeout);
                }

                if ($primes[$i] === false) { // if we've reached the timeout
                    if (count($primes) > 1) {
                        $partialkey = '';
                    } else {
                        array_pop($primes);
                        $partialkey = serialize(array(
                            'primes' => $primes,
                            'coefficients' => $coefficients,
                            'lcm' => $lcm,
                            'exponents' => $exponents
                        ));
                    }

                    return array(
                        'privatekey' => '',
                        'publickey'  => '',
                        'partialkey' => $partialkey
                    );
                }

                // the first coefficient is calculated differently from the rest
                // ie. instead of being $primes[1]->modInverse($primes[2]), it's $primes[2]->modInverse($primes[1])
                if ($i > 2) {
                    $coefficients[$i] = $n->modInverse($primes[$i]);
                }

                $n = $n->multiply($primes[$i]);

                $temp = $primes[$i]->subtract($this->one);

                // textbook RSA implementations use Euler's totient function instead of the least common multiple.
                // see http://en.wikipedia.org/wiki/Euler%27s_totient_function
                $lcm['top'] = $lcm['top']->multiply($temp);
                $lcm['bottom'] = $lcm['bottom'] === false ? $temp : $lcm['bottom']->gcd($temp);

                $exponents[$i] = $e->modInverse($temp);
            }

            list($temp) = $lcm['top']->divide($lcm['bottom']);
            $gcd = $temp->gcd($e);
            $i0 = 1;
        } while (!$gcd->equals($this->one));

        $d = $e->modInverse($temp);

        $coefficients[2] = $primes[2]->modInverse($primes[1]);

        // from <http://tools.ietf.org/html/rfc3447#appendix-A.1.2>:
        // RSAPrivateKey ::= SEQUENCE {
        //     version           Version,
        //     modulus           INTEGER,  -- n
        //     publicExponent    INTEGER,  -- e
        //     privateExponent   INTEGER,  -- d
        //     prime1            INTEGER,  -- p
        //     prime2            INTEGER,  -- q
        //     exponent1         INTEGER,  -- d mod (p-1)
        //     exponent2         INTEGER,  -- d mod (q-1)
        //     coefficient       INTEGER,  -- (inverse of q) mod p
        //     otherPrimeInfos   OtherPrimeInfos OPTIONAL
        // }

        return array(
            'privatekey' => $this->_convertPrivateKey($n, $e, $d, $primes, $exponents, $coefficients),
            'publickey'  => $this->_convertPublicKey($n, $e),
            'partialkey' => false
        );
    }

    /**
     * Convert a private key to the appropriate format.
     *
     * @access private
     * @see setPrivateKeyFormat()
     * @param String $RSAPrivateKey
     * @return String
     */
    function _convertPrivateKey($n, $e, $d, $primes, $exponents, $coefficients)
    {
        $signed = $this->privateKeyFormat != CRYPT_RSA_PRIVATE_FORMAT_XML;
        $num_primes = count($primes);
        $raw = array(
            'version' => $num_primes == 2 ? chr(0) : chr(1), // two-prime vs. multi
            'modulus' => $n->toBytes($signed),
            'publicExponent' => $e->toBytes($signed),
            'privateExponent' => $d->toBytes($signed),
            'prime1' => $primes[1]->toBytes($signed),
            'prime2' => $primes[2]->toBytes($signed),
            'exponent1' => $exponents[1]->toBytes($signed),
            'exponent2' => $exponents[2]->toBytes($signed),
            'coefficient' => $coefficients[2]->toBytes($signed)
        );

        // if the format in question does not support multi-prime rsa and multi-prime rsa was used,
        // call _convertPublicKey() instead.
        switch ($this->privateKeyFormat) {
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
                if ($num_primes != 2) {
                    return false;
                }
                return "<RSAKeyValue>\r\n" .
                       '  <Modulus>' . base64_encode($raw['modulus']) . "</Modulus>\r\n" .
                       '  <Exponent>' . base64_encode($raw['publicExponent']) . "</Exponent>\r\n" .
                       '  <P>' . base64_encode($raw['prime1']) . "</P>\r\n" .
                       '  <Q>' . base64_encode($raw['prime2']) . "</Q>\r\n" .
                       '  <DP>' . base64_encode($raw['exponent1']) . "</DP>\r\n" .
                       '  <DQ>' . base64_encode($raw['exponent2']) . "</DQ>\r\n" .
                       '  <InverseQ>' . base64_encode($raw['coefficient']) . "</InverseQ>\r\n" .
                       '  <D>' . base64_encode($raw['privateExponent']) . "</D>\r\n" .
                       '</RSAKeyValue>';
                break;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                if ($num_primes != 2) {
                    return false;
                }
                $key = "PuTTY-User-Key-File-2: ssh-rsa\r\nEncryption: ";
                $encryption = (!empty($this->password) || is_string($this->password)) ? 'aes256-cbc' : 'none';
                $key.= $encryption;
                $key.= "\r\nComment: " . $this->comment . "\r\n";
                $public = pack('Na*Na*Na*',
                    strlen('ssh-rsa'), 'ssh-rsa', strlen($raw['publicExponent']), $raw['publicExponent'], strlen($raw['modulus']), $raw['modulus']
                );
                $source = pack('Na*Na*Na*Na*',
                    strlen('ssh-rsa'), 'ssh-rsa', strlen($encryption), $encryption,
                    strlen($this->comment), $this->comment, strlen($public), $public
                );
                $public = base64_encode($public);
                $key.= "Public-Lines: " . ((strlen($public) + 63) >> 6) . "\r\n";
                $key.= chunk_split($public, 64);
                $private = pack('Na*Na*Na*Na*',
                    strlen($raw['privateExponent']), $raw['privateExponent'], strlen($raw['prime1']), $raw['prime1'],
                    strlen($raw['prime2']), $raw['prime2'], strlen($raw['coefficient']), $raw['coefficient']
                );
                if (empty($this->password) && !is_string($this->password)) {
                    $source.= pack('Na*', strlen($private), $private);
                    $hashkey = 'putty-private-key-file-mac-key';
                } else {
                    $private.= crypt_random_string(16 - (strlen($private) & 15));
                    $source.= pack('Na*', strlen($private), $private);
                    if (!class_exists('Crypt_AES')) {
                        include_once 'Crypt/AES.php';
                    }
                    $sequence = 0;
                    $symkey = '';
                    while (strlen($symkey) < 32) {
                        $temp = pack('Na*', $sequence++, $this->password);
                        $symkey.= pack('H*', sha1($temp));
                    }
                    $symkey = substr($symkey, 0, 32);
                    $crypto = new Crypt_AES();

                    $crypto->setKey($symkey);
                    $crypto->disablePadding();
                    $private = $crypto->encrypt($private);
                    $hashkey = 'putty-private-key-file-mac-key' . $this->password;
                }

                $private = base64_encode($private);
                $key.= 'Private-Lines: ' . ((strlen($private) + 63) >> 6) . "\r\n";
                $key.= chunk_split($private, 64);
                if (!class_exists('Crypt_Hash')) {
                    include_once 'Crypt/Hash.php';
                }
                $hash = new Crypt_Hash('sha1');
                $hash->setKey(pack('H*', sha1($hashkey)));
                $key.= 'Private-MAC: ' . bin2hex($hash->hash($source)) . "\r\n";

                return $key;
            default: // eg. CRYPT_RSA_PRIVATE_FORMAT_PKCS1
                $components = array();
                foreach ($raw as $name => $value) {
                    $components[$name] = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($value)), $value);
                }

                $RSAPrivateKey = implode('', $components);

                if ($num_primes > 2) {
                    $OtherPrimeInfos = '';
                    for ($i = 3; $i <= $num_primes; $i++) {
                        // OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo
                        //
                        // OtherPrimeInfo ::= SEQUENCE {
                        //     prime             INTEGER,  -- ri
                        //     exponent          INTEGER,  -- di
                        //     coefficient       INTEGER   -- ti
                        // }
                        $OtherPrimeInfo = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($primes[$i]->toBytes(true))), $primes[$i]->toBytes(true));
                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($exponents[$i]->toBytes(true))), $exponents[$i]->toBytes(true));
                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($coefficients[$i]->toBytes(true))), $coefficients[$i]->toBytes(true));
                        $OtherPrimeInfos.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfo)), $OtherPrimeInfo);
                    }
                    $RSAPrivateKey.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfos)), $OtherPrimeInfos);
                }

                $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);

                if ($this->privateKeyFormat == CRYPT_RSA_PRIVATE_FORMAT_PKCS8) {
                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
                    $RSAPrivateKey = pack('Ca*a*Ca*a*',
                        CRYPT_RSA_ASN1_INTEGER, "\01\00", $rsaOID, 4, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey
                    );
                    $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                    if (!empty($this->password) || is_string($this->password)) {
                        $salt = crypt_random_string(8);
                        $iterationCount = 2048;

                        if (!class_exists('Crypt_DES')) {
                            include_once 'Crypt/DES.php';
                        }
                        $crypto = new Crypt_DES();
                        $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
                        $RSAPrivateKey = $crypto->encrypt($RSAPrivateKey);

                        $parameters = pack('Ca*a*Ca*N',
                            CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($salt)), $salt,
                            CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(4), $iterationCount
                        );
                        $pbeWithMD5AndDES_CBC = "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x03";

                        $encryptionAlgorithm = pack('Ca*a*Ca*a*',
                            CRYPT_RSA_ASN1_OBJECT, $this->_encodeLength(strlen($pbeWithMD5AndDES_CBC)), $pbeWithMD5AndDES_CBC,
                            CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($parameters)), $parameters
                        );

                        $RSAPrivateKey = pack('Ca*a*Ca*a*',
                            CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($encryptionAlgorithm)), $encryptionAlgorithm,
                            CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey
                        );

                        $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);

                        $RSAPrivateKey = "-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n" .
                                         chunk_split(base64_encode($RSAPrivateKey), 64) .
                                         '-----END ENCRYPTED PRIVATE KEY-----';
                    } else {
                        $RSAPrivateKey = "-----BEGIN PRIVATE KEY-----\r\n" .
                                         chunk_split(base64_encode($RSAPrivateKey), 64) .
                                         '-----END PRIVATE KEY-----';
                    }
                    return $RSAPrivateKey;
                }

                if (!empty($this->password) || is_string($this->password)) {
                    $iv = crypt_random_string(8);
                    $symkey = pack('H*', md5($this->password . $iv)); // symkey is short for symmetric key
                    $symkey.= substr(pack('H*', md5($symkey . $this->password . $iv)), 0, 8);
                    if (!class_exists('Crypt_TripleDES')) {
                        include_once 'Crypt/TripleDES.php';
                    }
                    $des = new Crypt_TripleDES();
                    $des->setKey($symkey);
                    $des->setIV($iv);
                    $iv = strtoupper(bin2hex($iv));
                    $RSAPrivateKey = "-----BEGIN RSA PRIVATE KEY-----\r\n" .
                                     "Proc-Type: 4,ENCRYPTED\r\n" .
                                     "DEK-Info: DES-EDE3-CBC,$iv\r\n" .
                                     "\r\n" .
                                     chunk_split(base64_encode($des->encrypt($RSAPrivateKey)), 64) .
                                     '-----END RSA PRIVATE KEY-----';
                } else {
                    $RSAPrivateKey = "-----BEGIN RSA PRIVATE KEY-----\r\n" .
                                     chunk_split(base64_encode($RSAPrivateKey), 64) .
                                     '-----END RSA PRIVATE KEY-----';
                }

                return $RSAPrivateKey;
        }
    }

    /**
     * Convert a public key to the appropriate format
     *
     * @access private
     * @see setPublicKeyFormat()
     * @param String $RSAPrivateKey
     * @return String
     */
    function _convertPublicKey($n, $e)
    {
        $signed = $this->publicKeyFormat != CRYPT_RSA_PUBLIC_FORMAT_XML;

        $modulus = $n->toBytes($signed);
        $publicExponent = $e->toBytes($signed);

        switch ($this->publicKeyFormat) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                return array('e' => $e->copy(), 'n' => $n->copy());
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                return "<RSAKeyValue>\r\n" .
                       '  <Modulus>' . base64_encode($modulus) . "</Modulus>\r\n" .
                       '  <Exponent>' . base64_encode($publicExponent) . "</Exponent>\r\n" .
                       '</RSAKeyValue>';
                break;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                // from <http://tools.ietf.org/html/rfc4253#page-15>:
                // string    "ssh-rsa"
                // mpint     e
                // mpint     n
                $RSAPublicKey = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publicExponent), $publicExponent, strlen($modulus), $modulus);
                $RSAPublicKey = 'ssh-rsa ' . base64_encode($RSAPublicKey) . ' ' . $this->comment;

                return $RSAPublicKey;
            default: // eg. CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW or CRYPT_RSA_PUBLIC_FORMAT_PKCS1
                // from <http://tools.ietf.org/html/rfc3447#appendix-A.1.1>:
                // RSAPublicKey ::= SEQUENCE {
                //     modulus           INTEGER,  -- n
                //     publicExponent    INTEGER   -- e
                // }
                $components = array(
                    'modulus' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($modulus)), $modulus),
                    'publicExponent' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($publicExponent)), $publicExponent)
                );

                $RSAPublicKey = pack('Ca*a*a*',
                    CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($components['modulus']) + strlen($components['publicExponent'])),
                    $components['modulus'], $components['publicExponent']
                );

                if ($this->publicKeyFormat == CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW) {
                    $RSAPublicKey = "-----BEGIN RSA PUBLIC KEY-----\r\n" .
                                    chunk_split(base64_encode($RSAPublicKey), 64) .
                                    '-----END RSA PUBLIC KEY-----';
                } else {
                    // sequence(oid(1.2.840.113549.1.1.1), null)) = rsaEncryption.
                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
                    $RSAPublicKey = chr(0) . $RSAPublicKey;
                    $RSAPublicKey = chr(3) . $this->_encodeLength(strlen($RSAPublicKey)) . $RSAPublicKey;

                    $RSAPublicKey = pack('Ca*a*',
                        CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($rsaOID . $RSAPublicKey)), $rsaOID . $RSAPublicKey
                    );

                    $RSAPublicKey = "-----BEGIN PUBLIC KEY-----\r\n" .
                                     chunk_split(base64_encode($RSAPublicKey), 64) .
                                     '-----END PUBLIC KEY-----';
                }

                return $RSAPublicKey;
        }
    }

    /**
     * Break a public or private key down into its constituant components
     *
     * @access private
     * @see _convertPublicKey()
     * @see _convertPrivateKey()
     * @param String $key
     * @param Integer $type
     * @return Array
     */
    function _parseKey($key, $type)
    {
        if ($type != CRYPT_RSA_PUBLIC_FORMAT_RAW && !is_string($key)) {
            return false;
        }

        switch ($type) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                if (!is_array($key)) {
                    return false;
                }
                $components = array();
                switch (true) {
                    case isset($key['e']):
                        $components['publicExponent'] = $key['e']->copy();
                        break;
                    case isset($key['exponent']):
                        $components['publicExponent'] = $key['exponent']->copy();
                        break;
                    case isset($key['publicExponent']):
                        $components['publicExponent'] = $key['publicExponent']->copy();
                        break;
                    case isset($key[0]):
                        $components['publicExponent'] = $key[0]->copy();
                }
                switch (true) {
                    case isset($key['n']):
                        $components['modulus'] = $key['n']->copy();
                        break;
                    case isset($key['modulo']):
                        $components['modulus'] = $key['modulo']->copy();
                        break;
                    case isset($key['modulus']):
                        $components['modulus'] = $key['modulus']->copy();
                        break;
                    case isset($key[1]):
                        $components['modulus'] = $key[1]->copy();
                }
                return isset($components['modulus']) && isset($components['publicExponent']) ? $components : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS8:
            case CRYPT_RSA_PUBLIC_FORMAT_PKCS1:
                /* Although PKCS#1 proposes a format that public and private keys can use, encrypting them is
                   "outside the scope" of PKCS#1.  PKCS#1 then refers you to PKCS#12 and PKCS#15 if you're wanting to
                   protect private keys, however, that's not what OpenSSL* does.  OpenSSL protects private keys by adding
                   two new "fields" to the key - DEK-Info and Proc-Type.  These fields are discussed here:

                   http://tools.ietf.org/html/rfc1421#section-4.6.1.1
                   http://tools.ietf.org/html/rfc1421#section-4.6.1.3

                   DES-EDE3-CBC as an algorithm, however, is not discussed anywhere, near as I can tell.
                   DES-CBC and DES-EDE are discussed in RFC1423, however, DES-EDE3-CBC isn't, nor is its key derivation
                   function.  As is, the definitive authority on this encoding scheme isn't the IETF but rather OpenSSL's
                   own implementation.  ie. the implementation *is* the standard and any bugs that may exist in that
                   implementation are part of the standard, as well.

                   * OpenSSL is the de facto standard.  It's utilized by OpenSSH and other projects */
                if (preg_match('#DEK-Info: (.+),(.+)#', $key, $matches)) {
                    $iv = pack('H*', trim($matches[2]));
                    $symkey = pack('H*', md5($this->password . substr($iv, 0, 8))); // symkey is short for symmetric key
                    $symkey.= pack('H*', md5($symkey . $this->password . substr($iv, 0, 8)));
                    // remove the Proc-Type / DEK-Info sections as they're no longer needed
                    $key = preg_replace('#^(?:Proc-Type|DEK-Info): .*#m', '', $key);
                    $ciphertext = $this->_extractBER($key);
                    if ($ciphertext === false) {
                        $ciphertext = $key;
                    }
                    switch ($matches[1]) {
                        case 'AES-256-CBC':
                            if (!class_exists('Crypt_AES')) {
                                include_once 'Crypt/AES.php';
                            }
                            $crypto = new Crypt_AES();
                            break;
                        case 'AES-128-CBC':
                            if (!class_exists('Crypt_AES')) {
                                include_once 'Crypt/AES.php';
                            }
                            $symkey = substr($symkey, 0, 16);
                            $crypto = new Crypt_AES();
                            break;
                        case 'DES-EDE3-CFB':
                            if (!class_exists('Crypt_TripleDES')) {
                                include_once 'Crypt/TripleDES.php';
                            }
                            $crypto = new Crypt_TripleDES(CRYPT_DES_MODE_CFB);
                            break;
                        case 'DES-EDE3-CBC':
                            if (!class_exists('Crypt_TripleDES')) {
                                include_once 'Crypt/TripleDES.php';
                            }
                            $symkey = substr($symkey, 0, 24);
                            $crypto = new Crypt_TripleDES();
                            break;
                        case 'DES-CBC':
                            if (!class_exists('Crypt_DES')) {
                                include_once 'Crypt/DES.php';
                            }
                            $crypto = new Crypt_DES();
                            break;
                        default:
                            return false;
                    }
                    $crypto->setKey($symkey);
                    $crypto->setIV($iv);
                    $decoded = $crypto->decrypt($ciphertext);
                } else {
                    $decoded = $this->_extractBER($key);
                }

                if ($decoded !== false) {
                    $key = $decoded;
                }

                $components = array();

                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                    return false;
                }
                if ($this->_decodeLength($key) != strlen($key)) {
                    return false;
                }

                $tag = ord($this->_string_shift($key));
                /* intended for keys for which OpenSSL's asn1parse returns the following:

                    0:d=0  hl=4 l= 631 cons: SEQUENCE
                    4:d=1  hl=2 l=   1 prim:  INTEGER           :00
                    7:d=1  hl=2 l=  13 cons:  SEQUENCE
                    9:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
                   20:d=2  hl=2 l=   0 prim:   NULL
                   22:d=1  hl=4 l= 609 prim:  OCTET STRING

                   ie. PKCS8 keys*/

                if ($tag == CRYPT_RSA_ASN1_INTEGER && substr($key, 0, 3) == "\x01\x00\x30") {
                    $this->_string_shift($key, 3);
                    $tag = CRYPT_RSA_ASN1_SEQUENCE;
                }

                if ($tag == CRYPT_RSA_ASN1_SEQUENCE) {
                    $temp = $this->_string_shift($key, $this->_decodeLength($key));
                    if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_OBJECT) {
                        return false;
                    }
                    $length = $this->_decodeLength($temp);
                    switch ($this->_string_shift($temp, $length)) {
                        case "\x2a\x86\x48\x86\xf7\x0d\x01\x01\x01": // rsaEncryption
                            break;
                        case "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x03": // pbeWithMD5AndDES-CBC
                            /*
                               PBEParameter ::= SEQUENCE {
                                   salt OCTET STRING (SIZE(8)),
                                   iterationCount INTEGER }
                            */
                            if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_SEQUENCE) {
                                return false;
                            }
                            if ($this->_decodeLength($temp) != strlen($temp)) {
                                return false;
                            }
                            $this->_string_shift($temp); // assume it's an octet string
                            $salt = $this->_string_shift($temp, $this->_decodeLength($temp));
                            if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_INTEGER) {
                                return false;
                            }
                            $this->_decodeLength($temp);
                            list(, $iterationCount) = unpack('N', str_pad($temp, 4, chr(0), STR_PAD_LEFT));
                            $this->_string_shift($key); // assume it's an octet string
                            $length = $this->_decodeLength($key);
                            if (strlen($key) != $length) {
                                return false;
                            }

                            if (!class_exists('Crypt_DES')) {
                                include_once 'Crypt/DES.php';
                            }
                            $crypto = new Crypt_DES();
                            $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
                            $key = $crypto->decrypt($key);
                            if ($key === false) {
                                return false;
                            }
                            return $this->_parseKey($key, CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
                        default:
                            return false;
                    }
                    /* intended for keys for which OpenSSL's asn1parse returns the following:

                        0:d=0  hl=4 l= 290 cons: SEQUENCE
                        4:d=1  hl=2 l=  13 cons:  SEQUENCE
                        6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
                       17:d=2  hl=2 l=   0 prim:   NULL
                       19:d=1  hl=4 l= 271 prim:  BIT STRING */
                    $tag = ord($this->_string_shift($key)); // skip over the BIT STRING / OCTET STRING tag
                    $this->_decodeLength($key); // skip over the BIT STRING / OCTET STRING length
                    // "The initial octet shall encode, as an unsigned binary integer wtih bit 1 as the least significant bit, the number of
                    //  unused bits in the final subsequent octet. The number shall be in the range zero to seven."
                    //  -- http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (section 8.6.2.2)
                    if ($tag == CRYPT_RSA_ASN1_BITSTRING) {
                        $this->_string_shift($key);
                    }
                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                        return false;
                    }
                    if ($this->_decodeLength($key) != strlen($key)) {
                        return false;
                    }
                    $tag = ord($this->_string_shift($key));
                }
                if ($tag != CRYPT_RSA_ASN1_INTEGER) {
                    return false;
                }

                $length = $this->_decodeLength($key);
                $temp = $this->_string_shift($key, $length);
                if (strlen($temp) != 1 || ord($temp) > 2) {
                    $components['modulus'] = new Math_BigInteger($temp, 256);
                    $this->_string_shift($key); // skip over CRYPT_RSA_ASN1_INTEGER
                    $length = $this->_decodeLength($key);
                    $components[$type == CRYPT_RSA_PUBLIC_FORMAT_PKCS1 ? 'publicExponent' : 'privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);

                    return $components;
                }
                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_INTEGER) {
                    return false;
                }
                $length = $this->_decodeLength($key);
                $components['modulus'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['publicExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['primes'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), 256));
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['exponents'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), 256));
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['coefficients'] = array(2 => new Math_BigInteger($this->_string_shift($key, $length), 256));

                if (!empty($key)) {
                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                        return false;
                    }
                    $this->_decodeLength($key);
                    while (!empty($key)) {
                        if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                            return false;
                        }
                        $this->_decodeLength($key);
                        $key = substr($key, 1);
                        $length = $this->_decodeLength($key);
                        $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                        $this->_string_shift($key);
                        $length = $this->_decodeLength($key);
                        $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                        $this->_string_shift($key);
                        $length = $this->_decodeLength($key);
                        $components['coefficients'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                    }
                }

                return $components;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $parts = explode(' ', $key, 3);

                $key = isset($parts[1]) ? base64_decode($parts[1]) : false;
                if ($key === false) {
                    return false;
                }

                $comment = isset($parts[2]) ? $parts[2] : false;

                $cleanup = substr($key, 0, 11) == "\0\0\0\7ssh-rsa";

                if (strlen($key) <= 4) {
                    return false;
                }
                extract(unpack('Nlength', $this->_string_shift($key, 4)));
                $publicExponent = new Math_BigInteger($this->_string_shift($key, $length), -256);
                if (strlen($key) <= 4) {
                    return false;
                }
                extract(unpack('Nlength', $this->_string_shift($key, 4)));
                $modulus = new Math_BigInteger($this->_string_shift($key, $length), -256);

                if ($cleanup && strlen($key)) {
                    if (strlen($key) <= 4) {
                        return false;
                    }
                    extract(unpack('Nlength', $this->_string_shift($key, 4)));
                    $realModulus = new Math_BigInteger($this->_string_shift($key, $length), -256);
                    return strlen($key) ? false : array(
                        'modulus' => $realModulus,
                        'publicExponent' => $modulus,
                        'comment' => $comment
                    );
                } else {
                    return strlen($key) ? false : array(
                        'modulus' => $modulus,
                        'publicExponent' => $publicExponent,
                        'comment' => $comment
                    );
                }
            // http://www.w3.org/TR/xmldsig-core/#sec-RSAKeyValue
            // http://en.wikipedia.org/wiki/XML_Signature
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                $this->components = array();

                $xml = xml_parser_create('UTF-8');
                xml_set_object($xml, $this);
                xml_set_element_handler($xml, '_start_element_handler', '_stop_element_handler');
                xml_set_character_data_handler($xml, '_data_handler');
                // add <xml></xml> to account for "dangling" tags like <BitStrength>...</BitStrength> that are sometimes added
                if (!xml_parse($xml, '<xml>' . $key . '</xml>')) {
                    return false;
                }

                return isset($this->components['modulus']) && isset($this->components['publicExponent']) ? $this->components : false;
            // from PuTTY's SSHPUBK.C
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                $components = array();
                $key = preg_split('#\r\n|\r|\n#', $key);
                $type = trim(preg_replace('#PuTTY-User-Key-File-2: (.+)#', '$1', $key[0]));
                if ($type != 'ssh-rsa') {
                    return false;
                }
                $encryption = trim(preg_replace('#Encryption: (.+)#', '$1', $key[1]));
                $comment = trim(preg_replace('#Comment: (.+)#', '$1', $key[2]));

                $publicLength = trim(preg_replace('#Public-Lines: (\d+)#', '$1', $key[3]));
                $public = base64_decode(implode('', array_map('trim', array_slice($key, 4, $publicLength))));
                $public = substr($public, 11);
                extract(unpack('Nlength', $this->_string_shift($public, 4)));
                $components['publicExponent'] = new Math_BigInteger($this->_string_shift($public, $length), -256);
                extract(unpack('Nlength', $this->_string_shift($public, 4)));
                $components['modulus'] = new Math_BigInteger($this->_string_shift($public, $length), -256);

                $privateLength = trim(preg_replace('#Private-Lines: (\d+)#', '$1', $key[$publicLength + 4]));
                $private = base64_decode(implode('', array_map('trim', array_slice($key, $publicLength + 5, $privateLength))));

                switch ($encryption) {
                    case 'aes256-cbc':
                        if (!class_exists('Crypt_AES')) {
                            include_once 'Crypt/AES.php';
                        }
                        $symkey = '';
                        $sequence = 0;
                        while (strlen($symkey) < 32) {
                            $temp = pack('Na*', $sequence++, $this->password);
                            $symkey.= pack('H*', sha1($temp));
                        }
                        $symkey = substr($symkey, 0, 32);
                        $crypto = new Crypt_AES();
                }

                if ($encryption != 'none') {
                    $crypto->setKey($symkey);
                    $crypto->disablePadding();
                    $private = $crypto->decrypt($private);
                    if ($private === false) {
                        return false;
                    }
                }

                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['privateExponent'] = new Math_BigInteger($this->_string_shift($private, $length), -256);
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['primes'] = array(1 => new Math_BigInteger($this->_string_shift($private, $length), -256));
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['primes'][] = new Math_BigInteger($this->_string_shift($private, $length), -256);

                $temp = $components['primes'][1]->subtract($this->one);
                $components['exponents'] = array(1 => $components['publicExponent']->modInverse($temp));
                $temp = $components['primes'][2]->subtract($this->one);
                $components['exponents'][] = $components['publicExponent']->modInverse($temp);

                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['coefficients'] = array(2 => new Math_BigInteger($this->_string_shift($private, $length), -256));

                return $components;
        }
    }

    /**
     * Returns the key size
     *
     * More specifically, this returns the size of the modulo in bits.
     *
     * @access public
     * @return Integer
     */
    function getSize()
    {
        return !isset($this->modulus) ? 0 : strlen($this->modulus->toBits());
    }

    /**
     * Start Element Handler
     *
     * Called by xml_set_element_handler()
     *
     * @access private
     * @param Resource $parser
     * @param String $name
     * @param Array $attribs
     */
    function _start_element_handler($parser, $name, $attribs)
    {
        //$name = strtoupper($name);
        switch ($name) {
            case 'MODULUS':
                $this->current = &$this->components['modulus'];
                break;
            case 'EXPONENT':
                $this->current = &$this->components['publicExponent'];
                break;
            case 'P':
                $this->current = &$this->components['primes'][1];
                break;
            case 'Q':
                $this->current = &$this->components['primes'][2];
                break;
            case 'DP':
                $this->current = &$this->components['exponents'][1];
                break;
            case 'DQ':
                $this->current = &$this->components['exponents'][2];
                break;
            case 'INVERSEQ':
                $this->current = &$this->components['coefficients'][2];
                break;
            case 'D':
                $this->current = &$this->components['privateExponent'];
        }
        $this->current = '';
    }

    /**
     * Stop Element Handler
     *
     * Called by xml_set_element_handler()
     *
     * @access private
     * @param Resource $parser
     * @param String $name
     */
    function _stop_element_handler($parser, $name)
    {
        if (isset($this->current)) {
            $this->current = new Math_BigInteger(base64_decode($this->current), 256);
            unset($this->current);
        }
    }

    /**
     * Data Handler
     *
     * Called by xml_set_character_data_handler()
     *
     * @access private
     * @param Resource $parser
     * @param String $data
     */
    function _data_handler($parser, $data)
    {
        if (!isset($this->current) || is_object($this->current)) {
            return;
        }
        $this->current.= trim($data);
    }

    /**
     * Loads a public or private key
     *
     * Returns true on success and false on failure (ie. an incorrect password was provided or the key was malformed)
     *
     * @access public
     * @param String $key
     * @param Integer $type optional
     */
    function loadKey($key, $type = false)
    {
        if (is_object($key) && strtolower(get_class($key)) == 'crypt_rsa') {
            $this->privateKeyFormat = $key->privateKeyFormat;
            $this->publicKeyFormat = $key->publicKeyFormat;
            $this->k = $key->k;
            $this->hLen = $key->hLen;
            $this->sLen = $key->sLen;
            $this->mgfHLen = $key->mgfHLen;
            $this->encryptionMode = $key->encryptionMode;
            $this->signatureMode = $key->signatureMode;
            $this->password = $key->password;
            $this->configFile = $key->configFile;
            $this->comment = $key->comment;

            if (is_object($key->hash)) {
                $this->hash = new Crypt_Hash($key->hash->getHash());
            }
            if (is_object($key->mgfHash)) {
                $this->mgfHash = new Crypt_Hash($key->mgfHash->getHash());
            }

            if (is_object($key->modulus)) {
                $this->modulus = $key->modulus->copy();
            }
            if (is_object($key->exponent)) {
                $this->exponent = $key->exponent->copy();
            }
            if (is_object($key->publicExponent)) {
                $this->publicExponent = $key->publicExponent->copy();
            }

            $this->primes = array();
            $this->exponents = array();
            $this->coefficients = array();

            foreach ($this->primes as $prime) {
                $this->primes[] = $prime->copy();
            }
            foreach ($this->exponents as $exponent) {
                $this->exponents[] = $exponent->copy();
            }
            foreach ($this->coefficients as $coefficient) {
                $this->coefficients[] = $coefficient->copy();
            }

            return true;
        }

        if ($type === false) {
            $types = array(
                CRYPT_RSA_PUBLIC_FORMAT_RAW,
                CRYPT_RSA_PRIVATE_FORMAT_PKCS1,
                CRYPT_RSA_PRIVATE_FORMAT_XML,
                CRYPT_RSA_PRIVATE_FORMAT_PUTTY,
                CRYPT_RSA_PUBLIC_FORMAT_OPENSSH
            );
            foreach ($types as $type) {
                $components = $this->_parseKey($key, $type);
                if ($components !== false) {
                    break;
                }
            }

        } else {
            $components = $this->_parseKey($key, $type);
        }

        if ($components === false) {
            return false;
        }

        if (isset($components['comment']) && $components['comment'] !== false) {
            $this->comment = $components['comment'];
        }
        $this->modulus = $components['modulus'];
        $this->k = strlen($this->modulus->toBytes());
        $this->exponent = isset($components['privateExponent']) ? $components['privateExponent'] : $components['publicExponent'];
        if (isset($components['primes'])) {
            $this->primes = $components['primes'];
            $this->exponents = $components['exponents'];
            $this->coefficients = $components['coefficients'];
            $this->publicExponent = $components['publicExponent'];
        } else {
            $this->primes = array();
            $this->exponents = array();
            $this->coefficients = array();
            $this->publicExponent = false;
        }

        switch ($type) {
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                $this->setPublicKey();
                break;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
                switch (true) {
                    case strpos($key, '-BEGIN PUBLIC KEY-') !== false:
                    case strpos($key, '-BEGIN RSA PUBLIC KEY-') !== false:
                        $this->setPublicKey();
                }
        }

        return true;
    }

    /**
     * Sets the password
     *
     * Private keys can be encrypted with a password.  To unset the password, pass in the empty string or false.
     * Or rather, pass in $password such that empty($password) && !is_string($password) is true.
     *
     * @see createKey()
     * @see loadKey()
     * @access public
     * @param String $password
     */
    function setPassword($password = false)
    {
        $this->password = $password;
    }

    /**
     * Defines the public key
     *
     * Some private key formats define the public exponent and some don't.  Those that don't define it are problematic when
     * used in certain contexts.  For example, in SSH-2, RSA authentication works by sending the public key along with a
     * message signed by the private key to the server.  The SSH-2 server looks the public key up in an index of public keys
     * and if it's present then proceeds to verify the signature.  Problem is, if your private key doesn't include the public
     * exponent this won't work unless you manually add the public exponent. phpseclib tries to guess if the key being used
     * is the public key but in the event that it guesses incorrectly you might still want to explicitly set the key as being
     * public.
     *
     * Do note that when a new key is loaded the index will be cleared.
     *
     * Returns true on success, false on failure
     *
     * @see getPublicKey()
     * @access public
     * @param String $key optional
     * @param Integer $type optional
     * @return Boolean
     */
    function setPublicKey($key = false, $type = false)
    {
        // if a public key has already been loaded return false
        if (!empty($this->publicExponent)) {
            return false;
        }

        if ($key === false && !empty($this->modulus)) {
            $this->publicExponent = $this->exponent;
            return true;
        }

        if ($type === false) {
            $types = array(
                CRYPT_RSA_PUBLIC_FORMAT_RAW,
                CRYPT_RSA_PUBLIC_FORMAT_PKCS1,
                CRYPT_RSA_PUBLIC_FORMAT_XML,
                CRYPT_RSA_PUBLIC_FORMAT_OPENSSH
            );
            foreach ($types as $type) {
                $components = $this->_parseKey($key, $type);
                if ($components !== false) {
                    break;
                }
            }
        } else {
            $components = $this->_parseKey($key, $type);
        }

        if ($components === false) {
            return false;
        }

        if (empty($this->modulus) || !$this->modulus->equals($components['modulus'])) {
            $this->modulus = $components['modulus'];
            $this->exponent = $this->publicExponent = $components['publicExponent'];
            return true;
        }

        $this->publicExponent = $components['publicExponent'];

        return true;
    }

    /**
     * Defines the private key
     *
     * If phpseclib guessed a private key was a public key and loaded it as such it might be desirable to force
     * phpseclib to treat the key as a private key. This function will do that.
     *
     * Do note that when a new key is loaded the index will be cleared.
     *
     * Returns true on success, false on failure
     *
     * @see getPublicKey()
     * @access public
     * @param String $key optional
     * @param Integer $type optional
     * @return Boolean
     */
    function setPrivateKey($key = false, $type = false)
    {
        if ($key === false && !empty($this->publicExponent)) {
            unset($this->publicExponent);
            return true;
        }

        $rsa = new Crypt_RSA();
        if (!$rsa->loadKey($key, $type)) {
            return false;
        }
        unset($rsa->publicExponent);

        // don't overwrite the old key if the new key is invalid
        $this->loadKey($rsa);
        return true;
    }

    /**
     * Returns the public key
     *
     * The public key is only returned under two circumstances - if the private key had the public key embedded within it
     * or if the public key was set via setPublicKey().  If the currently loaded key is supposed to be the public key this
     * function won't return it since this library, for the most part, doesn't distinguish between public and private keys.
     *
     * @see getPublicKey()
     * @access public
     * @param String $key
     * @param Integer $type optional
     */
    function getPublicKey($type = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (empty($this->modulus) || empty($this->publicExponent)) {
            return false;
        }

        $oldFormat = $this->publicKeyFormat;
        $this->publicKeyFormat = $type;
        $temp = $this->_convertPublicKey($this->modulus, $this->publicExponent);
        $this->publicKeyFormat = $oldFormat;
        return $temp;
    }

    /**
     * Returns the private key
     *
     * The private key is only returned if the currently loaded key contains the constituent prime numbers.
     *
     * @see getPublicKey()
     * @access public
     * @param String $key
     * @param Integer $type optional
     */
    function getPrivateKey($type = CRYPT_RSA_PUBLIC_FORMAT_PKCS1)
    {
        if (empty($this->primes)) {
            return false;
        }

        $oldFormat = $this->privateKeyFormat;
        $this->privateKeyFormat = $type;
        $temp = $this->_convertPrivateKey($this->modulus, $this->publicExponent, $this->exponent, $this->primes, $this->exponents, $this->coefficients);
        $this->privateKeyFormat = $oldFormat;
        return $temp;
    }

    /**
     * Returns a minimalistic private key
     *
     * Returns the private key without the prime number constituants.  Structurally identical to a public key that
     * hasn't been set as the public key
     *
     * @see getPrivateKey()
     * @access private
     * @param String $key
     * @param Integer $type optional
     */
    function _getPrivatePublicKey($mode = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }

        $oldFormat = $this->publicKeyFormat;
        $this->publicKeyFormat = $mode;
        $temp = $this->_convertPublicKey($this->modulus, $this->exponent);
        $this->publicKeyFormat = $oldFormat;
        return $temp;
    }

    /**
     *  __toString() magic method
     *
     * @access public
     */
    function __toString()
    {
        $key = $this->getPrivateKey($this->privateKeyFormat);
        if ($key !== false) {
            return $key;
        }
        $key = $this->_getPrivatePublicKey($this->publicKeyFormat);
        return $key !== false ? $key : '';
    }

    /**
     *  __clone() magic method
     *
     * @access public
     */
    function __clone()
    {
        $key = new Crypt_RSA();
        $key->loadKey($this);
        return $key;
    }

    /**
     * Generates the smallest and largest numbers requiring $bits bits
     *
     * @access private
     * @param Integer $bits
     * @return Array
     */
    function _generateMinMax($bits)
    {
        $bytes = $bits >> 3;
        $min = str_repeat(chr(0), $bytes);
        $max = str_repeat(chr(0xFF), $bytes);
        $msb = $bits & 7;
        if ($msb) {
            $min = chr(1 << ($msb - 1)) . $min;
            $max = chr((1 << $msb) - 1) . $max;
        } else {
            $min[0] = chr(0x80);
        }

        return array(
            'min' => new Math_BigInteger($min, 256),
            'max' => new Math_BigInteger($max, 256)
        );
    }

    /**
     * DER-decode the length
     *
     * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
     *
     * @access private
     * @param String $string
     * @return Integer
     */
    function _decodeLength(&$string)
    {
        $length = ord($this->_string_shift($string));
        if ( $length & 0x80 ) { // definite length, long form
            $length&= 0x7F;
            $temp = $this->_string_shift($string, $length);
            list(, $length) = unpack('N', substr(str_pad($temp, 4, chr(0), STR_PAD_LEFT), -4));
        }
        return $length;
    }

    /**
     * DER-encode the length
     *
     * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
     *
     * @access private
     * @param Integer $length
     * @return String
     */
    function _encodeLength($length)
    {
        if ($length <= 0x7F) {
            return chr($length);
        }

        $temp = ltrim(pack('N', $length), chr(0));
        return pack('Ca*', 0x80 | strlen($temp), $temp);
    }

    /**
     * String Shift
     *
     * Inspired by array_shift
     *
     * @param String $string
     * @param optional Integer $index
     * @return String
     * @access private
     */
    function _string_shift(&$string, $index = 1)
    {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }

    /**
     * Determines the private key format
     *
     * @see createKey()
     * @access public
     * @param Integer $format
     */
    function setPrivateKeyFormat($format)
    {
        $this->privateKeyFormat = $format;
    }

    /**
     * Determines the public key format
     *
     * @see createKey()
     * @access public
     * @param Integer $format
     */
    function setPublicKeyFormat($format)
    {
        $this->publicKeyFormat = $format;
    }

    /**
     * Determines which hashing function should be used
     *
     * Used with signature production / verification and (if the encryption mode is CRYPT_RSA_ENCRYPTION_OAEP) encryption and
     * decryption.  If $hash isn't supported, sha1 is used.
     *
     * @access public
     * @param String $hash
     */
    function setHash($hash)
    {
        // Crypt_Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
        switch ($hash) {
            case 'md2':
            case 'md5':
            case 'sha1':
            case 'sha256':
            case 'sha384':
            case 'sha512':
                $this->hash = new Crypt_Hash($hash);
                $this->hashName = $hash;
                break;
            default:
                $this->hash = new Crypt_Hash('sha1');
                $this->hashName = 'sha1';
        }
        $this->hLen = $this->hash->getLength();
    }

    /**
     * Determines which hashing function should be used for the mask generation function
     *
     * The mask generation function is used by CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_SIGNATURE_PSS and although it's
     * best if Hash and MGFHash are set to the same thing this is not a requirement.
     *
     * @access public
     * @param String $hash
     */
    function setMGFHash($hash)
    {
        // Crypt_Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
        switch ($hash) {
            case 'md2':
            case 'md5':
            case 'sha1':
            case 'sha256':
            case 'sha384':
            case 'sha512':
                $this->mgfHash = new Crypt_Hash($hash);
                break;
            default:
                $this->mgfHash = new Crypt_Hash('sha1');
        }
        $this->mgfHLen = $this->mgfHash->getLength();
    }

    /**
     * Determines the salt length
     *
     * To quote from {@link http://tools.ietf.org/html/rfc3447#page-38 RFC3447#page-38}:
     *
     *    Typical salt lengths in octets are hLen (the length of the output
     *    of the hash function Hash) and 0.
     *
     * @access public
     * @param Integer $format
     */
    function setSaltLength($sLen)
    {
        $this->sLen = $sLen;
    }

    /**
     * Integer-to-Octet-String primitive
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-4.1 RFC3447#section-4.1}.
     *
     * @access private
     * @param Math_BigInteger $x
     * @param Integer $xLen
     * @return String
     */
    function _i2osp($x, $xLen)
    {
        $x = $x->toBytes();
        if (strlen($x) > $xLen) {
            user_error('Integer too large');
            return false;
        }
        return str_pad($x, $xLen, chr(0), STR_PAD_LEFT);
    }

    /**
     * Octet-String-to-Integer primitive
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-4.2 RFC3447#section-4.2}.
     *
     * @access private
     * @param String $x
     * @return Math_BigInteger
     */
    function _os2ip($x)
    {
        return new Math_BigInteger($x, 256);
    }

    /**
     * Exponentiate with or without Chinese Remainder Theorem
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.1 RFC3447#section-5.1.2}.
     *
     * @access private
     * @param Math_BigInteger $x
     * @return Math_BigInteger
     */
    function _exponentiate($x)
    {
        if (empty($this->primes) || empty($this->coefficients) || empty($this->exponents)) {
            return $x->modPow($this->exponent, $this->modulus);
        }

        $num_primes = count($this->primes);

        if (defined('CRYPT_RSA_DISABLE_BLINDING')) {
            $m_i = array(
                1 => $x->modPow($this->exponents[1], $this->primes[1]),
                2 => $x->modPow($this->exponents[2], $this->primes[2])
            );
            $h = $m_i[1]->subtract($m_i[2]);
            $h = $h->multiply($this->coefficients[2]);
            list(, $h) = $h->divide($this->primes[1]);
            $m = $m_i[2]->add($h->multiply($this->primes[2]));

            $r = $this->primes[1];
            for ($i = 3; $i <= $num_primes; $i++) {
                $m_i = $x->modPow($this->exponents[$i], $this->primes[$i]);

                $r = $r->multiply($this->primes[$i - 1]);

                $h = $m_i->subtract($m);
                $h = $h->multiply($this->coefficients[$i]);
                list(, $h) = $h->divide($this->primes[$i]);

                $m = $m->add($r->multiply($h));
            }
        } else {
            $smallest = $this->primes[1];
            for ($i = 2; $i <= $num_primes; $i++) {
                if ($smallest->compare($this->primes[$i]) > 0) {
                    $smallest = $this->primes[$i];
                }
            }

            $one = new Math_BigInteger(1);

            $r = $one->random($one, $smallest->subtract($one));

            $m_i = array(
                1 => $this->_blind($x, $r, 1),
                2 => $this->_blind($x, $r, 2)
            );
            $h = $m_i[1]->subtract($m_i[2]);
            $h = $h->multiply($this->coefficients[2]);
            list(, $h) = $h->divide($this->primes[1]);
            $m = $m_i[2]->add($h->multiply($this->primes[2]));

            $r = $this->primes[1];
            for ($i = 3; $i <= $num_primes; $i++) {
                $m_i = $this->_blind($x, $r, $i);

                $r = $r->multiply($this->primes[$i - 1]);

                $h = $m_i->subtract($m);
                $h = $h->multiply($this->coefficients[$i]);
                list(, $h) = $h->divide($this->primes[$i]);

                $m = $m->add($r->multiply($h));
            }
        }

        return $m;
    }

    /**
     * Performs RSA Blinding
     *
     * Protects against timing attacks by employing RSA Blinding.
     * Returns $x->modPow($this->exponents[$i], $this->primes[$i])
     *
     * @access private
     * @param Math_BigInteger $x
     * @param Math_BigInteger $r
     * @param Integer $i
     * @return Math_BigInteger
     */
    function _blind($x, $r, $i)
    {
        $x = $x->multiply($r->modPow($this->publicExponent, $this->primes[$i]));
        $x = $x->modPow($this->exponents[$i], $this->primes[$i]);

        $r = $r->modInverse($this->primes[$i]);
        $x = $x->multiply($r);
        list(, $x) = $x->divide($this->primes[$i]);

        return $x;
    }

    /**
     * Performs blinded RSA equality testing
     *
     * Protects against a particular type of timing attack described.
     *
     * See {@link http://codahale.com/a-lesson-in-timing-attacks/ A Lesson In Timing Attacks (or, Don't use MessageDigest.isEquals)}
     *
     * Thanks for the heads up singpolyma!
     *
     * @access private
     * @param String $x
     * @param String $y
     * @return Boolean
     */
    function _equals($x, $y)
    {
        if (strlen($x) != strlen($y)) {
            return false;
        }

        $result = 0;
        for ($i = 0; $i < strlen($x); $i++) {
            $result |= ord($x[$i]) ^ ord($y[$i]);
        }

        return $result == 0;
    }

    /**
     * RSAEP
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.1 RFC3447#section-5.1.1}.
     *
     * @access private
     * @param Math_BigInteger $m
     * @return Math_BigInteger
     */
    function _rsaep($m)
    {
        if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
            user_error('Message representative out of range');
            return false;
        }
        return $this->_exponentiate($m);
    }

    /**
     * RSADP
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.2 RFC3447#section-5.1.2}.
     *
     * @access private
     * @param Math_BigInteger $c
     * @return Math_BigInteger
     */
    function _rsadp($c)
    {
        if ($c->compare($this->zero) < 0 || $c->compare($this->modulus) > 0) {
            user_error('Ciphertext representative out of range');
            return false;
        }
        return $this->_exponentiate($c);
    }

    /**
     * RSASP1
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-5.2.1 RFC3447#section-5.2.1}.
     *
     * @access private
     * @param Math_BigInteger $m
     * @return Math_BigInteger
     */
    function _rsasp1($m)
    {
        if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
            user_error('Message representative out of range');
            return false;
        }
        return $this->_exponentiate($m);
    }

    /**
     * RSAVP1
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-5.2.2 RFC3447#section-5.2.2}.
     *
     * @access private
     * @param Math_BigInteger $s
     * @return Math_BigInteger
     */
    function _rsavp1($s)
    {
        if ($s->compare($this->zero) < 0 || $s->compare($this->modulus) > 0) {
            user_error('Signature representative out of range');
            return false;
        }
        return $this->_exponentiate($s);
    }

    /**
     * MGF1
     *
     * See {@link http://tools.ietf.org/html/rfc3447#appendix-B.2.1 RFC3447#appendix-B.2.1}.
     *
     * @access private
     * @param String $mgfSeed
     * @param Integer $mgfLen
     * @return String
     */
    function _mgf1($mgfSeed, $maskLen)
    {
        // if $maskLen would yield strings larger than 4GB, PKCS#1 suggests a "Mask too long" error be output.

        $t = '';
        $count = ceil($maskLen / $this->mgfHLen);
        for ($i = 0; $i < $count; $i++) {
            $c = pack('N', $i);
            $t.= $this->mgfHash->hash($mgfSeed . $c);
        }

        return substr($t, 0, $maskLen);
    }

    /**
     * RSAES-OAEP-ENCRYPT
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-7.1.1 RFC3447#section-7.1.1} and
     * {http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding OAES}.
     *
     * @access private
     * @param String $m
     * @param String $l
     * @return String
     */
    function _rsaes_oaep_encrypt($m, $l = '')
    {
        $mLen = strlen($m);

        // Length checking

        // if $l is larger than two million terrabytes and you're using sha1, PKCS#1 suggests a "Label too long" error
        // be output.

        if ($mLen > $this->k - 2 * $this->hLen - 2) {
            user_error('Message too long');
            return false;
        }

        // EME-OAEP encoding

        $lHash = $this->hash->hash($l);
        $ps = str_repeat(chr(0), $this->k - $mLen - 2 * $this->hLen - 2);
        $db = $lHash . $ps . chr(1) . $m;
        $seed = crypt_random_string($this->hLen);
        $dbMask = $this->_mgf1($seed, $this->k - $this->hLen - 1);
        $maskedDB = $db ^ $dbMask;
        $seedMask = $this->_mgf1($maskedDB, $this->hLen);
        $maskedSeed = $seed ^ $seedMask;
        $em = chr(0) . $maskedSeed . $maskedDB;

        // RSA encryption

        $m = $this->_os2ip($em);
        $c = $this->_rsaep($m);
        $c = $this->_i2osp($c, $this->k);

        // Output the ciphertext C

        return $c;
    }

    /**
     * RSAES-OAEP-DECRYPT
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-7.1.2 RFC3447#section-7.1.2}.  The fact that the error
     * messages aren't distinguishable from one another hinders debugging, but, to quote from RFC3447#section-7.1.2:
     *
     *    Note.  Care must be taken to ensure that an opponent cannot
     *    distinguish the different error conditions in Step 3.g, whether by
     *    error message or timing, or, more generally, learn partial
     *    information about the encoded message EM.  Otherwise an opponent may
     *    be able to obtain useful information about the decryption of the
     *    ciphertext C, leading to a chosen-ciphertext attack such as the one
     *    observed by Manger [36].
     *
     * As for $l...  to quote from {@link http://tools.ietf.org/html/rfc3447#page-17 RFC3447#page-17}:
     *
     *    Both the encryption and the decryption operations of RSAES-OAEP take
     *    the value of a label L as input.  In this version of PKCS #1, L is
     *    the empty string; other uses of the label are outside the scope of
     *    this document.
     *
     * @access private
     * @param String $c
     * @param String $l
     * @return String
     */
    function _rsaes_oaep_decrypt($c, $l = '')
    {
        // Length checking

        // if $l is larger than two million terrabytes and you're using sha1, PKCS#1 suggests a "Label too long" error
        // be output.

        if (strlen($c) != $this->k || $this->k < 2 * $this->hLen + 2) {
            user_error('Decryption error');
            return false;
        }

        // RSA decryption

        $c = $this->_os2ip($c);
        $m = $this->_rsadp($c);
        if ($m === false) {
            user_error('Decryption error');
            return false;
        }
        $em = $this->_i2osp($m, $this->k);

        // EME-OAEP decoding

        $lHash = $this->hash->hash($l);
        $y = ord($em[0]);
        $maskedSeed = substr($em, 1, $this->hLen);
        $maskedDB = substr($em, $this->hLen + 1);
        $seedMask = $this->_mgf1($maskedDB, $this->hLen);
        $seed = $maskedSeed ^ $seedMask;
        $dbMask = $this->_mgf1($seed, $this->k - $this->hLen - 1);
        $db = $maskedDB ^ $dbMask;
        $lHash2 = substr($db, 0, $this->hLen);
        $m = substr($db, $this->hLen);
        if ($lHash != $lHash2) {
            user_error('Decryption error');
            return false;
        }
        $m = ltrim($m, chr(0));
        if (ord($m[0]) != 1) {
            user_error('Decryption error');
            return false;
        }

        // Output the message M

        return substr($m, 1);
    }

    /**
     * RSAES-PKCS1-V1_5-ENCRYPT
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-7.2.1 RFC3447#section-7.2.1}.
     *
     * @access private
     * @param String $m
     * @return String
     */
    function _rsaes_pkcs1_v1_5_encrypt($m)
    {
        $mLen = strlen($m);

        // Length checking

        if ($mLen > $this->k - 11) {
            user_error('Message too long');
            return false;
        }

        // EME-PKCS1-v1_5 encoding

        $psLen = $this->k - $mLen - 3;
        $ps = '';
        while (strlen($ps) != $psLen) {
            $temp = crypt_random_string($psLen - strlen($ps));
            $temp = str_replace("\x00", '', $temp);
            $ps.= $temp;
        }
        $type = 2;
        // see the comments of _rsaes_pkcs1_v1_5_decrypt() to understand why this is being done
        if (defined('CRYPT_RSA_PKCS15_COMPAT') && (!isset($this->publicExponent) || $this->exponent !== $this->publicExponent)) {
            $type = 1;
            // "The padding string PS shall consist of k-3-||D|| octets. ... for block type 01, they shall have value FF"
            $ps = str_repeat("\xFF", $psLen);
        }
        $em = chr(0) . chr($type) . $ps . chr(0) . $m;

        // RSA encryption
        $m = $this->_os2ip($em);
        $c = $this->_rsaep($m);
        $c = $this->_i2osp($c, $this->k);

        // Output the ciphertext C

        return $c;
    }

    /**
     * RSAES-PKCS1-V1_5-DECRYPT
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-7.2.2 RFC3447#section-7.2.2}.
     *
     * For compatibility purposes, this function departs slightly from the description given in RFC3447.
     * The reason being that RFC2313#section-8.1 (PKCS#1 v1.5) states that ciphertext's encrypted by the
     * private key should have the second byte set to either 0 or 1 and that ciphertext's encrypted by the
     * public key should have the second byte set to 2.  In RFC3447 (PKCS#1 v2.1), the second byte is supposed
     * to be 2 regardless of which key is used.  For compatibility purposes, we'll just check to make sure the
     * second byte is 2 or less.  If it is, we'll accept the decrypted string as valid.
     *
     * As a consequence of this, a private key encrypted ciphertext produced with Crypt_RSA may not decrypt
     * with a strictly PKCS#1 v1.5 compliant RSA implementation.  Public key encrypted ciphertext's should but
     * not private key encrypted ciphertext's.
     *
     * @access private
     * @param String $c
     * @return String
     */
    function _rsaes_pkcs1_v1_5_decrypt($c)
    {
        // Length checking

        if (strlen($c) != $this->k) { // or if k < 11
            user_error('Decryption error');
            return false;
        }

        // RSA decryption

        $c = $this->_os2ip($c);
        $m = $this->_rsadp($c);

        if ($m === false) {
            user_error('Decryption error');
            return false;
        }
        $em = $this->_i2osp($m, $this->k);

        // EME-PKCS1-v1_5 decoding

        if (ord($em[0]) != 0 || ord($em[1]) > 2) {
            user_error('Decryption error');
            return false;
        }

        $ps = substr($em, 2, strpos($em, chr(0), 2) - 2);
        $m = substr($em, strlen($ps) + 3);

        if (strlen($ps) < 8) {
            user_error('Decryption error');
            return false;
        }

        // Output M

        return $m;
    }

    /**
     * EMSA-PSS-ENCODE
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-9.1.1 RFC3447#section-9.1.1}.
     *
     * @access private
     * @param String $m
     * @param Integer $emBits
     */
    function _emsa_pss_encode($m, $emBits)
    {
        // if $m is larger than two million terrabytes and you're using sha1, PKCS#1 suggests a "Label too long" error
        // be output.

        $emLen = ($emBits + 1) >> 3; // ie. ceil($emBits / 8)
        $sLen = $this->sLen == false ? $this->hLen : $this->sLen;

        $mHash = $this->hash->hash($m);
        if ($emLen < $this->hLen + $sLen + 2) {
            user_error('Encoding error');
            return false;
        }

        $salt = crypt_random_string($sLen);
        $m2 = "\0\0\0\0\0\0\0\0" . $mHash . $salt;
        $h = $this->hash->hash($m2);
        $ps = str_repeat(chr(0), $emLen - $sLen - $this->hLen - 2);
        $db = $ps . chr(1) . $salt;
        $dbMask = $this->_mgf1($h, $emLen - $this->hLen - 1);
        $maskedDB = $db ^ $dbMask;
        $maskedDB[0] = ~chr(0xFF << ($emBits & 7)) & $maskedDB[0];
        $em = $maskedDB . $h . chr(0xBC);

        return $em;
    }

    /**
     * EMSA-PSS-VERIFY
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-9.1.2 RFC3447#section-9.1.2}.
     *
     * @access private
     * @param String $m
     * @param String $em
     * @param Integer $emBits
     * @return String
     */
    function _emsa_pss_verify($m, $em, $emBits)
    {
        // if $m is larger than two million terrabytes and you're using sha1, PKCS#1 suggests a "Label too long" error
        // be output.

        $emLen = ($emBits + 1) >> 3; // ie. ceil($emBits / 8);
        $sLen = $this->sLen == false ? $this->hLen : $this->sLen;

        $mHash = $this->hash->hash($m);
        if ($emLen < $this->hLen + $sLen + 2) {
            return false;
        }

        if ($em[strlen($em) - 1] != chr(0xBC)) {
            return false;
        }

        $maskedDB = substr($em, 0, -$this->hLen - 1);
        $h = substr($em, -$this->hLen - 1, $this->hLen);
        $temp = chr(0xFF << ($emBits & 7));
        if ((~$maskedDB[0] & $temp) != $temp) {
            return false;
        }
        $dbMask = $this->_mgf1($h, $emLen - $this->hLen - 1);
        $db = $maskedDB ^ $dbMask;
        $db[0] = ~chr(0xFF << ($emBits & 7)) & $db[0];
        $temp = $emLen - $this->hLen - $sLen - 2;
        if (substr($db, 0, $temp) != str_repeat(chr(0), $temp) || ord($db[$temp]) != 1) {
            return false;
        }
        $salt = substr($db, $temp + 1); // should be $sLen long
        $m2 = "\0\0\0\0\0\0\0\0" . $mHash . $salt;
        $h2 = $this->hash->hash($m2);
        return $this->_equals($h, $h2);
    }

    /**
     * RSASSA-PSS-SIGN
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-8.1.1 RFC3447#section-8.1.1}.
     *
     * @access private
     * @param String $m
     * @return String
     */
    function _rsassa_pss_sign($m)
    {
        // EMSA-PSS encoding

        $em = $this->_emsa_pss_encode($m, 8 * $this->k - 1);

        // RSA signature

        $m = $this->_os2ip($em);
        $s = $this->_rsasp1($m);
        $s = $this->_i2osp($s, $this->k);

        // Output the signature S

        return $s;
    }

    /**
     * RSASSA-PSS-VERIFY
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-8.1.2 RFC3447#section-8.1.2}.
     *
     * @access private
     * @param String $m
     * @param String $s
     * @return String
     */
    function _rsassa_pss_verify($m, $s)
    {
        // Length checking

        if (strlen($s) != $this->k) {
            user_error('Invalid signature');
            return false;
        }

        // RSA verification

        $modBits = 8 * $this->k;

        $s2 = $this->_os2ip($s);
        $m2 = $this->_rsavp1($s2);
        if ($m2 === false) {
            user_error('Invalid signature');
            return false;
        }
        $em = $this->_i2osp($m2, $modBits >> 3);
        if ($em === false) {
            user_error('Invalid signature');
            return false;
        }

        // EMSA-PSS verification

        return $this->_emsa_pss_verify($m, $em, $modBits - 1);
    }

    /**
     * EMSA-PKCS1-V1_5-ENCODE
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-9.2 RFC3447#section-9.2}.
     *
     * @access private
     * @param String $m
     * @param Integer $emLen
     * @return String
     */
    function _emsa_pkcs1_v1_5_encode($m, $emLen)
    {
        $h = $this->hash->hash($m);
        if ($h === false) {
            return false;
        }

        // see http://tools.ietf.org/html/rfc3447#page-43
        switch ($this->hashName) {
            case 'md2':
                $t = pack('H*', '3020300c06082a864886f70d020205000410');
                break;
            case 'md5':
                $t = pack('H*', '3020300c06082a864886f70d020505000410');
                break;
            case 'sha1':
                $t = pack('H*', '3021300906052b0e03021a05000414');
                break;
            case 'sha256':
                $t = pack('H*', '3031300d060960864801650304020105000420');
                break;
            case 'sha384':
                $t = pack('H*', '3041300d060960864801650304020205000430');
                break;
            case 'sha512':
                $t = pack('H*', '3051300d060960864801650304020305000440');
        }
        $t.= $h;
        $tLen = strlen($t);

        if ($emLen < $tLen + 11) {
            user_error('Intended encoded message length too short');
            return false;
        }

        $ps = str_repeat(chr(0xFF), $emLen - $tLen - 3);

        $em = "\0\1$ps\0$t";

        return $em;
    }

    /**
     * RSASSA-PKCS1-V1_5-SIGN
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-8.2.1 RFC3447#section-8.2.1}.
     *
     * @access private
     * @param String $m
     * @return String
     */
    function _rsassa_pkcs1_v1_5_sign($m)
    {
        // EMSA-PKCS1-v1_5 encoding

        $em = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
        if ($em === false) {
            user_error('RSA modulus too short');
            return false;
        }

        // RSA signature

        $m = $this->_os2ip($em);
        $s = $this->_rsasp1($m);
        $s = $this->_i2osp($s, $this->k);

        // Output the signature S

        return $s;
    }

    /**
     * RSASSA-PKCS1-V1_5-VERIFY
     *
     * See {@link http://tools.ietf.org/html/rfc3447#section-8.2.2 RFC3447#section-8.2.2}.
     *
     * @access private
     * @param String $m
     * @return String
     */
    function _rsassa_pkcs1_v1_5_verify($m, $s)
    {
        // Length checking

        if (strlen($s) != $this->k) {
            user_error('Invalid signature');
            return false;
        }

        // RSA verification

        $s = $this->_os2ip($s);
        $m2 = $this->_rsavp1($s);
        if ($m2 === false) {
            user_error('Invalid signature');
            return false;
        }
        $em = $this->_i2osp($m2, $this->k);
        if ($em === false) {
            user_error('Invalid signature');
            return false;
        }

        // EMSA-PKCS1-v1_5 encoding

        $em2 = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
        if ($em2 === false) {
            user_error('RSA modulus too short');
            return false;
        }

        // Compare
        return $this->_equals($em, $em2);
    }

    /**
     * Set Encryption Mode
     *
     * Valid values include CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_ENCRYPTION_PKCS1.
     *
     * @access public
     * @param Integer $mode
     */
    function setEncryptionMode($mode)
    {
        $this->encryptionMode = $mode;
    }

    /**
     * Set Signature Mode
     *
     * Valid values include CRYPT_RSA_SIGNATURE_PSS and CRYPT_RSA_SIGNATURE_PKCS1
     *
     * @access public
     * @param Integer $mode
     */
    function setSignatureMode($mode)
    {
        $this->signatureMode = $mode;
    }

    /**
     * Set public key comment.
     *
     * @access public
     * @param String $comment
     */
    function setComment($comment)
    {
        $this->comment = $comment;
    }

    /**
     * Get public key comment.
     *
     * @access public
     * @return String
     */
    function getComment()
    {
        return $this->comment;
    }

    /**
     * Encryption
     *
     * Both CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_ENCRYPTION_PKCS1 both place limits on how long $plaintext can be.
     * If $plaintext exceeds those limits it will be broken up so that it does and the resultant ciphertext's will
     * be concatenated together.
     *
     * @see decrypt()
     * @access public
     * @param String $plaintext
     * @return String
     */
    function encrypt($plaintext)
    {
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $length = $this->k - 11;
                if ($length <= 0) {
                    return false;
                }

                $plaintext = str_split($plaintext, $length);
                $ciphertext = '';
                foreach ($plaintext as $m) {
                    $ciphertext.= $this->_rsaes_pkcs1_v1_5_encrypt($m);
                }
                return $ciphertext;
            //case CRYPT_RSA_ENCRYPTION_OAEP:
            default:
                $length = $this->k - 2 * $this->hLen - 2;
                if ($length <= 0) {
                    return false;
                }

                $plaintext = str_split($plaintext, $length);
                $ciphertext = '';
                foreach ($plaintext as $m) {
                    $ciphertext.= $this->_rsaes_oaep_encrypt($m);
                }
                return $ciphertext;
        }
    }

    /**
     * Decryption
     *
     * @see encrypt()
     * @access public
     * @param String $plaintext
     * @return String
     */
    function decrypt($ciphertext)
    {
        if ($this->k <= 0) {
            return false;
        }

        $ciphertext = str_split($ciphertext, $this->k);
        $ciphertext[count($ciphertext) - 1] = str_pad($ciphertext[count($ciphertext) - 1], $this->k, chr(0), STR_PAD_LEFT);

        $plaintext = '';

        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $decrypt = '_rsaes_pkcs1_v1_5_decrypt';
                break;
            //case CRYPT_RSA_ENCRYPTION_OAEP:
            default:
                $decrypt = '_rsaes_oaep_decrypt';
        }

        foreach ($ciphertext as $c) {
            $temp = $this->$decrypt($c);
            if ($temp === false) {
                return false;
            }
            $plaintext.= $temp;
        }

        return $plaintext;
    }

    /**
     * Create a signature
     *
     * @see verify()
     * @access public
     * @param String $message
     * @return String
     */
    function sign($message)
    {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }

        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_sign($message);
            //case CRYPT_RSA_SIGNATURE_PSS:
            default:
                return $this->_rsassa_pss_sign($message);
        }
    }

    /**
     * Verifies a signature
     *
     * @see sign()
     * @access public
     * @param String $message
     * @param String $signature
     * @return Boolean
     */
    function verify($message, $signature)
    {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }

        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_verify($message, $signature);
            //case CRYPT_RSA_SIGNATURE_PSS:
            default:
                return $this->_rsassa_pss_verify($message, $signature);
        }
    }

    /**
     * Extract raw BER from Base64 encoding
     *
     * @access private
     * @param String $str
     * @return String
     */
    function _extractBER($str)
    {
        /* X.509 certs are assumed to be base64 encoded but sometimes they'll have additional things in them
         * above and beyond the ceritificate.
         * ie. some may have the following preceding the -----BEGIN CERTIFICATE----- line:
         *
         * Bag Attributes
         *     localKeyID: 01 00 00 00
         * subject=/O=organization/OU=org unit/CN=common name
         * issuer=/O=organization/CN=common name
         */
        $temp = preg_replace('#.*?^-+[^-]+-+#ms', '', $str, 1);
        // remove the -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- stuff
        $temp = preg_replace('#-+[^-]+-+#', '', $temp);
        // remove new lines
        $temp = str_replace(array("\r", "\n", ' '), '', $temp);
        $temp = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $temp) ? base64_decode($temp) : false;
        return $temp != false ? $temp : $str;
    }
}

}

/********************************************************
 * XPertMailer package 4.0.5 (LGPLv2.1)                 *
 * Tanase Laurentiu Iulian                              *
 * http://xpertmailer.sourceforge.net/                  *
 ********************************************************/
if (!defined('DISPLAY_XPM4_ERRORS')) define('DISPLAY_XPM4_ERRORS', FALSE);
if (version_compare(phpversion(), '5', '>='))
{
    if (!class_exists('FUNC5')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  Adapted by SysCo/al to support "compilation" with a 4.x PHP interpreter                *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!defined('DISPLAY_XPM4_ERRORS')) define('DISPLAY_XPM4_ERRORS', true);

class FUNC5 {

	function is_debug($debug) {
		return (is_array($debug) && isset($debug[0]['class'], $debug[0]['type'], $debug[0]['function'], $debug[0]['file'], $debug[0]['line']));
	}

	function microtime_float() {
		return microtime(true);
	}

	function is_win() {
		return (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN');
	}

	function log_errors($msg = null, $strip = false) {
		if (defined('LOG_XPM4_ERRORS')) {
			if (is_string(LOG_XPM4_ERRORS) && is_string($msg) && is_bool($strip)) {
				if (is_array($arr = unserialize(LOG_XPM4_ERRORS)) && isset($arr['type']) && is_int($arr['type']) && ($arr['type'] == 0 || $arr['type'] == 1 || $arr['type'] == 3)) {
					$msg = "\r\n".'['.date('m-d-Y H:i:s').'] XPM4 '.($strip ? str_replace(array('<br />', '<b>', '</b>', "\r\n"), '', $msg) : $msg);
					if ($arr['type'] == 0) error_log($msg);
					else if ($arr['type'] == 1 && isset($arr['destination'], $arr['headers']) && 
						is_string($arr['destination']) && strlen(trim($arr['destination'])) > 5 && count(explode('@', $arr['destination'])) == 2 && 
						is_string($arr['headers']) && strlen(trim($arr['headers'])) > 3) {
						error_log($msg, 1, trim($arr['destination']), trim($arr['headers']));
					} else if ($arr['type'] == 3 && isset($arr['destination']) && is_string($arr['destination']) && strlen(trim($arr['destination'])) > 1) {
						error_log($msg, 3, trim($arr['destination']));
					} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid LOG_XPM4_ERRORS constant value', E_USER_WARNING);
				} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid LOG_XPM4_ERRORS constant type', E_USER_WARNING);
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid parameter(s) type', E_USER_WARNING);
		}
	}

	function trace($debug, $message = null, $level = 0, $ret = false) {
		if ($this->is_debug($debug) && is_string($message) && ($level == 0 || $level == 1 || $level == 2)) {
			if ($level == 0) $mess = 'Error';
			else if ($level == 1) $mess = 'Warning';
			else if ($level == 2) $mess = 'Notice';
			$emsg = '<br /><b>'.$mess.'</b>: '.$message.
				' on '.strtoupper($debug[0]['class']).$debug[0]['type'].$debug[0]['function'].'()'.
				' in <b>'.$debug[0]['file'].'</b> on line <b>'.$debug[0]['line'].'</b><br />'."\r\n";
			$this->log_errors($emsg, true);
			if ($level == 0) {
				if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) die($emsg);
				else exit;
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) echo $emsg;
		} else {
			$emsg = 'invalid debug parameters';
			$this->log_errors(': '.$emsg, true);
			if ($level == 0) {
				if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error($emsg, E_USER_ERROR);
				else exit;
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error($emsg, E_USER_WARNING);
		}
		return $ret;
	}

	function str_clear($str = null, $addrep = null, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		$rep = array("\r", "\n", "\t");
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($addrep == null) $addrep = array();
		if (is_array($addrep)) {
			if (count($addrep) > 0) {
				foreach ($addrep as $strrep) {
					if (is_string($strrep) && $strrep != '') $rep[] = $strrep;
					else {
						$err[] = 'invalid array value';
						break;
					}
				}
			}
		} else $err[] = 'invalid array type';
		if (count($err) == 0) return ($str == '') ? '' : str_replace($rep, '', $str);
		else $this->trace($debug, implode(', ', $err));
	}

	function is_alpha($str = null, $num = true, $add = '', $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if (!is_bool($num)) $err[] = 'invalid numeric type';
		if (!is_string($add)) $err[] = 'invalid additional type';
		if (count($err) > 0) $this->trace($debug, implode(', ', $err));
		else {
			if ($str != '') {
				$lst = 'abcdefghijklmnoqprstuvwxyzABCDEFGHIJKLMNOQPRSTUVWXYZ'.$add;
				if ($num) $lst .= '1234567890';
				$len1 = strlen($str);
				$len2 = strlen($lst);
				$match = true;
				for ($i = 0; $i < $len1; $i++) {
					$found = false;
					for ($j = 0; $j < $len2; $j++) {
						if ($lst{$j} == $str{$i}) {
							$found = true;
							break;
						}
					}
					if (!$found) {
						$match = false;
						break;
					}
				}
				return $match;
			} else return false;
		}
	}

	function is_hostname($str = null, $addr = false, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid hostname type';
		if (!is_bool($addr)) $err[] = 'invalid address type';
		if (count($err) > 0) $this->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (trim($str) != '' && $this->is_alpha($str, true, '-.')) {
				if (count($exphost1 = explode('.', $str)) > 1 && !(strstr($str, '.-') || strstr($str, '-.'))) {
					$set = true;
					foreach ($exphost1 as $expstr1) {
						if ($expstr1 == '') {
							$set = false;
							break;
						}
					}
					if ($set) {
						foreach (($exphost2 = explode('-', $str)) as $expstr2) {
							if ($expstr2 == '') {
								$set = false;
								break;
							}
						}
					}
					$ext = $exphost1[count($exphost1)-1];
					$len = strlen($ext);
					if ($set && $len >= 2 && $len <= 6 && $this->is_alpha($ext, false)) $ret = true;
				}
			}
			return ($ret && $addr && gethostbyname($str) == $str) ? false : $ret;
		}
	}

	function is_ipv4($str = null, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		if (is_string($str)) return (trim($str) != '' && ip2long($str) && count(explode('.', $str)) === 4);
		else $this->trace($debug, 'invalid argument type');
	}

	function getmxrr_win($hostname = null, &$mxhosts, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		$mxhosts = array();
		if (!is_string($hostname)) $this->trace($debug, 'invalid hostname type');
		else {
			$hostname = strtolower($hostname);
			if ($this->is_hostname($hostname, true, $debug)) {
				$retstr = exec('nslookup -type=mx '.$hostname, $retarr);
				if ($retstr && count($retarr) > 0) {
					foreach ($retarr as $line) {
						if (preg_match('/.*mail exchanger = (.*)/', $line, $matches)) $mxhosts[] = $matches[1];
					}
				}
			} else $this->trace($debug, 'invalid hostname value', 1);
			return (count($mxhosts) > 0);
		}
	}

	function is_mail($addr = null, $vermx = false, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		if (!is_bool($vermx)) $err[] = 'invalid MX type';
		if (count($err) > 0) $this->trace($debug, implode(', ', $err));
		else {
			$ret = (count($exp = explode('@', $addr)) === 2 && $exp[0] != '' && $exp[1] != '' && $this->is_alpha($exp[0], true, '_-.+') && ($this->is_hostname($exp[1]) || $this->is_ipv4($exp[1])));
			if ($ret && $vermx) {
				if ($this->is_ipv4($exp[1])) $ret = false;
				else $ret = $this->is_win() ? $this->getmxrr_win($exp[1], $mxh, $debug) : getmxrr($exp[1], $mxh);
			}
			return $ret;
		}
	}

	function mime_type($name = null, $debug = null) {
		if (!$this->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($name)) $this->trace($debug, 'invalid filename type');
		else {
			$name = $this->str_clear($name);
			$name = trim($name);
			if ($name == '') return $this->trace($debug, 'invalid filename value', 1);
			else {
				$ret = 'application/octet-stream';
				$arr = array(
					'z'    => 'application/x-compress', 
					'xls'  => 'application/x-excel', 
					'gtar' => 'application/x-gtar', 
					'gz'   => 'application/x-gzip', 
					'cgi'  => 'application/x-httpd-cgi', 
					'php'  => 'application/x-httpd-php', 
					'js'   => 'application/x-javascript', 
					'swf'  => 'application/x-shockwave-flash', 
					'tar'  => 'application/x-tar', 
					'tgz'  => 'application/x-tar', 
					'tcl'  => 'application/x-tcl', 
					'src'  => 'application/x-wais-source', 
					'zip'  => 'application/zip', 
					'kar'  => 'audio/midi', 
					'mid'  => 'audio/midi', 
					'midi' => 'audio/midi', 
					'mp2'  => 'audio/mpeg', 
					'mp3'  => 'audio/mpeg', 
					'mpga' => 'audio/mpeg', 
					'ram'  => 'audio/x-pn-realaudio', 
					'rm'   => 'audio/x-pn-realaudio', 
					'rpm'  => 'audio/x-pn-realaudio-plugin', 
					'wav'  => 'audio/x-wav', 
					'bmp'  => 'image/bmp', 
					'fif'  => 'image/fif', 
					'gif'  => 'image/gif', 
					'ief'  => 'image/ief', 
					'jpe'  => 'image/jpeg', 
					'jpeg' => 'image/jpeg', 
					'jpg'  => 'image/jpeg', 
					'png'  => 'image/png', 
					'tif'  => 'image/tiff', 
					'tiff' => 'image/tiff', 
					'css'  => 'text/css', 
					'htm'  => 'text/html', 
					'html' => 'text/html', 
					'txt'  => 'text/plain', 
					'rtx'  => 'text/richtext', 
					'vcf'  => 'text/x-vcard', 
					'xml'  => 'text/xml', 
					'xsl'  => 'text/xsl', 
					'mpe'  => 'video/mpeg', 
					'mpeg' => 'video/mpeg', 
					'mpg'  => 'video/mpeg', 
					'mov'  => 'video/quicktime', 
					'qt'   => 'video/quicktime', 
					'asf'  => 'video/x-ms-asf', 
					'asx'  => 'video/x-ms-asf', 
					'avi'  => 'video/x-msvideo', 
					'vrml' => 'x-world/x-vrml', 
					'wrl'  => 'x-world/x-vrml');
				if (count($exp = explode('.', $name)) >= 2) {
					$ext = strtolower($exp[count($exp)-1]);
					if (trim($exp[count($exp)-2]) != '' && isset($arr[$ext])) $ret = $arr[$ext];
				}
				return $ret;
			}
		}
	}

}

    }

    if (!class_exists('MIME5')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  Adapted by SysCo/al to support "compilation" with a 4.x PHP interpreter                *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('FUNC5')) require_once 'FUNC5.php';

class MIME5 {

    var $LE = "\r\n";
    var $HLEN = 72; // SysCo/al instead of 52
    var $MLEN = 72; // SysCo/al instead of 73

    var $HCHARSET = 'utf-8';
    var $MCHARSET = 'us-ascii';

    var $HENCDEF = 'quoted-printable';
    var $MENCDEF = 'quoted-printable';
    
	var $hencarr = array('quoted-printable' => '', 'base64' => '');
	var $mencarr = array('7bit' => '', '8bit' => '', 'quoted-printable' => '', 'base64' => '', 'binary' => '');

	var $qpkeys = array(
			"\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07",
			"\x08","\x09","\x0A","\x0B","\x0C","\x0D","\x0E","\x0F",
			"\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17",
			"\x18","\x19","\x1A","\x1B","\x1C","\x1D","\x1E","\x1F",
			"\x7F","\x80","\x81","\x82","\x83","\x84","\x85","\x86",
			"\x87","\x88","\x89","\x8A","\x8B","\x8C","\x8D","\x8E",
			"\x8F","\x90","\x91","\x92","\x93","\x94","\x95","\x96",
			"\x97","\x98","\x99","\x9A","\x9B","\x9C","\x9D","\x9E",
			"\x9F","\xA0","\xA1","\xA2","\xA3","\xA4","\xA5","\xA6",
			"\xA7","\xA8","\xA9","\xAA","\xAB","\xAC","\xAD","\xAE",
			"\xAF","\xB0","\xB1","\xB2","\xB3","\xB4","\xB5","\xB6",
			"\xB7","\xB8","\xB9","\xBA","\xBB","\xBC","\xBD","\xBE",
			"\xBF","\xC0","\xC1","\xC2","\xC3","\xC4","\xC5","\xC6",
			"\xC7","\xC8","\xC9","\xCA","\xCB","\xCC","\xCD","\xCE",
			"\xCF","\xD0","\xD1","\xD2","\xD3","\xD4","\xD5","\xD6",
			"\xD7","\xD8","\xD9","\xDA","\xDB","\xDC","\xDD","\xDE",
			"\xDF","\xE0","\xE1","\xE2","\xE3","\xE4","\xE5","\xE6",
			"\xE7","\xE8","\xE9","\xEA","\xEB","\xEC","\xED","\xEE",
			"\xEF","\xF0","\xF1","\xF2","\xF3","\xF4","\xF5","\xF6",
			"\xF7","\xF8","\xF9","\xFA","\xFB","\xFC","\xFD","\xFE",
			"\xFF");

	var $qpvrep = array(
			"=00","=01","=02","=03","=04","=05","=06","=07",
			"=08","=09","=0A","=0B","=0C","=0D","=0E","=0F",
			"=10","=11","=12","=13","=14","=15","=16","=17",
			"=18","=19","=1A","=1B","=1C","=1D","=1E","=1F",
			"=7F","=80","=81","=82","=83","=84","=85","=86",
			"=87","=88","=89","=8A","=8B","=8C","=8D","=8E",
			"=8F","=90","=91","=92","=93","=94","=95","=96",
			"=97","=98","=99","=9A","=9B","=9C","=9D","=9E",
			"=9F","=A0","=A1","=A2","=A3","=A4","=A5","=A6",
			"=A7","=A8","=A9","=AA","=AB","=AC","=AD","=AE",
			"=AF","=B0","=B1","=B2","=B3","=B4","=B5","=B6",
			"=B7","=B8","=B9","=BA","=BB","=BC","=BD","=BE",
			"=BF","=C0","=C1","=C2","=C3","=C4","=C5","=C6",
			"=C7","=C8","=C9","=CA","=CB","=CC","=CD","=CE",
			"=CF","=D0","=D1","=D2","=D3","=D4","=D5","=D6",
			"=D7","=D8","=D9","=DA","=DB","=DC","=DD","=DE",
			"=DF","=E0","=E1","=E2","=E3","=E4","=E5","=E6",
			"=E7","=E8","=E9","=EA","=EB","=EC","=ED","=EE",
			"=EF","=F0","=F1","=F2","=F3","=F4","=F5","=F6",
			"=F7","=F8","=F9","=FA","=FB","=FC","=FD","=FE",
			"=FF");

    var $_func;
    
	function __construct() {
		$this->_func = new FUNC5;
	}

	function unique($add = null) {
		return md5(microtime(true).$add);
	}

	function is_printable($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($str)) $this->_func->trace($debug, 'invalid argument type');
		else {
			$contain = implode('', $this->qpkeys);
			return (strcspn($str, $contain) == strlen($str));
		}
	}

	function qp_encode($str = null, $len = null, $end = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($len == null) $len = $this->MLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $this->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			if ($str == '') return $str;
			else {
				$out = array();
				foreach (explode($end, $str) as $line) {
					if ($line == '') $out[] = '';
					else {
						$line = str_replace('=', '=3D', $line);
						$line = str_replace($this->qpkeys, $this->qpvrep, $line);
						preg_match_all('/.{1,'.$len.'}([^=]{0,2})?/', $line, $match);
						$mcnt = count($match[0]);
						for ($i = 0; $i < $mcnt; $i++) {
							$line = (substr($match[0][$i], -1) == ' ') ? substr($match[0][$i], 0, -1).'=20' : $match[0][$i];
							if (($i+1) < $mcnt) $line .= '=';
							$out[] = $line;
						}
					}
				}
				return implode($end, $out);
			}
		}
	}

	function encode_header($str = null, $charset = null, $encoding = null, $len = null, $end = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($charset == null) $charset = $this->HCHARSET;
		else if (!is_string($charset)) $err[] = 'invalid charset type';
		else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		if ($encoding == null) $encoding = $this->HENCDEF;
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$encoding = strtolower($this->_func->str_clear($encoding));
			if (!isset($this->hencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if ($len == null) $len = $this->HLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $this->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			if ($str == '') return $str;
			else {
				$enc = false;
				$dif = $len - strlen('=?'.$charset.'?X??=');
				if ($encoding == 'quoted-printable') {
					if (!$this->is_printable($str)) {
						$new = (($dif-4) > 2) ? ($dif-4) : $len;
						$enc = $this->qp_encode($str, $new, $end);
						$enc = str_replace(array('?', ' ', '='.$end), array('=3F', '_', $end), $enc);
					}
				} else if ($encoding == 'base64') {
					$new = ($dif > 3) ? $dif : $len;
					if ($new > 3) {
						for ($i = $new; $i > 2; $i--) {
							$crt = '';
							for ($j = 0; $j <= $i; $j++) $crt .= 'x';
							if (strlen(base64_encode($crt)) <= $new) {
								$new = $i;
								break;
							}
						}
					}
					$cnk = rtrim(chunk_split($str, $new, $end));
					$imp = array();
					foreach (explode($end, $cnk) as $line) if ($line != '') $imp[] = base64_encode($line);
					$enc = implode($end, $imp);
				}
				$res = array();
				if ($enc) {
					$chr = ($encoding == 'base64') ? 'B' : 'Q';
					foreach (explode($end, $enc) as $val) if ($val != '') $res[] = '=?'.$charset.'?'.$chr.'?'.$val.'?=';
				} else {
					$cnk = rtrim(chunk_split($str, $len, $end));
					foreach (explode($end, $cnk) as $val) if ($val != '') $res[] = $val;
				}
				return implode($end."\t", $res);
			}
		}
	}

	function decode_header($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($str)) $this->_func->trace($debug, 'invalid argument type');
		else {
			$str = trim($this->_func->str_clear($str));
			$arr = array();
			if ($str == '') $arr[] = array('charset' => $this->HCHARSET, 'value' => '');
			else {
				foreach (preg_split('/(?<!\\?(?i)q)\\?\\=/', $str, -1, PREG_SPLIT_NO_EMPTY) as $str1) {
					foreach (explode('=?', $str1, 2) as $str2) {
						$def = false;
						if (count($exp = explode('?B?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && $this->_func->is_alpha($exp[0], true, '-') && trim($exp[1]) != '') $def = array('charset' => $exp[0], 'value' => base64_decode(trim($exp[1])));
						} else if (count($exp = explode('?b?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && $this->_func->is_alpha($exp[0], true, '-') && trim($exp[1]) != '') $def = array('charset' => $exp[0], 'value' => base64_decode(trim($exp[1])));
						} else if (count($exp = explode('?Q?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && $this->_func->is_alpha($exp[0], true, '-') && $exp[1] != '') $def = array('charset' => $exp[0], 'value' => quoted_printable_decode(str_replace('_', ' ', $exp[1])));
						} else if (count($exp = explode('?q?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && $this->_func->is_alpha($exp[0], true, '-') && $exp[1] != '') $def = array('charset' => $exp[0], 'value' => quoted_printable_decode(str_replace('_', ' ', $exp[1])));
						}
						if ($def) {
							if ($def['value'] != '') $arr[] = array('charset' => $def['charset'], 'value' => $def['value']);
						} else {
							if ($str2 != '') $arr[] = array('charset' => $this->HCHARSET, 'value' => $str2);
						}
					}
				}
			}
			return $arr;
		}
	}

	function decode_content($str = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid content type';
		if ($encoding == null) $encoding = '7bit';
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$encoding = strtolower($encoding);
			if (!isset($this->mencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			if ($encoding == 'base64') {
				$str = trim($this->_func->str_clear($str));
				return base64_decode($str);
			} else if ($encoding == 'quoted-printable') {
				return quoted_printable_decode($str);
			} else return $str;
		}
	}

	function message($content = null, $type = null, $name = null, $charset = null, $encoding = null, $disposition = null, $id = null, $len = null, $end = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($type == null) $type = 'application/octet-stream';
		else if (is_string($type)) {
			$type = trim($this->_func->str_clear($type));
			if (strlen($type) < 4) $err[] = 'invalid type value';
		} else $err[] = 'invalid type';
		if (is_string($name)) {
			$name = trim($this->_func->str_clear($name));
			if ($name == '') $err[] = 'invalid name value';
		} else if ($name != null) $err[] = 'invalid name type';
		if ($charset == null) $charset = $this->MCHARSET;
		else if (!is_string($charset)) $err[] = 'invalid charset type';
		else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		if ($encoding == null) $encoding = $this->MENCDEF;
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$encoding = strtolower($this->_func->str_clear($encoding));
			if (!isset($this->mencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if ($disposition == null) $disposition = 'inline';
		else if (is_string($disposition)) {
			$disposition = strtolower($this->_func->str_clear($disposition));
			if (!($disposition == 'inline' || $disposition == 'attachment')) $err[] = 'invalid disposition value';
		} else $err[] = 'invalid disposition type';
		if (is_string($id)) {
			$id = $this->_func->str_clear($id, array(' '));
			if ($id == '') $err[] = 'invalid id value';
		} else if ($id != null) $err[] = 'invalid id type';
		if ($len == null) $len = $this->MLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $this->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$header = ''.
				'Content-Type: '.$type.';'.$end."\t".'charset="'.$charset.'"'.
				(($name == null) ? '' : ';'.$end."\t".'name="'.$name.'"').$end.
				'Content-Transfer-Encoding: '.$encoding.$end.
				'Content-Disposition: '.$disposition.
				(($name == null) ? '' : ';'.$end."\t".'filename="'.$name.'"').
				(($id == null) ? '' : $end.'Content-ID: <'.$id.'>');
			if ($encoding == '7bit' || $encoding == '8bit') $content = wordwrap($this->fix_eol($content), $len, $end, true);
			else if ($encoding == 'base64') $content = rtrim(chunk_split(base64_encode($content), $len, $end));
			else if ($encoding == 'quoted-printable') $content = $this->qp_encode($this->fix_eol($content), $len, $end);
			return array('header' => $header, 'content' => $content);
		}
	}

	function compose($text = null, $html = null, $attach = null, $uniq = null, $end = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if ($text == null && $html == null) $err[] = 'message is not set';
		else {
			if ($text != null) {
				if (!(is_array($text) && isset($text['header'], $text['content']) && is_string($text['header']) && is_string($text['content']) && $this->isset_header($text['header'], 'content-type', 'text/plain', $debug))) $err[] = 'invalid text message type';
			}
			if ($html != null) {
				if (!(is_array($html) && isset($html['header'], $html['content']) && is_string($html['header']) && is_string($html['content']) && $this->isset_header($html['header'], 'content-type', 'text/html', $debug))) $err[] = 'invalid html message type';
			}
		}
		if ($attach != null) {
			if (is_array($attach) && count($attach) > 0) {
				foreach ($attach as $arr) {
					if (!(is_array($arr) && isset($arr['header'], $arr['content']) && is_string($arr['header']) && is_string($arr['content']) && ($this->isset_header($arr['header'], 'content-disposition', 'inline', $debug) || $this->isset_header($arr['header'], 'content-disposition', 'attachment', $debug)))) {
						$err[] = 'invalid attachment type';
						break;
					}
				}
			} else $err[] = 'invalid attachment format';
		}
		if ($end == null) $end = $this->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$multipart = false;
			if ($text && $html) $multipart = true;
			if ($attach) $multipart = true;
			$header = $body = array();
			$header[] = 'Date: '.date('r');

            // Added by SysCo/al
            if (defined('XPM4_X-MAILER_CUSTOMIZED'))
            {
                $header[] = 'X-Mailer: '.constant('XPM4_X-MAILER_CUSTOMIZED');
            }
            else
            {
                $header[] = base64_decode('WC1NYWlsZXI6IFhQTTQgdi4wLjUgPCB3d3cueHBlcnRtYWlsZXIuY29tID4=');
            }
			if ($multipart) {
				$uniq = ($uniq == null) ? 0 : intval($uniq);
				$boundary1 = '=_1.'.$this->unique($uniq++);
				$boundary2 = '=_2.'.$this->unique($uniq++);
				$boundary3 = '=_3.'.$this->unique($uniq++);
				$disp['inline'] = $disp['attachment'] = false;
				if ($attach != null) {
					foreach ($attach as $darr) {
						if ($this->isset_header($darr['header'], 'content-disposition', 'inline', $debug)) $disp['inline'] = true;
						else if ($this->isset_header($darr['header'], 'content-disposition', 'attachment', $debug)) $disp['attachment'] = true;
					}
				}
				$hstr = 'Content-Type: multipart/%s;'.$end."\t".'boundary="%s"';
				$bstr = '--%s'.$end.'%s'.$end.$end.'%s';
				$body[] = 'This is a message in MIME Format. If you see this, your mail reader does not support this format.'.$end;
				if ($text && $html) {
						if ($disp['inline'] && $disp['attachment']) {
							$header[] = sprintf($hstr, 'mixed', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'related', $boundary2).$end;
							$body[] = '--'.$boundary2;
							$body[] = sprintf($hstr, 'alternative', $boundary3).$end;
							$body[] = sprintf($bstr, $boundary3, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary3, $html['header'], $html['content']);
							$body[] = '--'.$boundary3.'--';
							foreach ($attach as $desc) if ($this->isset_header($desc['header'], 'content-disposition', 'inline', $debug)) $body[] = sprintf($bstr, $boundary2, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) if ($this->isset_header($desc['header'], 'content-disposition', 'attachment', $debug)) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else if ($disp['inline']) {
							$header[] = sprintf($hstr, 'related', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'alternative', $boundary2).$end;
							$body[] = sprintf($bstr, $boundary2, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else if ($disp['attachment']) {
							$header[] = sprintf($hstr, 'mixed', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'alternative', $boundary2).$end;
							$body[] = sprintf($bstr, $boundary2, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else {
							$header[] = sprintf($hstr, 'alternative', $boundary1);
							$body[] = sprintf($bstr, $boundary1, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
							$body[] = '--'.$boundary1.'--';
						}
				} else if ($text) {
					$header[] = sprintf($hstr, 'mixed', $boundary1);
					$body[] = sprintf($bstr, $boundary1, $text['header'], $text['content']);
					foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
					$body[] = '--'.$boundary1.'--';
				} else if ($html) {
					if ($disp['inline'] && $disp['attachment']) {
						$header[] = sprintf($hstr, 'mixed', $boundary1);
						$body[] = '--'.$boundary1;
						$body[] = sprintf($hstr, 'related', $boundary2).$end;
						$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
						foreach ($attach as $desc) if ($this->isset_header($desc['header'], 'content-disposition', 'inline', $debug)) $body[] = sprintf($bstr, $boundary2, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary2.'--';
						foreach ($attach as $desc) if ($this->isset_header($desc['header'], 'content-disposition', 'attachment', $debug)) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					} else if ($disp['inline']) {
						$header[] = sprintf($hstr, 'related', $boundary1);
						$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
						foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					} else if ($disp['attachment']) {
						$header[] = sprintf($hstr, 'mixed', $boundary1);
						$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
						foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					}
				}
			} else {
				if ($text) {
					$header[] = $text['header'];
					$body[] = $text['content'];
				} else if ($html) {
					$header[] = $html['header'];
					$body[] = $html['content'];
				}
			}
			$header[] = 'MIME-Version: 1.0';
			return array('header' => implode($end, $header), 'content' => implode($end, $body));
		}
	}

	function isset_header($str = null, $name = null, $value = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($str) && $str != '')) $err[] = 'invalid header type';
		if (!(is_string($name) && strlen($name) > 1 && $this->_func->is_alpha($name, true, '-'))) $err[] = 'invalid name type';
		if ($value != null && !is_string($value)) $err[] = 'invalid value type';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if ($exp = $this->split_header($str, $debug)) {
				foreach ($exp as $harr) {
					if (strtolower($harr['name']) == strtolower($name)) {
						if ($value != null) $ret = (strtolower($harr['value']) == strtolower($value)) ? $harr['value'] : false;
						else $ret = $harr['value'];
						if ($ret) break;
					}
				}
			}
			return $ret;
		}
	}

	function split_header($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) $this->_func->trace($debug, 'invalid header value');
		else {
			$str = str_replace(array(";\r\n\t", "; \r\n\t", ";\r\n ", "; \r\n "), '; ', $str);
			$str = str_replace(array(";\n\t", "; \n\t", ";\n ", "; \n "), '; ', $str);
			$str = str_replace(array("\r\n\t", "\r\n "), '', $str);
			$str = str_replace(array("\n\t", "\n "), '', $str);
			$arr = array();
			foreach (explode("\n", $str) as $line) {
				$line = trim($this->_func->str_clear($line));
				if ($line != '') {
					if (count($exp1 = explode(':', $line, 2)) == 2) {
						$name = rtrim($exp1[0]);
						$val1 = ltrim($exp1[1]);
						if (strlen($name) > 1 && $this->_func->is_alpha($name, true, '-') && $val1 != '') {
							$name = ucfirst($name);
							$hadd = array();
							if (substr(strtolower($name), 0, 8) == 'content-') {
								$exp2 = explode('; ', $val1);
								$cnt2 = count($exp2);
								if ($cnt2 > 1) {
									for ($i = 1; $i < $cnt2; $i++) {
										if (count($exp3 = explode('=', $exp2[$i], 2)) == 2) {
											$hset = trim($exp3[0]);
											$hval = trim($exp3[1], ' "');
											if ($hset != '' && $hval != '') $hadd[strtolower($hset)] = $hval;
										}
									}
								}
							}
							$val2 = (count($hadd) > 0) ? trim($exp2[0]) : $val1;
							$arr[] = array('name' => $name, 'value' => $val2, 'content' => $hadd);
						}
					}
				}
			}
			if (count($arr) > 0) return $arr;
			else $this->_func->trace($debug, 'invalid header value', 1);
		}
	}

	function split_message($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) $this->_func->trace($debug, 'invalid message value');
		else {
			$ret = false;
			if (strpos($str, "\r\n\r\n")) $ret = explode("\r\n\r\n", $str, 2);
			else if (strpos($str, "\n\n")) $ret = explode("\n\n", $str, 2);
			if ($ret) return array('header' => trim($ret[0]), 'content' => $ret[1]);
			else return false;
		}
	}

	function split_mail($str = null, &$headers, &$body, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$headers = $body = false;
		if (!$part = $this->split_message($str, $debug)) return false;
		if (!$harr = $this->split_header($part['header'], $debug)) return false;
		$type = $boundary = false;
		foreach ($harr as $hnum) {
			if (strtolower($hnum['name']) == 'content-type') {
				$type = strtolower($hnum['value']);
				foreach ($hnum['content'] as $hnam => $hval) {
					if (strtolower($hnam) == 'boundary') {
						$boundary = $hval;
						break;
					}
				}
				if ($boundary) break;
			}
		}
		$headers = $harr;
		$body = array();
		if (substr($type, 0, strlen('multipart/')) == 'multipart/' && $boundary && strstr($part['content'], '--'.$boundary.'--')) $body = $this->_parts($part['content'], $boundary, strtolower(substr($type, strlen('multipart/'))), $debug);
		if (count($body) == 0) $body[] = $this->_content($str, $debug);
	}

	function _parts($str = null, $boundary = null, $multipart = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($str) && $str != '')) $err[] = 'invalid content value';
		if (!(is_string($boundary) && $boundary != '')) $err[] = 'invalid boundary value';
		if (!(is_string($multipart) && $multipart != '')) $err[] = 'invalid multipart value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = array();
			if (count($exp = explode('--'.$boundary.'--', $str)) == 2) {
				if (count($exp = explode('--'.$boundary, $exp[0])) > 2) {
					$cnt = 0;
					foreach ($exp as $split) {
						$cnt++;
						if ($cnt > 1 && $part = $this->split_message($split, $debug)) {
							if ($harr = $this->split_header($part['header'], $debug)) {
								$type = $newb = false;
								foreach ($harr as $hnum) {
									if (strtolower($hnum['name']) == 'content-type') {
										$type = strtolower($hnum['value']);
										foreach ($hnum['content'] as $hnam => $hval) {
											if (strtolower($hnam) == 'boundary') {
												$newb = $hval;
												break;
											}
										}
										if ($newb) break;
									}
								}
								if (substr($type, 0, strlen('multipart/')) == 'multipart/' && $newb && strstr($part['content'], '--'.$newb.'--')) $ret = $this->_parts($part['content'], $newb, $multipart.'|'.strtolower(substr($type, strlen('multipart/'))), $debug);
								else {
									$res = $this->_content($split, $debug);
									$res['multipart'] = $multipart;
									$ret[] = $res;
								}
							}
						}
					}
				}
			}
			return $ret;
		}
	}

	function _content($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) $this->_func->trace($debug, 'invalid content value');
		else {
			if (!$part = $this->split_message($str, $debug)) return null;
			if (!$harr = $this->split_header($part['header'], $debug)) return null;
			$body = array();
			$clen = strlen('content-');
			$encoding = false;
			foreach ($harr as $hnum) {
				if (substr(strtolower($hnum['name']), 0, $clen) == 'content-') {
					$name = strtolower(substr($hnum['name'], $clen));
					if ($name == 'transfer-encoding') $encoding = strtolower($hnum['value']);
					else if ($name == 'id') $body[$name] = array('value' => trim($hnum['value'], '<>'), 'extra' => $hnum['content']);
					else $body[$name] = array('value' => $hnum['value'], 'extra' => $hnum['content']);
				}
			}
			if ($encoding == 'base64' || $encoding == 'quoted-printable') $body['content'] = $this->decode_content($part['content'], $encoding, $debug);
			else {
				if ($encoding) $body['transfer-encoding'] = $encoding;
				$body['content'] = $part['content'];
			}
			if (substr($body['content'], -2) == "\r\n") $body['content'] = substr($body['content'], 0, -2);
			else if (substr($body['content'], -1) == "\n") $body['content'] = substr($body['content'], 0, -1);
			return $body;
		}
	}

	function fix_eol($str = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) $this->_func->trace($debug, 'invalid content value');
		else {
			$str = str_replace("\r\n", "\n", $str);
			$str = str_replace("\r", "\n", $str);
			if ($this->LE != "\n") $str = str_replace("\n", $this->LE, $str);
			return $str;
		}
	}

}

    }

    if (!class_exists('SMTP5')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  Adapted by SysCo/al to support "compilation" with a 4.x PHP interpreter                *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('MIME5')) require_once 'MIME5.php';

$_RESULT = array();

class SMTP5 {

	var $CRLF = "\r\n";
	var $PORT = 25;
	var $TOUT = 30;
	var $COUT = 5;
	var $BLEN = 1024;

    var $_func;
    
	function __construct() {
		$this->_func = new FUNC5;
	}

	function _cres($conn = null, &$resp, $code1 = null, $code2 = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!(is_int($code1) && $code1 > 99 && $code1 < 1000)) $err[] = 'invalid 1 code value';
		if ($code2 != null) {
			if (!(is_int($code2) && $code2 > 99 && $code2 < 1000)) $err[] = 'invalid 2 code value';
		}
		if (count($err) > 0) return $this->_func->trace($debug, implode(', ', $err), 1);
		else {
			$ret = true;
			do {
				if ($result = fgets($conn, $this->BLEN)) {
					$resp[] = $result;
					$rescode = substr($result, 0, 3);
					if (!($rescode == $code1 || $rescode == $code2)) {
						$ret = false;
						break;
					}
				} else {
					$resp[] = 'can not read';
					$ret = false;
					break;
				}
			} while ($result[3] == '-');
			return $ret;
		}
	}

	function mxconnect($host = null, $port = null, $tout = null, $name = null, $context = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($host)) $this->_func->trace($debug, 'invalid host type');
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && $this->_func->is_hostname($host, true, $debug))) $this->_func->trace($debug, 'invalid host value');
		}
		$res = $this->_func->is_win() ? $this->_func->getmxrr_win($host, $arr, $debug) : getmxrr($host, $arr);
		$con = false;
		if ($res) {
			foreach ($arr as $mx) {
				if ($con = $this->connect($mx, $port, null, null, null, $tout, $name, $context, null, $debug)) break;
			}
		}
		if (!$con) $con = $this->connect($host, $port, null, null, null, $tout, $name, $context, null, $debug);
		return $con;
	}

	function connect($host = null, $port = null, $user = null, $pass = null, $vssl = null, $tout = null, $name = null, $context = null, $login = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if ($port == null) $port = $this->PORT;
		if ($tout == null) $tout = $this->TOUT;
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || $this->_func->is_ipv4($host) || $this->_func->is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (!(is_int($port) && $port > 0)) $err[] = 'invalid port value';
		if ($user != null) {
			if (!is_string($user)) $err[] = 'invalid username type';
			else if (($user = $this->_func->str_clear($user)) == '') $err[] = 'invalid username value';
		}
		if ($pass != null) {
			if (!is_string($pass)) $err[] = 'invalid password type';
			else if (($pass = $this->_func->str_clear($pass)) == '') $err[] = 'invalid password value';
		}
		if (($user != null && $pass == null) || ($user == null && $pass != null)) $err[] = 'invalid username/password combination';
		if ($vssl != null) {
			if (!is_string($vssl)) $err[] = 'invalid ssl version type';
			else {
				$vssl = strtolower($vssl);
				if (!($vssl == 'tls' || $vssl == 'ssl' || $vssl == 'sslv2' || $vssl == 'sslv3')) $err[] = 'invalid ssl version value';
			}
		}
		if (!(is_int($tout) && $tout > 0)) $err[] = 'invalid timeout value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = strtolower(trim($name));
				if (!($name != '' && ($name == 'localhost' || $this->_func->is_ipv4($name) || $this->_func->is_hostname($name, true, $debug)))) $err[] = 'invalid name value';
			}
		} else $name = '127.0.0.1';
		if ($context != null && !is_resource($context)) $err[] = 'invalid context type';
		if ($login != null) {
			$login = strtolower(trim($login));
			if (!($login == 'login' || $login == 'plain' || $login == 'cram-md5')) $err[] = 'invalid authentication type value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$prt = ($vssl == null) ? 'tcp' : $vssl;
			$conn = ($context == null) ? stream_socket_client($prt.'://'.$host.':'.$port, $errno, $errstr, $tout) : stream_socket_client($prt.'://'.$host.':'.$port, $errno, $errstr, $tout, STREAM_CLIENT_CONNECT, $context);
			if (!$conn) $_RESULT[101] = $errstr;
			else if (!stream_set_timeout($conn, $this->COUT)) $_RESULT[102] = 'could not set stream timeout';
			else if (!$this->_cres($conn, $resp, 220, null, $debug)) $_RESULT[103] = $resp;
			else {
				$continue = true;
				if (!$this->ehlo($conn, $name, $debug)) $continue = $this->helo($conn, $name, $debug);
				if ($continue) {
					if ($user == null) $ret = true;
					else if ($login != null) $ret = $this->auth($conn, $user, $pass, $login, $debug);
					else {
						list($code, $arr) = each($_RESULT);
						$auth['default'] = $auth['login'] = $auth['plain'] = $auth['cram-md5'] = false;
						foreach ($arr as $line) {
							if (substr($line, 0, strlen('250-AUTH ')) == '250-AUTH ') {
								foreach (explode(' ', substr($line, strlen('250-AUTH '))) as $type) {
									$type = strtolower(trim($type));
									if ($type == 'login' || $type == 'plain' || $type == 'cram-md5') $auth[$type] = true;
								}
							} else if (substr($line, 0, strlen('250 AUTH=')) == '250 AUTH=') {
								$expl = explode(' ', strtolower(trim(substr($line, strlen('250 AUTH=')))), 2);
								if ($expl[0] == 'login' || $expl[0] == 'plain' || $expl[0] == 'cram-md5') $auth['default'] = $expl[0];
							}
						}
						if ($auth['default']) $ret = $this->auth($conn, $user, $pass, $auth['default'], $debug);
						if (!$ret && $auth['login'] && $auth['default'] != 'login') $ret = $this->auth($conn, $user, $pass, 'login', $debug);
						if (!$ret && $auth['plain'] && $auth['default'] != 'plain') $ret = $this->auth($conn, $user, $pass, 'plain', $debug);
						if (!$ret && $auth['cram-md5'] && $auth['default'] != 'cram-md5') $ret = $this->auth($conn, $user, $pass, 'cram-md5', $debug);
						if (!$ret && !$auth['login'] && $auth['default'] != 'login') $ret = $this->auth($conn, $user, $pass, 'login', $debug);
						if (!$ret && !$auth['plain'] && $auth['default'] != 'plain') $ret = $this->auth($conn, $user, $pass, 'plain', $debug);
						if (!$ret && !$auth['cram-md5'] && $auth['default'] != 'cram-md5') $ret = $this->auth($conn, $user, $pass, 'cram-md5', $debug);
					}
				}
			}
			if (!$ret) {
				if (is_resource($conn)) $this->disconnect($conn, $debug);
				$conn = false;
			}
			return $conn;
		}
	}

	function send($conn = null, $addrs = null, $mess = null, $from = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_array($addrs)) $err[] = 'invalid to address type';
		else {
			$aver = true;
			if (count($addrs) > 0) {
				foreach ($addrs as $addr) {
					if (!$this->_func->is_mail($addr)) {
						$aver = false;
						break;
					}
				}
			} else $aver = false;
			if (!$aver) $err[] = 'invalid to address value';
		}
		if (!is_string($mess)) $err[] = 'invalid message value';
		if ($from == null) {
			$from = @ini_get('sendmail_from');
			if ($from == '' || !$this->_func->is_mail($from)) $from = (isset($_SERVER['SERVER_ADMIN']) && $this->_func->is_mail($_SERVER['SERVER_ADMIN'])) ? $_SERVER['SERVER_ADMIN'] : 'postmaster@localhost';
		} else {
			if (!is_string($from)) $err[] = 'invalid from address type';
			else if (!($from != '' && $this->_func->is_mail($from))) $err[] = 'invalid from address value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if ($this->from($conn, $from, $debug)) {
				$continue = true;
				foreach ($addrs as $dest) {
					if (!$this->to($conn, $dest, $debug)) {
						$continue = false;
						break;
					}
				}
				if ($continue) {
					if ($this->data($conn, $mess, $debug)) $ret = $this->rset($conn, $debug);
				}
			}
			return $ret;
		}
	}

	function disconnect($conn = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		if (!is_resource($conn)) return $this->_func->trace($debug, 'invalid resource connection', 1);
		else {
			if (!fwrite($conn, 'QUIT'.$this->CRLF)) $_RESULT[300] = 'can not write';
			else $_RESULT[301] = 'Send QUIT';
			return @fclose($conn);
		}
	}

	function quit($conn = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		if (!is_resource($conn)) $this->_func->trace($debug, 'invalid resource connection');
		else if (!fwrite($conn, 'QUIT'.$this->CRLF)) $_RESULT[302] = 'can not write';
		else {
			$_RESULT[303] = ($vget = @fgets($conn, $this->BLEN)) ? $vget : 'can not read';
			$ret = true;
		}
		return $ret;
	}

	function helo($conn = null, $host = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || $this->_func->is_ipv4($host) || $this->_func->is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (!fwrite($conn, 'HELO '.$host.$this->CRLF)) $_RESULT[304] = 'can not write';
			else if (!$this->_cres($conn, $resp, 250, null, $debug)) $_RESULT[305] = $resp;
			else {
				$_RESULT[306] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function ehlo($conn = null, $host = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || $this->_func->is_ipv4($host) || $this->_func->is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (!fwrite($conn, 'EHLO '.$host.$this->CRLF)) $_RESULT[307] = 'can not write';
			else if (!$this->_cres($conn, $resp, 250, null, $debug)) $_RESULT[308] = $resp;
			else {
				$_RESULT[309] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function auth($conn = null, $user = null, $pass = null, $type = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($user)) $err[] = 'invalid username type';
		else if (($user = $this->_func->str_clear($user)) == '') $err[] = 'invalid username value';
		if (!is_string($pass)) $err[] = 'invalid password type';
		else if (($pass = $this->_func->str_clear($pass)) == '') $err[] = 'invalid password value';
		if ($type == null) $type = 'login';
		if (!is_string($type)) $err[] = 'invalid authentication type';
		else {
			$type = strtolower(trim($type));
			if (!($type == 'login' || $type == 'plain' || $type == 'cram-md5')) $err[] = 'invalid authentication type value';
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if ($type == 'login') {
				if (!fwrite($conn, 'AUTH LOGIN'.$this->CRLF)) $_RESULT[310] = 'can not write';
				else if (!$this->_cres($conn, $resp, 334, null, $debug)) $_RESULT[311] = $resp;
				else if (!fwrite($conn, base64_encode($user).$this->CRLF)) $_RESULT[312] = 'can not write';
				else if (!$this->_cres($conn, $resp, 334, null, $debug)) $_RESULT[313] = $resp;
				else if (!fwrite($conn, base64_encode($pass).$this->CRLF)) $_RESULT[314] = 'can not write';
				else if (!$this->_cres($conn, $resp, 235, null, $debug)) $_RESULT[315] = $resp;
				else {
					$_RESULT[316] = $resp;
					$ret = true;
				}
			} else if ($type == 'plain') {
				if (!fwrite($conn, 'AUTH PLAIN '.base64_encode($user.chr(0).$user.chr(0).$pass).$this->CRLF)) $_RESULT[317] = 'can not write';
				else if (!$this->_cres($conn, $resp, 235, null, $debug)) $_RESULT[318] = $resp;
				else {
					$_RESULT[319] = $resp;
					$ret = true;
				}
			} else if ($type == 'cram-md5') {
				if (!fwrite($conn, 'AUTH CRAM-MD5'.$this->CRLF)) $_RESULT[200] = 'can not write';
				else if (!$this->_cres($conn, $resp, 334, null, $debug)) $_RESULT[201] = $resp;
				else {
					if (strlen($pass) > 64) $pass = pack('H32', md5($pass));
					if (strlen($pass) < 64) $pass = str_pad($pass, 64, chr(0));
					$pad1 = substr($pass, 0, 64) ^ str_repeat(chr(0x36), 64);
					$pad2 = substr($pass, 0, 64) ^ str_repeat(chr(0x5C), 64);
					$chal = substr($resp[count($resp)-1], 4);
					$innr = pack('H32', md5($pad1.base64_decode($chal)));
					if (!fwrite($conn, base64_encode($user.' '.md5($pad2.$innr)).$this->CRLF)) $_RESULT[202] = 'can not write';
					else if (!$this->_cres($conn, $resp, 235, null, $debug)) $_RESULT[203] = $resp;
					else {
						$_RESULT[204] = $resp;
						$ret = true;
					}
				}
			}
			return $ret;
		}
	}

	function from($conn = null, $addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($addr)) $err[] = 'invalid from address type';
		else if (!($addr != '' && $this->_func->is_mail($addr))) $err[] = 'invalid from address value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (!fwrite($conn, 'MAIL FROM:<'.$addr.'>'.$this->CRLF)) $_RESULT[320] = 'can not write';
			else if (!$this->_cres($conn, $resp, 250, null, $debug)) $_RESULT[321] = $resp;
			else {
				$_RESULT[322] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function to($conn = null, $addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($addr)) $err[] = 'invalid to address type';
		else if (!($addr != '' && $this->_func->is_mail($addr))) $err[] = 'invalid to address value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (!fwrite($conn, 'RCPT TO:<'.$addr.'>'.$this->CRLF)) $_RESULT[323] = 'can not write';
			else if (!$this->_cres($conn, $resp, 250, 251, $debug)) $_RESULT[324] = $resp;
			else {
				$_RESULT[325] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function data($conn = null, $mess = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!(is_string($mess) && $mess != '')) $err[] = 'invalid message value';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (!fwrite($conn, 'DATA'.$this->CRLF)) $_RESULT[326] = 'can not write';
			else if (!$this->_cres($conn, $resp, 354, null, $debug)) $_RESULT[327] = $resp;
			else {
				$continue = true;
				foreach (explode($this->CRLF, $mess) as $line) {
					if ($line != '' && $line[0] == '.') $line = '.'.$line;
					if (!fwrite($conn, $line.$this->CRLF)) {
						$_RESULT[328] = 'can not write';
						$continue = false;
						break;
					}
				}
				if ($continue) {
					if (!fwrite($conn, '.'.$this->CRLF)) $_RESULT[329] = 'can not write';
					else if (!$this->_cres($conn, $resp, 250, null, $debug)) $_RESULT[330] = $resp;
					else {
						$_RESULT[331] = $resp;
						$ret = true;
					}
				}
			}
			return $ret;
		}
	}

	function rset($conn = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		if (!is_resource($conn)) $this->_func->trace($debug, 'invalid resource connection');
		else if (!fwrite($conn, 'RSET'.$this->CRLF)) $_RESULT[332] = 'can not write';
		else if (!$this->_cres($conn, $resp, 250, null, $debug)) $_RESULT[333] = $resp;
		else {
			$_RESULT[334] = $resp;
			$ret = true;
		}
		return $ret;
	}

	function recv($conn = null, $code1 = null, $code2 = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		if (!$this->_cres($conn, $resp, $code1, $code2, $debug)) $_RESULT[335] = $resp;
		else {
			$_RESULT[336] = $resp;
			$ret = true;
		}
		return $ret;
	}

}

    }

    if (!class_exists('MAIL5')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  Adapted by SysCo/al to support "compilation" with a 4.x PHP interpreter                *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('SMTP5')) require_once 'SMTP5.php';

class MAIL5 {

	var $From = null;
	var $To = array();
	var $Cc = array();
	var $Bcc = array();

	var $Subject = null;
	var $Text = null;
	var $Html = null;
	var $Header = array();
	var $Attach = array();

	var $Host = null;
	var $Port = null;
	var $User = null;
	var $Pass = null;
	var $Vssl = null;
	var $Tout = null;
	var $Auth = null;

	var $Name = null;
	var $Path = null;
	var $Priority = null;

	var $Context = null;

	var $SendMail = '/usr/sbin/sendmail';
	var $QMail = '/var/qmail/bin/sendmail';

	var $_conns = array();
	var $History = array();
	var $Result = null;

    var $_func;
    var $_mime;
    var $_smtp;

	function __construct() {
		$this->_func = new FUNC5;
		$this->_mime = new MIME5;
		$this->_smtp = new SMTP5;
		$this->_result(array(0 => 'initialize class'));
	}

	function _result($data = array(), $ret = null) {
		$this->History[][strval(microtime(true))] = $data;
		$this->Result = $data;
		return $ret;
	}

	function context($arr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_array($arr)) $this->_func->trace($debug, 'invalid context type');
		else if (!is_resource($res = stream_context_create($arr))) $this->_func->trace($debug, 'invalid context value');
		else {
			$this->Context = $res;
			return $this->_result(array(0 => 'set context connection'), true);
		}
	}

	function name($host = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($host)) $this->_func->trace($debug, 'invalid hostname type');
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || $this->_func->is_ipv4($host) || $this->_func->is_hostname($host, true, $debug)))) $this->_func->trace($debug, 'invalid hostname value');
			$this->Name = $host;
			return $this->_result(array(0 => 'set HELO/EHLO hostname'), true);
		}
	}

	function path($addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($addr)) $this->_func->trace($debug, 'invalid address type');
		else {
			if (!($addr != '' && $this->_func->is_mail($addr))) $this->_func->trace($debug, 'invalid address value');
			$this->Path = $addr;
			return $this->_result(array(0 => 'set Return-Path address'), true);
		}
	}

	function priority($level = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($level == null) {
			$this->Priority = null;
			return $this->_result(array(0 => 'unset priority'), true);
		} else if (is_int($level) || is_string($level)) {
			if (is_string($level)) $level = strtolower(trim($this->_func->str_clear($level)));
			if ($level == 1 || $level == 3 || $level == 5 || $level == 'high' || $level == 'normal' || $level == 'low') {
				$this->Priority = $level;
				return $this->_result(array(0 => 'set priority'), true);
			} else $this->_func->trace($debug, 'invalid level value');
		} else $this->_func->trace($debug, 'invalid level type');
	}

	function from($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!$this->_func->is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim($this->_func->str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$this->From = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set From address'), true);
		}
	}

	function addto($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!$this->_func->is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim($this->_func->str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$find = false;
			if (count($this->To) > 0) {
				$ladr = strtolower($addr);
				foreach ($this->To as $to) {
					if ($ladr == strtolower($to['address'])) {
						$this->_func->trace($debug, 'duplicate To address "'.$addr.'"', 1);
						$find = true;
					}
				}
			}
			if ($find) return false;
			else {
				$this->To[] = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add To address'), true);
			}
		}
	}

	function delto($addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->To = array();
			return $this->_result(array(0 => 'delete all To addresses'), true);
		} else if (!(is_string($addr) && $this->_func->is_mail($addr))) {
			$this->_func->trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->To) > 0) {
				$addr = strtolower($addr);
				foreach ($this->To as $to) {
					if ($addr == strtolower($to['address'])) $ret = true;
					else $new[] = $to;
				}
			}
			if ($ret) {
				$this->To = $new;
				return $this->_result(array(0 => 'delete To address'), true);
			} else return $this->_func->trace($debug, 'To address "'.$addr.'" not found', 1);
		}
	}

	function addcc($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!$this->_func->is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim($this->_func->str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$find = false;
			if (count($this->Cc) > 0) {
				$ladr = strtolower($addr);
				foreach ($this->Cc as $cc) {
					if ($ladr == strtolower($cc['address'])) {
						$this->_func->trace($debug, 'duplicate Cc address "'.$addr.'"', 1);
						$find = true;
					}
				}
			}
			if ($find) return false;
			else {
				$this->Cc[] = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add Cc address'), true);
			}
		}
	}

	function delcc($addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->Cc = array();
			return $this->_result(array(0 => 'delete all Cc addresses'), true);
		} else if (!(is_string($addr) && $this->_func->is_mail($addr))) {
			$this->_func->trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Cc) > 0) {
				$addr = strtolower($addr);
				foreach ($this->Cc as $cc) {
					if ($addr == strtolower($cc['address'])) $ret = true;
					else $new[] = $cc;
				}
			}
			if ($ret) {
				$this->Cc = $new;
				return $this->_result(array(0 => 'delete Cc address'), true);
			} else return $this->_func->trace($debug, 'Cc address "'.$addr.'" not found', 1);
		}
	}

	function addbcc($addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($addr)) $this->_func->trace($debug, 'invalid address type');
		else if (!$this->_func->is_mail($addr)) $this->_func->trace($debug, 'invalid address value');
		$find = false;
		if (count($this->Bcc) > 0) {
			$ladr = strtolower($addr);
			foreach ($this->Bcc as $bcc) {
				if ($ladr == strtolower($bcc)) {
					$this->_func->trace($debug, 'duplicate Bcc address "'.$addr.'"', 1);
					$find = true;
				}
			}
		}
		if ($find) return false;
		else {
			$this->Bcc[] = $addr;
			return $this->_result(array(0 => 'add Bcc address'), true);
		}
	}

	function delbcc($addr = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->Bcc = array();
			return $this->_result(array(0 => 'delete all Bcc addresses'), true);
		} else if (!(is_string($addr) && $this->_func->is_mail($addr))) {
			$this->_func->trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Bcc) > 0) {
				$addr = strtolower($addr);
				foreach ($this->Bcc as $bcc) {
					if ($addr == strtolower($bcc)) $ret = true;
					else $new[] = $bcc;
				}
			}
			if ($ret) {
				$this->Bcc = $new;
				return $this->_result(array(0 => 'delete Bcc address'), true);
			} else return $this->_func->trace($debug, 'Bcc address "'.$addr.'" not found', 1);
		}
	}

	function addheader($name = null, $value = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($name)) $err[] = 'invalid name type';
		else {
			$name = ucfirst(trim($this->_func->str_clear($name)));
			if (!(strlen($name) >= 2 && $this->_func->is_alpha($name, true, '-'))) $err[] = 'invalid name value';
		}
		if (!is_string($value)) $err[] = 'invalid content type';
		else {
			$value = trim($this->_func->str_clear($value));
			if ($value == '') $err[] = 'invalid content value';
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$ver = strtolower($name);
			$err = false;
			if ($ver == 'to') $err = 'can not set "To", for this, use function "AddTo()"';
			else if ($ver == 'cc') $err = 'can not set "Cc", for this, use function "AddCc()"';
			else if ($ver == 'bcc') $err = 'can not set "Bcc", for this, use function "AddBcc()"';
			else if ($ver == 'from') $err = 'can not set "From", for this, use function "From()"';
			else if ($ver == 'subject') $err = 'can not set "Subject", for this, use function "Subject()"';
			else if ($ver == 'x-priority') $err = 'can not set "X-Priority", for this, use function "Priority()"';
			else if ($ver == 'x-msmail-priority') $err = 'can not set "X-MSMail-Priority", for this, use function "Priority()"';
			else if ($ver == 'x-mimeole') $err = 'can not set "X-MimeOLE", for this, use function "Priority()"';
			else if ($ver == 'date') $err = 'can not set "Date", this value is automaticaly set';
			else if ($ver == 'content-type') $err = 'can not set "Content-Type", this value is automaticaly set';
			else if ($ver == 'content-transfer-encoding') $err = 'can not set "Content-Transfer-Encoding", this value is automaticaly set';
			else if ($ver == 'content-disposition') $err = 'can not set "Content-Disposition", this value is automaticaly set';
			else if ($ver == 'mime-version') $err = 'can not set "Mime-Version", this value is automaticaly set';
			else if ($ver == 'x-mailer') $err = 'can not set "X-Mailer", this value is automaticaly set';
			else if ($ver == 'message-id') $err = 'can not set "Message-ID", this value is automaticaly set';
			if ($err) $this->_func->trace($debug, $err);
			else {
				$this->Header[] = array('name' => $name, 'value' => $value, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add header'), true);
			}
		}
	}

	function delheader($name = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($name == null) {
			$this->Header = array();
			return $this->_result(array(0 => 'delete all headers'), true);
		} else if (!(is_string($name) && strlen($name) >= 2 && $this->_func->is_alpha($name, true, '-'))) {
			$this->_func->trace($debug, 'invalid name value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Header) > 0) {
				$name = strtolower($name);
				foreach ($this->Header as $header) {
					if ($name == strtolower($header['name'])) $ret = true;
					else $new[] = $header;
				}
			}
			if ($ret) {
				$this->Header = $new;
				return $this->_result(array(0 => 'delete header'), true);
			} else return $this->_func->trace($debug, 'header not found', 1);
		}
	}

	function subject($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($content)) $err[] = 'invalid content type';
		else {
			$content = trim($this->_func->str_clear($content));
			if ($content == '') $err[] = 'invalid content value';
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$this->Subject = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set subject'), true);
		}
	}

	function text($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$this->Text = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set text version'), true);
		}
	}

	function html($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$this->Html = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set html version'), true);
		}
	}

	function attach($content = null, $type = null, $name = null, $charset = null, $encoding = null, $disposition = null, $id = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($type != null) {
			if (!is_string($type)) $err[] = 'invalid type value';
			else {
				$type = trim($this->_func->str_clear($type));
				if (strlen($type) < 4) $err[] = 'invalid type value';
			}
		}
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim($this->_func->str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && $this->_func->is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding == null) $encoding = 'base64';
		else if (is_string($encoding)) {
			$encoding = strtolower($encoding);
			if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
		} else $err[] = 'invalid encoding type';
		if ($disposition == null) $disposition = 'attachment';
		else if (is_string($disposition)) {
			$disposition = strtolower($this->_func->str_clear($disposition));
			if (!($disposition == 'inline' || $disposition == 'attachment')) $err[] = 'invalid disposition value';
		} else $err[] = 'invalid disposition type';
		if ($id != null) {
			if (!is_string($id)) $err[] = 'invalid id type';
			else {
				$id = $this->_func->str_clear($id, array(' '));
				if ($id == '') $err[] = 'invalid id value';
			}
		}
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$this->Attach[] = array('content' => $content, 'type' => $type, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding, 'disposition' => $disposition, 'id' => $id);
			return $this->_result(array(0 => 'add attachment'), true);
		}
	}

	function delattach($name = null, $debug = null) {
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($name == null) {
			$this->Attach = array();
			return $this->_result(array(0 => 'delete all attachments'), true);
		} else if (!(is_string($name) && strlen($name) > 1)) {
			$this->_func->trace($debug, 'invalid name value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Attach) > 0) {
				$name = strtolower($name);
				foreach ($this->Attach as $att) {
					if ($name == strtolower($att['name'])) $ret = true;
					else $new[] = $att;
				}
			}
			if ($ret) {
				$this->Attach = $new;
				return $this->_result(array(0 => 'delete attachment'), true);
			} else return $this->_func->trace($debug, 'attachment not found', 1);
		}
	}

	function connect($host = null, $port = null, $user = null, $pass = null, $vssl = null, $tout = null, $name = null, $context = null, $auth = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($host == null) $host = $this->Host;
		if ($port == null) $port = $this->Port;
		if ($user == null) $user = $this->User;
		if ($pass == null) $pass = $this->Pass;
		if ($vssl == null) $vssl = $this->Vssl;
		if ($tout == null) $tout = $this->Tout;
		if ($name == null) $name = $this->Name;
		if ($context == null) $context = $this->Context;
		if ($auth == null) $auth = $this->Auth;
		if ($ret = $this->_smtp->connect($host, $port, $user, $pass, $vssl, $tout, $name, $context, $auth, $debug)) $this->_conns[] = $ret;
		return $this->_result($_RESULT, $ret);
	}

	function disconnect($resc = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if ($resc != null) {
			if (count($this->_conns) > 0) {
				$new = array();
				foreach ($this->_conns as $cres) {
					if ($cres != $resc) $new[] = $cres;
				}
				$this->_conns = $new;
			}
			$disc = $this->_smtp->disconnect($resc, $debug);
			return $this->_result($_RESULT, $disc);
		} else {
			$rarr = array();
			$disc = true;
			if (count($this->_conns) > 0) {
				foreach ($this->_conns as $cres) {
					if (!$this->_smtp->disconnect($cres, $debug)) $disc = false;
					$rarr[] = $_RESULT;
				}
			}
			return $this->_result($rarr, $disc);
		}
	}

	function send($resc = null, $debug = null) {
		global $_RESULT;
		$_RESULT = $err = array();
		if (!$this->_func->is_debug($debug)) $debug = debug_backtrace();
		if (is_resource($resc)) $delivery = 'relay';
		else {
			if ($resc == null) $resc = 'local';
			if (!is_string($resc)) $err[] = 'invalid connection type';
			else {
				$resc = strtolower(trim($resc));
				if ($resc == 'local' || $resc == 'client' || $resc == 'sendmail' || $resc == 'qmail') $delivery = $resc;
				else $err[] = 'invalid connection value';
			}
		}
		if (count($this->To) == 0) $err[] = 'to mail address is not set';
		if (!isset($this->Subject['content'])) $err[] = 'mail subject is not set';
		if (!(isset($this->Text['content']) || isset($this->Html['content']))) $err[] = 'mail message is not set';
		if (count($err) > 0) $this->_func->trace($debug, implode(', ', $err));
		else {
			$header['local'] = $header['client'] = array();
			$body = '';
			$from = null;
			if (isset($this->From['address']) && is_string($this->From['address'])) {
				$from = $this->From['address'];
				$hv = 'From: ';
				if (isset($this->From['name']) && trim($this->From['name']) != '') {
					$hn = $this->_mime->encode_header($this->From['name'], 
						isset($this->From['charset']) ? $this->From['charset'] : null, 
						isset($this->From['encoding']) ? $this->From['encoding'] : null, 
						null, null, $debug);
					if ($hn == $this->From['name']) $hn = '"'.str_replace('"', '\\"', $this->From['name']).'"';
					$hv .= $hn.' <'.$this->From['address'].'>';
				} else $hv .= $this->From['address'];
				$header['local'][] = $hv;
				$header['client'][] = $hv;
			}
			$addrs = $arr = array();
			foreach ($this->To as $to) {
				if (isset($to['address']) && $this->_func->is_mail($to['address'], false, $debug)) {
					$addrs[] = $to['address'];
					if (isset($to['name']) && trim($to['name']) != '') {
						$hn = $this->_mime->encode_header($to['name'], 
							isset($to['charset']) ? $to['charset'] : null, 
							isset($to['encoding']) ? $to['encoding'] : null, 
							null, null, $debug);
						if ($hn == $to['name']) $hn = '"'.str_replace('"', '\\"', $to['name']).'"';
						$arr[] = $hn.' <'.$to['address'].'>';
					} else $arr[] = $to['address'];
				}
			}
			if (count($arr) > 0) {
				$to = implode(', ', $arr);
				$header['client'][] = 'To: '.implode(', '.$this->_mime->LE."\t", $arr);
			} else $this->_func->trace($debug, 'to mail address is not set');
			if (count($this->Cc) > 0) {
				$arr = array();
				foreach ($this->Cc as $cc) {
					if (isset($cc['address']) && $this->_func->is_mail($cc['address'], false, $debug)) {
						$addrs[] = $cc['address'];
						if (isset($cc['name']) && trim($cc['name']) != '') {
							$hn = $this->_mime->encode_header($cc['name'], 
								isset($cc['charset']) ? $cc['charset'] : null, 
								isset($cc['encoding']) ? $cc['encoding'] : null, 
								null, null, $debug);
							if ($hn == $cc['name']) $hn = '"'.str_replace('"', '\\"', $cc['name']).'"';
							$arr[] = $hn.' <'.$cc['address'].'>';
						} else $arr[] = $cc['address'];
					}
				}
				if (count($arr) > 0) {
					$header['local'][] = 'Cc: '.implode(', ', $arr);
					$header['client'][] = 'Cc: '.implode(', '.$this->_mime->LE."\t", $arr);
				}
			}
			$hbcc = '';
			if (count($this->Bcc) > 0) {
				$arr = array();
				foreach ($this->Bcc as $bcc) {
					if ($this->_func->is_mail($bcc, false, $debug)) {
						$arr[] = $bcc;
						$addrs[] = $bcc;
					}
				}
				if (count($arr) > 0) {
					$header['local'][] = 'Bcc: '.implode(', ', $arr);
					$hbcc = $this->_mime->LE.'Bcc: '.implode(', ', $arr);
				}
			}
			$hn = $this->_mime->encode_header($this->Subject['content'], 
				isset($this->Subject['charset']) ? $this->Subject['charset'] : null, 
				isset($this->Subject['encoding']) ? $this->Subject['encoding'] : null, 
				null, null, $debug);
			$subject = $hn;
			$header['client'][] = 'Subject: '.$hn;
			if (is_int($this->Priority) || is_string($this->Priority)) {
				$arr = false;
				if ($this->Priority == 1 || $this->Priority == 'high') $arr = array(1, 'high');
				else if ($this->Priority == 3 || $this->Priority == 'normal') $arr = array(3, 'normal');
				else if ($this->Priority == 5 || $this->Priority == 'low') $arr = array(5, 'low');
				if ($arr) {
                    // Added by SysCo/al
                    if (defined('XPM4_X-MIMEOLE_CUSTOMIZED'))
                    {
                        $xmimeoleinfo = 'X-MimeOLE: '.constant('XPM4_X-MIMEOLE_CUSTOMIZED');
                    }
                    else
                    {
                        $xmimeoleinfo = 'X-MimeOLE: Produced By XPertMailer v.4 MIME Class';
                    }
					$header['local'][] = 'X-Priority: '.$arr[0];
					$header['local'][] = 'X-MSMail-Priority: '.$arr[1];
					$header['local'][] = $xmimeoleinfo; // << required by SpamAssassin in conjunction with "X-MSMail-Priority"
					$header['client'][] = 'X-Priority: '.$arr[0];
					$header['client'][] = 'X-MSMail-Priority: '.$arr[1];
					$header['client'][] = $xmimeoleinfo;
				}
			}
            // Added by SysCo/al
            if (defined('XPM4_MESSAGE_ID_CUSTOMIZED'))
            {
                $header['client'][] = 'Message-ID: <'.$this->_mime->unique().'@'.constant('XPM4_MESSAGE_ID_CUSTOMIZED').'>';
            }
            else
            {
                $header['client'][] = 'Message-ID: <'.$this->_mime->unique().'@xpertmailer.com>';
            }
			if (count($this->Header) > 0) {
				foreach ($this->Header as $harr) {
					if (isset($harr['name'], $harr['value']) && strlen($harr['name']) >= 2 && $this->_func->is_alpha($harr['name'], true, '-')) {
						$hn = $this->_mime->encode_header($harr['value'], 
							isset($harr['charset']) ? $harr['charset'] : null, 
							isset($harr['encoding']) ? $harr['encoding'] : null, 
							null, null, $debug);
						$header['local'][] = ucfirst($harr['name']).': '.$hn;
						$header['client'][] = ucfirst($harr['name']).': '.$hn;
					}
				}
			}
			$text = $html = $att = null;
			if (isset($this->Text['content'])) {
				$text = $this->_mime->message($this->Text['content'], 'text/plain', null, 
					isset($this->Text['charset']) ? $this->Text['charset'] : null, 
					isset($this->Text['encoding']) ? $this->Text['encoding'] : null, 
					null, null, null, null, $debug);
			}
			if (isset($this->Html['content'])) {
				$html = $this->_mime->message($this->Html['content'], 'text/html', null, 
					isset($this->Html['charset']) ? $this->Html['charset'] : null, 
					isset($this->Html['encoding']) ? $this->Html['encoding'] : null, 
					null, null, null, null, $debug);
			}
			if (count($this->Attach) > 0) {
				$att = array();
				foreach ($this->Attach as $attach) {
					if (isset($attach['content'])) {
						$att[] = $this->_mime->message($attach['content'], 
							isset($attach['type']) ? $attach['type'] : null, 
							isset($attach['name']) ? $attach['name'] : null, 
							isset($attach['charset']) ? $attach['charset'] : null, 
							isset($attach['encoding']) ? $attach['encoding'] : null, 
							isset($attach['disposition']) ? $attach['disposition'] : null, 
							isset($attach['id']) ? $attach['id'] : null, 
							null, null, $debug);
					}
				}
				if (count($att) == 0) $att = null;
			}
			$arr = $this->_mime->compose($text, $html, $att);
			if ($delivery == 'relay') {
				$res = $this->_smtp->send($resc, $addrs, implode($this->_mime->LE, $header['client']).$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'], (($this->Path != null) ? $this->Path : $from), $debug);
				return $this->_result($_RESULT, $res);
			} else if ($delivery == 'local') {
				$rpath = (!$this->_func->is_win() && $this->Path != null) ? '-f '.$this->Path : null;
				$spath = ($this->Path != null) ? @ini_set('sendmail_from', $this->Path) : false;
				if (!$this->_func->is_win()) $arr['content'] = str_replace("\r\n", "\n", $arr['content']);
				$res = mail($to, $subject, $arr['content'], implode($this->_mime->LE, $header['local']).$this->_mime->LE.$arr['header'], $rpath);
				if ($spath) @ini_restore('sendmail_from');
				return $this->_result(array(0 => 'send mail local'), $res);
			} else if ($delivery == 'client') {
				$group = array();
				foreach ($addrs as $addr) {
					$exp = explode('@', $addr);
					$group[strtolower($exp[1])][] = $addr;
				}
				$ret = true;
				$reg = (count($group) == 1);
				foreach ($group as $domain => $arrs) {
					$con = $this->_smtp->mxconnect($domain, $this->Port, $this->Tout, $this->Name, $this->Context, $debug);
					if ($reg) $this->_result(array($domain => $_RESULT));
					if ($con) {
						if (!$this->_smtp->send($con, $arrs, implode($this->_mime->LE, $header['client']).$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'], (($this->Path != null) ? $this->Path : $from), $debug)) $ret = false;
						if ($reg) $this->_result(array($domain => $_RESULT));
						$this->_smtp->disconnect($con, $debug);
					} else $ret = false;
				}
				if (!$reg) $this->_result(array(0 => 'send mail client'));
				return $ret;
			} else if ($delivery == 'sendmail' || $delivery == 'qmail') {
				$ret = false;
				$comm = (($delivery == 'sendmail') ? $this->SendMail : $this->QMail).' -oi'.(($this->Path != null) ? ' -f '.$this->Path : '').' -t';
				if ($con = popen($comm, 'w')) {
					if (fputs($con, implode($this->_mime->LE, $header['client']).$hbcc.$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'])) {
						$res = pclose($con) >> 8 & 0xFF;
						if ($res == 0) {
							$ret = true;
							$this->_result(array(0 => 'send mail using "'.ucfirst($delivery).'" program'));
						} else $this->_result(array(0 => $res));
					} else $this->_result(array(0 => 'can not write'));
				} else $this->_result(array(0 => 'can not write line command'));
				return $ret;
			}
		}
	}

}

    }
    class MAIL extends MAIL5 { }
}
else
{
    if (!class_exists('FUNC4')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!defined('DISPLAY_XPM4_ERRORS')) define('DISPLAY_XPM4_ERRORS', true);

if (!function_exists('debug_backtrace')) {
	function debug_backtrace() {
		return array(0 => array('class' => 'unknown', 'type' => 'unknown', 'function' => 'unknown', 'file' => __FILE__, 'line' => __LINE__));
	}
}

class FUNC4 {

	function is_debug($debug) {
		return (is_array($debug) && isset($debug[0]['class'], $debug[0]['type'], $debug[0]['function'], $debug[0]['file'], $debug[0]['line']));
	}

	function microtime_float() {
		list($usec, $sec) = explode(' ', microtime());
		return ((float)$usec + (float)$sec);
	}

	function is_win() {
		return (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN');
	}

	function log_errors($msg = null, $strip = false) {
		if (defined('LOG_XPM4_ERRORS')) {
			if (is_string(LOG_XPM4_ERRORS) && is_string($msg) && is_bool($strip)) {
				if (is_array($arr = unserialize(LOG_XPM4_ERRORS)) && isset($arr['type']) && is_int($arr['type']) && ($arr['type'] == 0 || $arr['type'] == 1 || $arr['type'] == 3)) {
					$msg = "\r\n".'['.date('m-d-Y H:i:s').'] XPM4 '.($strip ? str_replace(array('<br />', '<b>', '</b>', "\r\n"), '', $msg) : $msg);
					if ($arr['type'] == 0) error_log($msg);
					else if ($arr['type'] == 1 && isset($arr['destination'], $arr['headers']) && 
						is_string($arr['destination']) && strlen(trim($arr['destination'])) > 5 && count(explode('@', $arr['destination'])) == 2 && 
						is_string($arr['headers']) && strlen(trim($arr['headers'])) > 3) {
						error_log($msg, 1, trim($arr['destination']), trim($arr['headers']));
					} else if ($arr['type'] == 3 && isset($arr['destination']) && is_string($arr['destination']) && strlen(trim($arr['destination'])) > 1) {
						error_log($msg, 3, trim($arr['destination']));
					} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid LOG_XPM4_ERRORS constant value', E_USER_WARNING);
				} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid LOG_XPM4_ERRORS constant type', E_USER_WARNING);
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error('invalid parameter(s) type', E_USER_WARNING);
		}
	}

	function trace($debug, $message = null, $level = 0, $ret = false) {
		if (FUNC4::is_debug($debug) && is_string($message) && ($level == 0 || $level == 1 || $level == 2)) {
			if ($level == 0) $mess = 'Error';
			else if ($level == 1) $mess = 'Warning';
			else if ($level == 2) $mess = 'Notice';
			$emsg = '<br /><b>'.$mess.'</b>: '.$message.
				' on '.strtoupper($debug[0]['class']).$debug[0]['type'].$debug[0]['function'].'()'.
				' in <b>'.$debug[0]['file'].'</b> on line <b>'.$debug[0]['line'].'</b><br />'."\r\n";
			FUNC4::log_errors($emsg, true);
			if ($level == 0) {
				if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) die($emsg);
				else exit;
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) echo $emsg;
		} else {
			$emsg = 'invalid debug parameters';
			FUNC4::log_errors(': '.$emsg, true);
			if ($level == 0) {
				if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error($emsg, E_USER_ERROR);
				else exit;
			} else if (defined('DISPLAY_XPM4_ERRORS') && DISPLAY_XPM4_ERRORS == true) trigger_error($emsg, E_USER_WARNING);
		}
		return $ret;
	}

	function str_clear($str = null, $addrep = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		$rep = array("\r", "\n", "\t");
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($addrep == null) $addrep = array();
		if (is_array($addrep)) {
			if (count($addrep) > 0) {
				foreach ($addrep as $strrep) {
					if (is_string($strrep) && $strrep != '') $rep[] = $strrep;
					else {
						$err[] = 'invalid array value';
						break;
					}
				}
			}
		} else $err[] = 'invalid array type';
		if (count($err) == 0) return ($str == '') ? '' : str_replace($rep, '', $str);
		else FUNC4::trace($debug, implode(', ', $err));
	}

	function is_alpha($str = null, $num = true, $add = '', $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if (!is_bool($num)) $err[] = 'invalid numeric type';
		if (!is_string($add)) $err[] = 'invalid additional type';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			if ($str != '') {
				$lst = 'abcdefghijklmnoqprstuvwxyzABCDEFGHIJKLMNOQPRSTUVWXYZ'.$add;
				if ($num) $lst .= '1234567890';
				$len1 = strlen($str);
				$len2 = strlen($lst);
				$match = true;
				for ($i = 0; $i < $len1; $i++) {
					$found = false;
					for ($j = 0; $j < $len2; $j++) {
						if ($lst{$j} == $str{$i}) {
							$found = true;
							break;
						}
					}
					if (!$found) {
						$match = false;
						break;
					}
				}
				return $match;
			} else return false;
		}
	}

	function is_hostname($str = null, $addr = false, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid hostname type';
		if (!is_bool($addr)) $err[] = 'invalid address type';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (trim($str) != '' && FUNC4::is_alpha($str, true, '-.')) {
				if (count($exphost1 = explode('.', $str)) > 1 && !(strstr($str, '.-') || strstr($str, '-.'))) {
					$set = true;
					foreach ($exphost1 as $expstr1) {
						if ($expstr1 == '') {
							$set = false;
							break;
						}
					}
					if ($set) {
						foreach (($exphost2 = explode('-', $str)) as $expstr2) {
							if ($expstr2 == '') {
								$set = false;
								break;
							}
						}
					}
					$ext = $exphost1[count($exphost1)-1];
					$len = strlen($ext);
					if ($set && $len >= 2 && $len <= 6 && FUNC4::is_alpha($ext, false)) $ret = true;
				}
			}
			return ($ret && $addr && gethostbyname($str) == $str) ? false : $ret;
		}
	}

	function is_ipv4($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (is_string($str)) return (trim($str) != '' && ip2long($str) && count(explode('.', $str)) === 4);
		else FUNC4::trace($debug, 'invalid argument type');
	}

	function getmxrr_win($hostname = null, &$mxhosts, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$mxhosts = array();
		if (!is_string($hostname)) FUNC4::trace($debug, 'invalid hostname type');
		else {
			$hostname = strtolower($hostname);
			if (FUNC4::is_hostname($hostname, true, $debug)) {
				$retstr = exec('nslookup -type=mx '.$hostname, $retarr);
				if ($retstr && count($retarr) > 0) {
					foreach ($retarr as $line) {
						if (preg_match('/.*mail exchanger = (.*)/', $line, $matches)) $mxhosts[] = $matches[1];
					}
				}
			} else FUNC4::trace($debug, 'invalid hostname value', 1);
			return (count($mxhosts) > 0);
		}
	}

	function is_mail($addr = null, $vermx = false, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		if (!is_bool($vermx)) $err[] = 'invalid MX type';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = (count($exp = explode('@', $addr)) === 2 && $exp[0] != '' && $exp[1] != '' && FUNC4::is_alpha($exp[0], true, '_-.+') && (FUNC4::is_hostname($exp[1]) || FUNC4::is_ipv4($exp[1])));
			if ($ret && $vermx) {
				if (FUNC4::is_ipv4($exp[1])) $ret = false;
				else $ret = FUNC4::is_win() ? FUNC4::getmxrr_win($exp[1], $mxh, $debug) : getmxrr($exp[1], $mxh);
			}
			return $ret;
		}
	}

	function mime_type($name = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($name)) FUNC4::trace($debug, 'invalid filename type');
		else {
			$name = FUNC4::str_clear($name);
			$name = trim($name);
			if ($name == '') return FUNC4::trace($debug, 'invalid filename value', 1);
			else {
				$ret = 'application/octet-stream';
				$arr = array(
					'z'    => 'application/x-compress', 
					'xls'  => 'application/x-excel', 
					'gtar' => 'application/x-gtar', 
					'gz'   => 'application/x-gzip', 
					'cgi'  => 'application/x-httpd-cgi', 
					'php'  => 'application/x-httpd-php', 
					'js'   => 'application/x-javascript', 
					'swf'  => 'application/x-shockwave-flash', 
					'tar'  => 'application/x-tar', 
					'tgz'  => 'application/x-tar', 
					'tcl'  => 'application/x-tcl', 
					'src'  => 'application/x-wais-source', 
					'zip'  => 'application/zip', 
					'kar'  => 'audio/midi', 
					'mid'  => 'audio/midi', 
					'midi' => 'audio/midi', 
					'mp2'  => 'audio/mpeg', 
					'mp3'  => 'audio/mpeg', 
					'mpga' => 'audio/mpeg', 
					'ram'  => 'audio/x-pn-realaudio', 
					'rm'   => 'audio/x-pn-realaudio', 
					'rpm'  => 'audio/x-pn-realaudio-plugin', 
					'wav'  => 'audio/x-wav', 
					'bmp'  => 'image/bmp', 
					'fif'  => 'image/fif', 
					'gif'  => 'image/gif', 
					'ief'  => 'image/ief', 
					'jpe'  => 'image/jpeg', 
					'jpeg' => 'image/jpeg', 
					'jpg'  => 'image/jpeg', 
					'png'  => 'image/png', 
					'tif'  => 'image/tiff', 
					'tiff' => 'image/tiff', 
					'css'  => 'text/css', 
					'htm'  => 'text/html', 
					'html' => 'text/html', 
					'txt'  => 'text/plain', 
					'rtx'  => 'text/richtext', 
					'vcf'  => 'text/x-vcard', 
					'xml'  => 'text/xml', 
					'xsl'  => 'text/xsl', 
					'mpe'  => 'video/mpeg', 
					'mpeg' => 'video/mpeg', 
					'mpg'  => 'video/mpeg', 
					'mov'  => 'video/quicktime', 
					'qt'   => 'video/quicktime', 
					'asf'  => 'video/x-ms-asf', 
					'asx'  => 'video/x-ms-asf', 
					'avi'  => 'video/x-msvideo', 
					'vrml' => 'x-world/x-vrml', 
					'wrl'  => 'x-world/x-vrml');
				if (count($exp = explode('.', $name)) >= 2) {
					$ext = strtolower($exp[count($exp)-1]);
					if (trim($exp[count($exp)-2]) != '' && isset($arr[$ext])) $ret = $arr[$ext];
				}
				return $ret;
			}
		}
	}

}

    }

    if (!class_exists('MIME4')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('FUNC4')) require_once 'FUNC4.php';

class MIME4 {

	var $LE = "\r\n";
	var $HLEN = 72; // SysCo/al instead of 52
	var $MLEN = 72; // SysCo/al instead of 73

	var $HCHARSET = 'utf-8';
	var $MCHARSET = 'us-ascii';

	var $HENCDEF = 'quoted-printable';
	var $MENCDEF = 'quoted-printable';

	var $hencarr = array('quoted-printable' => '', 'base64' => '');
	var $mencarr = array('7bit' => '', '8bit' => '', 'quoted-printable' => '', 'base64' => '', 'binary' => '');

	var $qpkeys = array(
			"\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07",
			"\x08","\x09","\x0A","\x0B","\x0C","\x0D","\x0E","\x0F",
			"\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17",
			"\x18","\x19","\x1A","\x1B","\x1C","\x1D","\x1E","\x1F",
			"\x7F","\x80","\x81","\x82","\x83","\x84","\x85","\x86",
			"\x87","\x88","\x89","\x8A","\x8B","\x8C","\x8D","\x8E",
			"\x8F","\x90","\x91","\x92","\x93","\x94","\x95","\x96",
			"\x97","\x98","\x99","\x9A","\x9B","\x9C","\x9D","\x9E",
			"\x9F","\xA0","\xA1","\xA2","\xA3","\xA4","\xA5","\xA6",
			"\xA7","\xA8","\xA9","\xAA","\xAB","\xAC","\xAD","\xAE",
			"\xAF","\xB0","\xB1","\xB2","\xB3","\xB4","\xB5","\xB6",
			"\xB7","\xB8","\xB9","\xBA","\xBB","\xBC","\xBD","\xBE",
			"\xBF","\xC0","\xC1","\xC2","\xC3","\xC4","\xC5","\xC6",
			"\xC7","\xC8","\xC9","\xCA","\xCB","\xCC","\xCD","\xCE",
			"\xCF","\xD0","\xD1","\xD2","\xD3","\xD4","\xD5","\xD6",
			"\xD7","\xD8","\xD9","\xDA","\xDB","\xDC","\xDD","\xDE",
			"\xDF","\xE0","\xE1","\xE2","\xE3","\xE4","\xE5","\xE6",
			"\xE7","\xE8","\xE9","\xEA","\xEB","\xEC","\xED","\xEE",
			"\xEF","\xF0","\xF1","\xF2","\xF3","\xF4","\xF5","\xF6",
			"\xF7","\xF8","\xF9","\xFA","\xFB","\xFC","\xFD","\xFE",
			"\xFF");

	var $qpvrep = array(
			"=00","=01","=02","=03","=04","=05","=06","=07",
			"=08","=09","=0A","=0B","=0C","=0D","=0E","=0F",
			"=10","=11","=12","=13","=14","=15","=16","=17",
			"=18","=19","=1A","=1B","=1C","=1D","=1E","=1F",
			"=7F","=80","=81","=82","=83","=84","=85","=86",
			"=87","=88","=89","=8A","=8B","=8C","=8D","=8E",
			"=8F","=90","=91","=92","=93","=94","=95","=96",
			"=97","=98","=99","=9A","=9B","=9C","=9D","=9E",
			"=9F","=A0","=A1","=A2","=A3","=A4","=A5","=A6",
			"=A7","=A8","=A9","=AA","=AB","=AC","=AD","=AE",
			"=AF","=B0","=B1","=B2","=B3","=B4","=B5","=B6",
			"=B7","=B8","=B9","=BA","=BB","=BC","=BD","=BE",
			"=BF","=C0","=C1","=C2","=C3","=C4","=C5","=C6",
			"=C7","=C8","=C9","=CA","=CB","=CC","=CD","=CE",
			"=CF","=D0","=D1","=D2","=D3","=D4","=D5","=D6",
			"=D7","=D8","=D9","=DA","=DB","=DC","=DD","=DE",
			"=DF","=E0","=E1","=E2","=E3","=E4","=E5","=E6",
			"=E7","=E8","=E9","=EA","=EB","=EC","=ED","=EE",
			"=EF","=F0","=F1","=F2","=F3","=F4","=F5","=F6",
			"=F7","=F8","=F9","=FA","=FB","=FC","=FD","=FE",
			"=FF");

	function unique($add = null) {
		return md5(FUNC4::microtime_float().$add);
	}

	function is_printable($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($str)) FUNC4::trace($debug, 'invalid argument type');
		else {
			$_mime = new MIME4;
			$contain = implode('', $_mime->qpkeys);
			return (strcspn($str, $contain) == strlen($str));
		}
	}

	function qp_encode($str = null, $len = null, $end = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$_mime = new MIME4;
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($len == null) $len = $_mime->MLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $_mime->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			if ($str == '') return $str;
			else {
				$out = array();
				foreach (explode($end, $str) as $line) {
					if ($line == '') $out[] = '';
					else {
						$line = str_replace('=', '=3D', $line);
						$line = str_replace($_mime->qpkeys, $_mime->qpvrep, $line);
						preg_match_all('/.{1,'.$len.'}([^=]{0,2})?/', $line, $match);
						$mcnt = count($match[0]);
						for ($i = 0; $i < $mcnt; $i++) {
							$line = (substr($match[0][$i], -1) == ' ') ? substr($match[0][$i], 0, -1).'=20' : $match[0][$i];
							if (($i+1) < $mcnt) $line .= '=';
							$out[] = $line;
						}
					}
				}
				return implode($end, $out);
			}
		}
	}

	function encode_header($str = null, $charset = null, $encoding = null, $len = null, $end = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$_mime = new MIME4;
		$err = array();
		if (!is_string($str)) $err[] = 'invalid argument type';
		if ($charset == null) $charset = $_mime->HCHARSET;
		else if (!is_string($charset)) $err[] = 'invalid charset type';
		else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		if ($encoding == null) $encoding = $_mime->HENCDEF;
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$encoding = strtolower(FUNC4::str_clear($encoding));
			if (!isset($_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if ($len == null) $len = $_mime->HLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $_mime->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			if ($str == '') return $str;
			else {
				$enc = false;
				$dif = $len - strlen('=?'.$charset.'?X??=');
				if ($encoding == 'quoted-printable') {
					if (!MIME4::is_printable($str)) {
						$new = (($dif-4) > 2) ? ($dif-4) : $len;
						$enc = MIME4::qp_encode($str, $new, $end);
						$enc = str_replace(array('?', ' ', '='.$end), array('=3F', '_', $end), $enc);
					}
				} else if ($encoding == 'base64') {
					$new = ($dif > 3) ? $dif : $len;
					if ($new > 3) {
						for ($i = $new; $i > 2; $i--) {
							$crt = '';
							for ($j = 0; $j <= $i; $j++) $crt .= 'x';
							if (strlen(base64_encode($crt)) <= $new) {
								$new = $i;
								break;
							}
						}
					}
					$cnk = rtrim(chunk_split($str, $new, $end));
					$imp = array();
					foreach (explode($end, $cnk) as $line) if ($line != '') $imp[] = base64_encode($line);
					$enc = implode($end, $imp);
				}
				$res = array();
				if ($enc) {
					$chr = ($encoding == 'base64') ? 'B' : 'Q';
					foreach (explode($end, $enc) as $val) if ($val != '') $res[] = '=?'.$charset.'?'.$chr.'?'.$val.'?=';
				} else {
					$cnk = rtrim(chunk_split($str, $len, $end));
					foreach (explode($end, $cnk) as $val) if ($val != '') $res[] = $val;
				}
				return implode($end."\t", $res);
			}
		}
	}

	function decode_header($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($str)) FUNC4::trace($debug, 'invalid argument type');
		else {
			$_mime = new MIME4;
			$str = trim(FUNC4::str_clear($str));
			$arr = array();
			if ($str == '') $arr[] = array('charset' => $_mime->HCHARSET, 'value' => '');
			else {
				foreach (preg_split('/(?<!\\?(?i)q)\\?\\=/', $str, -1, PREG_SPLIT_NO_EMPTY) as $str1) {
					foreach (explode('=?', $str1, 2) as $str2) {
						$def = false;
						if (count($exp = explode('?B?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && FUNC4::is_alpha($exp[0], true, '-') && trim($exp[1]) != '') $def = array('charset' => $exp[0], 'value' => base64_decode(trim($exp[1])));
						} else if (count($exp = explode('?b?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && FUNC4::is_alpha($exp[0], true, '-') && trim($exp[1]) != '') $def = array('charset' => $exp[0], 'value' => base64_decode(trim($exp[1])));
						} else if (count($exp = explode('?Q?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && FUNC4::is_alpha($exp[0], true, '-') && $exp[1] != '') $def = array('charset' => $exp[0], 'value' => quoted_printable_decode(str_replace('_', ' ', $exp[1])));
						} else if (count($exp = explode('?q?', $str2)) == 2) {
							if (strlen($exp[0]) >= 2 && FUNC4::is_alpha($exp[0], true, '-') && $exp[1] != '') $def = array('charset' => $exp[0], 'value' => quoted_printable_decode(str_replace('_', ' ', $exp[1])));
						}
						if ($def) {
							if ($def['value'] != '') $arr[] = array('charset' => $def['charset'], 'value' => $def['value']);
						} else {
							if ($str2 != '') $arr[] = array('charset' => $_mime->HCHARSET, 'value' => $str2);
						}
					}
				}
			}
			return $arr;
		}
	}

	function decode_content($str = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($str)) $err[] = 'invalid content type';
		if ($encoding == null) $encoding = '7bit';
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$_mime = new MIME4;
			$encoding = strtolower($encoding);
			if (!isset($_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			if ($encoding == 'base64') {
				$str = trim(FUNC4::str_clear($str));
				return base64_decode($str);
			} else if ($encoding == 'quoted-printable') {
				return quoted_printable_decode($str);
			} else return $str;
		}
	}

	function message($content = null, $type = null, $name = null, $charset = null, $encoding = null, $disposition = null, $id = null, $len = null, $end = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$_mime = new MIME4;
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($type == null) $type = 'application/octet-stream';
		else if (is_string($type)) {
			$type = trim(FUNC4::str_clear($type));
			if (strlen($type) < 4) $err[] = 'invalid type value';
		} else $err[] = 'invalid type';
		if (is_string($name)) {
			$name = trim(FUNC4::str_clear($name));
			if ($name == '') $err[] = 'invalid name value';
		} else if ($name != null) $err[] = 'invalid name type';
		if ($charset == null) $charset = $_mime->MCHARSET;
		else if (!is_string($charset)) $err[] = 'invalid charset type';
		else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		if ($encoding == null) $encoding = $_mime->MENCDEF;
		else if (!is_string($encoding)) $err[] = 'invalid encoding type';
		else {
			$encoding = strtolower(FUNC4::str_clear($encoding));
			if (!isset($_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
		}
		if ($disposition == null) $disposition = 'inline';
		else if (is_string($disposition)) {
			$disposition = strtolower(FUNC4::str_clear($disposition));
			if (!($disposition == 'inline' || $disposition == 'attachment')) $err[] = 'invalid disposition value';
		} else $err[] = 'invalid disposition type';
		if (is_string($id)) {
			$id = FUNC4::str_clear($id, array(' '));
			if ($id == '') $err[] = 'invalid id value';
		} else if ($id != null) $err[] = 'invalid id type';
		if ($len == null) $len = $_mime->MLEN;
		else if (!(is_int($len) && $len > 1)) $err[] = 'invalid line length value';
		if ($end == null) $end = $_mime->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$header = ''.
				'Content-Type: '.$type.';'.$end."\t".'charset="'.$charset.'"'.
				(($name == null) ? '' : ';'.$end."\t".'name="'.$name.'"').$end.
				'Content-Transfer-Encoding: '.$encoding.$end.
				'Content-Disposition: '.$disposition.
				(($name == null) ? '' : ';'.$end."\t".'filename="'.$name.'"').
				(($id == null) ? '' : $end.'Content-ID: <'.$id.'>');
			if ($encoding == '7bit' || $encoding == '8bit') $content = wordwrap(MIME4::fix_eol($content), $len, $end, true);
			else if ($encoding == 'base64') $content = rtrim(chunk_split(base64_encode($content), $len, $end));
			else if ($encoding == 'quoted-printable') $content = MIME4::qp_encode(MIME4::fix_eol($content), $len, $end);
			return array('header' => $header, 'content' => $content);
		}
	}

	function compose($text = null, $html = null, $attach = null, $uniq = null, $end = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$_mime = new MIME4;
		$err = array();
		if ($text == null && $html == null) $err[] = 'message is not set';
		else {
			if ($text != null) {
				if (!(is_array($text) && isset($text['header'], $text['content']) && is_string($text['header']) && is_string($text['content']) && MIME4::isset_header($text['header'], 'content-type', 'text/plain', $debug))) $err[] = 'invalid text message type';
			}
			if ($html != null) {
				if (!(is_array($html) && isset($html['header'], $html['content']) && is_string($html['header']) && is_string($html['content']) && MIME4::isset_header($html['header'], 'content-type', 'text/html', $debug))) $err[] = 'invalid html message type';
			}
		}
		if ($attach != null) {
			if (is_array($attach) && count($attach) > 0) {
				foreach ($attach as $arr) {
					if (!(is_array($arr) && isset($arr['header'], $arr['content']) && is_string($arr['header']) && is_string($arr['content']) && (MIME4::isset_header($arr['header'], 'content-disposition', 'inline', $debug) || MIME4::isset_header($arr['header'], 'content-disposition', 'attachment', $debug)))) {
						$err[] = 'invalid attachment type';
						break;
					}
				}
			} else $err[] = 'invalid attachment format';
		}
		if ($end == null) $end = $_mime->LE;
		else if (!is_string($end)) $err[] = 'invalid line end value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$multipart = false;
			if ($text && $html) $multipart = true;
			if ($attach) $multipart = true;
			$header = $body = array();
			$header[] = 'Date: '.date('r');
            // Added by SysCo/al
            if (defined('XPM4_X-MAILER_CUSTOMIZED'))
            {
                $header[] = 'X-Mailer: '.constant('XPM4_X-MAILER_CUSTOMIZED');
            }
            else
            {
                $header[] = base64_decode('WC1NYWlsZXI6IFhQTTQgdi4wLjUgPCB3d3cueHBlcnRtYWlsZXIuY29tID4=');
            }
			if ($multipart) {
				$uniq = ($uniq == null) ? 0 : intval($uniq);
				$boundary1 = '=_1.'.MIME4::unique($uniq++);
				$boundary2 = '=_2.'.MIME4::unique($uniq++);
				$boundary3 = '=_3.'.MIME4::unique($uniq++);
				$disp['inline'] = $disp['attachment'] = false;
				if ($attach != null) {
					foreach ($attach as $darr) {
						if (MIME4::isset_header($darr['header'], 'content-disposition', 'inline', $debug)) $disp['inline'] = true;
						else if (MIME4::isset_header($darr['header'], 'content-disposition', 'attachment', $debug)) $disp['attachment'] = true;
					}
				}
				$hstr = 'Content-Type: multipart/%s;'.$end."\t".'boundary="%s"';
				$bstr = '--%s'.$end.'%s'.$end.$end.'%s';
				$body[] = 'This is a message in MIME Format. If you see this, your mail reader does not support this format.'.$end;
				if ($text && $html) {
						if ($disp['inline'] && $disp['attachment']) {
							$header[] = sprintf($hstr, 'mixed', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'related', $boundary2).$end;
							$body[] = '--'.$boundary2;
							$body[] = sprintf($hstr, 'alternative', $boundary3).$end;
							$body[] = sprintf($bstr, $boundary3, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary3, $html['header'], $html['content']);
							$body[] = '--'.$boundary3.'--';
							foreach ($attach as $desc) if (MIME4::isset_header($desc['header'], 'content-disposition', 'inline', $debug)) $body[] = sprintf($bstr, $boundary2, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) if (MIME4::isset_header($desc['header'], 'content-disposition', 'attachment', $debug)) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else if ($disp['inline']) {
							$header[] = sprintf($hstr, 'related', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'alternative', $boundary2).$end;
							$body[] = sprintf($bstr, $boundary2, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else if ($disp['attachment']) {
							$header[] = sprintf($hstr, 'mixed', $boundary1);
							$body[] = '--'.$boundary1;
							$body[] = sprintf($hstr, 'alternative', $boundary2).$end;
							$body[] = sprintf($bstr, $boundary2, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
							$body[] = '--'.$boundary2.'--';
							foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
							$body[] = '--'.$boundary1.'--';
						} else {
							$header[] = sprintf($hstr, 'alternative', $boundary1);
							$body[] = sprintf($bstr, $boundary1, $text['header'], $text['content']);
							$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
							$body[] = '--'.$boundary1.'--';
						}
				} else if ($text) {
					$header[] = sprintf($hstr, 'mixed', $boundary1);
					$body[] = sprintf($bstr, $boundary1, $text['header'], $text['content']);
					foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
					$body[] = '--'.$boundary1.'--';
				} else if ($html) {
					if ($disp['inline'] && $disp['attachment']) {
						$header[] = sprintf($hstr, 'mixed', $boundary1);
						$body[] = '--'.$boundary1;
						$body[] = sprintf($hstr, 'related', $boundary2).$end;
						$body[] = sprintf($bstr, $boundary2, $html['header'], $html['content']);
						foreach ($attach as $desc) if (MIME4::isset_header($desc['header'], 'content-disposition', 'inline', $debug)) $body[] = sprintf($bstr, $boundary2, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary2.'--';
						foreach ($attach as $desc) if (MIME4::isset_header($desc['header'], 'content-disposition', 'attachment', $debug)) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					} else if ($disp['inline']) {
						$header[] = sprintf($hstr, 'related', $boundary1);
						$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
						foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					} else if ($disp['attachment']) {
						$header[] = sprintf($hstr, 'mixed', $boundary1);
						$body[] = sprintf($bstr, $boundary1, $html['header'], $html['content']);
						foreach ($attach as $desc) $body[] = sprintf($bstr, $boundary1, $desc['header'], $desc['content']);
						$body[] = '--'.$boundary1.'--';
					}
				}
			} else {
				if ($text) {
					$header[] = $text['header'];
					$body[] = $text['content'];
				} else if ($html) {
					$header[] = $html['header'];
					$body[] = $html['content'];
				}
			}
			$header[] = 'MIME-Version: 1.0';
			return array('header' => implode($end, $header), 'content' => implode($end, $body));
		}
	}

	function isset_header($str = null, $name = null, $value = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($str) && $str != '')) $err[] = 'invalid header type';
		if (!(is_string($name) && strlen($name) > 1 && FUNC4::is_alpha($name, true, '-'))) $err[] = 'invalid name type';
		if ($value != null && !is_string($value)) $err[] = 'invalid value type';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if ($exp = MIME4::split_header($str, $debug)) {
				foreach ($exp as $harr) {
					if (strtolower($harr['name']) == strtolower($name)) {
						if ($value != null) $ret = (strtolower($harr['value']) == strtolower($value)) ? $harr['value'] : false;
						else $ret = $harr['value'];
						if ($ret) break;
					}
				}
			}
			return $ret;
		}
	}

	function split_header($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) FUNC4::trace($debug, 'invalid header value');
		else {
			$str = str_replace(array(";\r\n\t", "; \r\n\t", ";\r\n ", "; \r\n "), '; ', $str);
			$str = str_replace(array(";\n\t", "; \n\t", ";\n ", "; \n "), '; ', $str);
			$str = str_replace(array("\r\n\t", "\r\n "), '', $str);
			$str = str_replace(array("\n\t", "\n "), '', $str);
			$arr = array();
			foreach (explode("\n", $str) as $line) {
				$line = trim(FUNC4::str_clear($line));
				if ($line != '') {
					if (count($exp1 = explode(':', $line, 2)) == 2) {
						$name = rtrim($exp1[0]);
						$val1 = ltrim($exp1[1]);
						if (strlen($name) > 1 && FUNC4::is_alpha($name, true, '-') && $val1 != '') {
							$name = ucfirst($name);
							$hadd = array();
							if (substr(strtolower($name), 0, 8) == 'content-') {
								$exp2 = explode('; ', $val1);
								$cnt2 = count($exp2);
								if ($cnt2 > 1) {
									for ($i = 1; $i < $cnt2; $i++) {
										if (count($exp3 = explode('=', $exp2[$i], 2)) == 2) {
											$hset = trim($exp3[0]);
											$hval = trim($exp3[1], ' "');
											if ($hset != '' && $hval != '') $hadd[strtolower($hset)] = $hval;
										}
									}
								}
							}
							$val2 = (count($hadd) > 0) ? trim($exp2[0]) : $val1;
							$arr[] = array('name' => $name, 'value' => $val2, 'content' => $hadd);
						}
					}
				}
			}
			if (count($arr) > 0) return $arr;
			else FUNC4::trace($debug, 'invalid header value', 1);
		}
	}

	function split_message($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) FUNC4::trace($debug, 'invalid message value');
		else {
			$ret = false;
			if (strpos($str, "\r\n\r\n")) $ret = explode("\r\n\r\n", $str, 2);
			else if (strpos($str, "\n\n")) $ret = explode("\n\n", $str, 2);
			if ($ret) return array('header' => trim($ret[0]), 'content' => $ret[1]);
			else return false;
		}
	}

	function split_mail($str = null, &$headers, &$body, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$headers = $body = false;
		if (!$part = MIME4::split_message($str, $debug)) return false;
		if (!$harr = MIME4::split_header($part['header'], $debug)) return false;
		$type = $boundary = false;
		foreach ($harr as $hnum) {
			if (strtolower($hnum['name']) == 'content-type') {
				$type = strtolower($hnum['value']);
				foreach ($hnum['content'] as $hnam => $hval) {
					if (strtolower($hnam) == 'boundary') {
						$boundary = $hval;
						break;
					}
				}
				if ($boundary) break;
			}
		}
		$headers = $harr;
		$body = array();
		if (substr($type, 0, strlen('multipart/')) == 'multipart/' && $boundary && strstr($part['content'], '--'.$boundary.'--')) $body = MIME4::_parts($part['content'], $boundary, strtolower(substr($type, strlen('multipart/'))), $debug);
		if (count($body) == 0) $body[] = MIME4::_content($str, $debug);
	}

	function _parts($str = null, $boundary = null, $multipart = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($str) && $str != '')) $err[] = 'invalid content value';
		if (!(is_string($boundary) && $boundary != '')) $err[] = 'invalid boundary value';
		if (!(is_string($multipart) && $multipart != '')) $err[] = 'invalid multipart value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = array();
			if (count($exp = explode('--'.$boundary.'--', $str)) == 2) {
				if (count($exp = explode('--'.$boundary, $exp[0])) > 2) {
					$cnt = 0;
					foreach ($exp as $split) {
						$cnt++;
						if ($cnt > 1 && $part = MIME4::split_message($split, $debug)) {
							if ($harr = MIME4::split_header($part['header'], $debug)) {
								$type = $newb = false;
								foreach ($harr as $hnum) {
									if (strtolower($hnum['name']) == 'content-type') {
										$type = strtolower($hnum['value']);
										foreach ($hnum['content'] as $hnam => $hval) {
											if (strtolower($hnam) == 'boundary') {
												$newb = $hval;
												break;
											}
										}
										if ($newb) break;
									}
								}
								if (substr($type, 0, strlen('multipart/')) == 'multipart/' && $newb && strstr($part['content'], '--'.$newb.'--')) $ret = MIME4::_parts($part['content'], $newb, $multipart.'|'.strtolower(substr($type, strlen('multipart/'))), $debug);
								else {
									$res = MIME4::_content($split, $debug);
									$res['multipart'] = $multipart;
									$ret[] = $res;
								}
							}
						}
					}
				}
			}
			return $ret;
		}
	}

	function _content($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) FUNC4::trace($debug, 'invalid content value');
		else {
			if (!$part = MIME4::split_message($str, $debug)) return null;
			if (!$harr = MIME4::split_header($part['header'], $debug)) return null;
			$body = array();
			$clen = strlen('content-');
			$encoding = false;
			foreach ($harr as $hnum) {
				if (substr(strtolower($hnum['name']), 0, $clen) == 'content-') {
					$name = strtolower(substr($hnum['name'], $clen));
					if ($name == 'transfer-encoding') $encoding = strtolower($hnum['value']);
					else if ($name == 'id') $body[$name] = array('value' => trim($hnum['value'], '<>'), 'extra' => $hnum['content']);
					else $body[$name] = array('value' => $hnum['value'], 'extra' => $hnum['content']);
				}
			}
			if ($encoding == 'base64' || $encoding == 'quoted-printable') $body['content'] = MIME4::decode_content($part['content'], $encoding, $debug);
			else {
				if ($encoding) $body['transfer-encoding'] = $encoding;
				$body['content'] = $part['content'];
			}
			if (substr($body['content'], -2) == "\r\n") $body['content'] = substr($body['content'], 0, -2);
			else if (substr($body['content'], -1) == "\n") $body['content'] = substr($body['content'], 0, -1);
			return $body;
		}
	}

	function fix_eol($str = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!(is_string($str) && $str != '')) FUNC4::trace($debug, 'invalid content value');
		else {
			$_mime = new MIME4;
			$str = str_replace("\r\n", "\n", $str);
			$str = str_replace("\r", "\n", $str);
			if ($_mime->LE != "\n") $str = str_replace("\n", $_mime->LE, $str);
			return $str;
		}
	}

}

    }

    if (!class_exists('SMTP4')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('MIME4')) require_once 'MIME4.php';

$_RESULT = array();

class SMTP4 {

	var $CRLF = "\r\n";
	var $PORT = 25;
	var $TOUT = 30;
	var $COUT = 5;
	var $BLEN = 1024;

	function _cres($conn = null, &$resp, $code1 = null, $code2 = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!(is_int($code1) && $code1 > 99 && $code1 < 1000)) $err[] = 'invalid 1 code value';
		if ($code2 != null) {
			if (!(is_int($code2) && $code2 > 99 && $code2 < 1000)) $err[] = 'invalid 2 code value';
		}
		if (count($err) > 0) return FUNC4::trace($debug, implode(', ', $err), 1);
		else {
			$_smtp = new SMTP4;
			$ret = true;
			do {
				if ($result = fgets($conn, $_smtp->BLEN)) {
					$resp[] = $result;
					$rescode = substr($result, 0, 3);
					if (!($rescode == $code1 || $rescode == $code2)) {
						$ret = false;
						break;
					}
				} else {
					$resp[] = 'can not read';
					$ret = false;
					break;
				}
			} while ($result[3] == '-');
			return $ret;
		}
	}

	function mxconnect($host = null, $port = null, $tout = null, $name = null, $context = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($host)) FUNC4::trace($debug, 'invalid host type');
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && FUNC4::is_hostname($host, true, $debug))) FUNC4::trace($debug, 'invalid host value');
		}
		$res = FUNC4::is_win() ? FUNC4::getmxrr_win($host, $arr, $debug) : getmxrr($host, $arr);
		$con = false;
		if ($res) {
			foreach ($arr as $mx) {
				if ($con = SMTP4::connect($mx, $port, null, null, null, $tout, $name, $context, null, $debug)) break;
			}
		}
		if (!$con) $con = SMTP4::connect($host, $port, null, null, null, $tout, $name, $context, null, $debug);
		return $con;
	}
	
	function connect($host = null, $port = null, $user = null, $pass = null, $vssl = null, $tout = null, $name = null, $context = null, $login = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		$_smtp = new SMTP4;
		if ($port == null) $port = $_smtp->PORT;
		if ($tout == null) $tout = $_smtp->TOUT;
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || FUNC4::is_ipv4($host) || FUNC4::is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (!(is_int($port) && $port > 0)) $err[] = 'invalid port value';
		if ($user != null) {
			if (!is_string($user)) $err[] = 'invalid username type';
			else if (($user = FUNC4::str_clear($user)) == '') $err[] = 'invalid username value';
		}
		if ($pass != null) {
			if (!is_string($pass)) $err[] = 'invalid password type';
			else if (($pass = FUNC4::str_clear($pass)) == '') $err[] = 'invalid password value';
		}
		if (($user != null && $pass == null) || ($user == null && $pass != null)) $err[] = 'invalid username/password combination';
		if ($vssl != null) {
			if (!is_string($vssl)) $err[] = 'invalid ssl version type';
			else {
				$vssl = strtolower($vssl);
				if (!($vssl == 'tls' || $vssl == 'ssl' || $vssl == 'sslv2' || $vssl == 'sslv3')) $err[] = 'invalid ssl version value';
			}
		}
		if (!(is_int($tout) && $tout > 0)) $err[] = 'invalid timeout value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = strtolower(trim($name));
				if (!($name != '' && ($name == 'localhost' || FUNC4::is_ipv4($name) || FUNC4::is_hostname($name, true, $debug)))) $err[] = 'invalid name value';
			}
		} else $name = '127.0.0.1';
		if ($context != null && !is_resource($context)) $err[] = 'invalid context type';
		if ($login != null) {
			$login = strtolower(trim($login));
			if (!($login == 'login' || $login == 'plain' || $login == 'cram-md5')) $err[] = 'invalid authentication type value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$prt = ($vssl == null) ? 'tcp' : $vssl;
			$conn = ($context == null) ? fsockopen($prt.'://'.$host, $port, $errno, $errstr, $tout) : fsockopen($prt.'://'.$host, $port, $errno, $errstr, $tout, $context);
			if (!$conn) $_RESULT[101] = $errstr;
			else if (!socket_set_timeout($conn, $_smtp->COUT)) $_RESULT[102] = 'could not set socket timeout';
			else if (!SMTP4::_cres($conn, $resp, 220, null, $debug)) $_RESULT[103] = $resp;
			else {
				$continue = true;
				if (!SMTP4::ehlo($conn, $name, $debug)) $continue = SMTP4::helo($conn, $name, $debug);
				if ($continue) {
					if ($user == null) $ret = true;
					else if ($login != null) $ret = SMTP4::auth($conn, $user, $pass, $login, $debug);
					else {
						list($code, $arr) = each($_RESULT);
						$auth['default'] = $auth['login'] = $auth['plain'] = $auth['cram-md5'] = false;
						foreach ($arr as $line) {
							if (substr($line, 0, strlen('250-AUTH ')) == '250-AUTH ') {
								foreach (explode(' ', substr($line, strlen('250-AUTH '))) as $type) {
									$type = strtolower(trim($type));
									if ($type == 'login' || $type == 'plain' || $type == 'cram-md5') $auth[$type] = true;
								}
							} else if (substr($line, 0, strlen('250 AUTH=')) == '250 AUTH=') {
								$expl = explode(' ', strtolower(trim(substr($line, strlen('250 AUTH=')))), 2);
								if ($expl[0] == 'login' || $expl[0] == 'plain' || $expl[0] == 'cram-md5') $auth['default'] = $expl[0];
							}
						}
						if ($auth['default']) $ret = SMTP4::auth($conn, $user, $pass, $auth['default'], $debug);
						if (!$ret && $auth['login'] && $auth['default'] != 'login') $ret = SMTP4::auth($conn, $user, $pass, 'login', $debug);
						if (!$ret && $auth['plain'] && $auth['default'] != 'plain') $ret = SMTP4::auth($conn, $user, $pass, 'plain', $debug);
						if (!$ret && $auth['cram-md5'] && $auth['default'] != 'cram-md5') $ret = SMTP4::auth($conn, $user, $pass, 'cram-md5', $debug);
						if (!$ret && !$auth['login'] && $auth['default'] != 'login') $ret = SMTP4::auth($conn, $user, $pass, 'login', $debug);
						if (!$ret && !$auth['plain'] && $auth['default'] != 'plain') $ret = SMTP4::auth($conn, $user, $pass, 'plain', $debug);
						if (!$ret && !$auth['cram-md5'] && $auth['default'] != 'cram-md5') $ret = SMTP4::auth($conn, $user, $pass, 'cram-md5', $debug);
					}
				}
			}
			if (!$ret) {
				if (is_resource($conn)) SMTP4::disconnect($conn, $debug);
				$conn = false;
			}
			return $conn;
		}
	}

	function send($conn = null, $addrs = null, $mess = null, $from = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_array($addrs)) $err[] = 'invalid to address type';
		else {
			$aver = true;
			if (count($addrs) > 0) {
				foreach ($addrs as $addr) {
					if (!FUNC4::is_mail($addr)) {
						$aver = false;
						break;
					}
				}
			} else $aver = false;
			if (!$aver) $err[] = 'invalid to address value';
		}
		if (!is_string($mess)) $err[] = 'invalid message value';
		if ($from == null) {
			$from = @ini_get('sendmail_from');
			if ($from == '' || !FUNC4::is_mail($from)) $from = (isset($_SERVER['SERVER_ADMIN']) && FUNC4::is_mail($_SERVER['SERVER_ADMIN'])) ? $_SERVER['SERVER_ADMIN'] : 'postmaster@localhost';
		} else {
			if (!is_string($from)) $err[] = 'invalid from address type';
			else if (!($from != '' && FUNC4::is_mail($from))) $err[] = 'invalid from address value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			if (SMTP4::from($conn, $from, $debug)) {
				$continue = true;
				foreach ($addrs as $dest) {
					if (!SMTP4::to($conn, $dest, $debug)) {
						$continue = false;
						break;
					}
				}
				if ($continue) {
					if (SMTP4::data($conn, $mess, $debug)) $ret = SMTP4::rset($conn, $debug);
				}
			}
			return $ret;
		}
	}

	function disconnect($conn = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		if (!is_resource($conn)) return FUNC4::trace($debug, 'invalid resource connection', 1);
		else {
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'QUIT'.$_smtp->CRLF)) $_RESULT[300] = 'can not write';
			else $_RESULT[301] = 'Send QUIT';
			return @fclose($conn);
		}
	}

	function quit($conn = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		$_smtp = new SMTP4;
		if (!is_resource($conn)) FUNC4::trace($debug, 'invalid resource connection');
		else if (!fwrite($conn, 'QUIT'.$_smtp->CRLF)) $_RESULT[302] = 'can not write';
		else {
			$_RESULT[303] = ($vget = @fgets($conn, $_smtp->BLEN)) ? $vget : 'can not read';
			$ret = true;
		}
		return $ret;
	}

	function helo($conn = null, $host = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || FUNC4::is_ipv4($host) || FUNC4::is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'HELO '.$host.$_smtp->CRLF)) $_RESULT[304] = 'can not write';
			else if (!SMTP4::_cres($conn, $resp, 250, null, $debug)) $_RESULT[305] = $resp;
			else {
				$_RESULT[306] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function ehlo($conn = null, $host = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($host)) $err[] = 'invalid host type';
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || FUNC4::is_ipv4($host) || FUNC4::is_hostname($host, true, $debug)))) $err[] = 'invalid host value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'EHLO '.$host.$_smtp->CRLF)) $_RESULT[307] = 'can not write';
			else if (!SMTP4::_cres($conn, $resp, 250, null, $debug)) $_RESULT[308] = $resp;
			else {
				$_RESULT[309] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function auth($conn = null, $user = null, $pass = null, $type = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($user)) $err[] = 'invalid username type';
		else if (($user = FUNC4::str_clear($user)) == '') $err[] = 'invalid username value';
		if (!is_string($pass)) $err[] = 'invalid password type';
		else if (($pass = FUNC4::str_clear($pass)) == '') $err[] = 'invalid password value';
		if ($type == null) $type = 'login';
		if (!is_string($type)) $err[] = 'invalid authentication type';
		else {
			$type = strtolower(trim($type));
			if (!($type == 'login' || $type == 'plain' || $type == 'cram-md5')) $err[] = 'invalid authentication type value';
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if ($type == 'login') {
				if (!fwrite($conn, 'AUTH LOGIN'.$_smtp->CRLF)) $_RESULT[310] = 'can not write';
				else if (!SMTP4::_cres($conn, $resp, 334, null, $debug)) $_RESULT[311] = $resp;
				else if (!fwrite($conn, base64_encode($user).$_smtp->CRLF)) $_RESULT[312] = 'can not write';
				else if (!SMTP4::_cres($conn, $resp, 334, null, $debug)) $_RESULT[313] = $resp;
				else if (!fwrite($conn, base64_encode($pass).$_smtp->CRLF)) $_RESULT[314] = 'can not write';
				else if (!SMTP4::_cres($conn, $resp, 235, null, $debug)) $_RESULT[315] = $resp;
				else {
					$_RESULT[316] = $resp;
					$ret = true;
				}
			} else if ($type == 'plain') {
				if (!fwrite($conn, 'AUTH PLAIN '.base64_encode($user.chr(0).$user.chr(0).$pass).$_smtp->CRLF)) $_RESULT[317] = 'can not write';
				else if (!SMTP4::_cres($conn, $resp, 235, null, $debug)) $_RESULT[318] = $resp;
				else {
					$_RESULT[319] = $resp;
					$ret = true;
				}
			} else if ($type == 'cram-md5') {
				if (!fwrite($conn, 'AUTH CRAM-MD5'.$_smtp->CRLF)) $_RESULT[200] = 'can not write';
				else if (!SMTP4::_cres($conn, $resp, 334, null, $debug)) $_RESULT[201] = $resp;
				else {
					if (strlen($pass) > 64) $pass = pack('H32', md5($pass));
					if (strlen($pass) < 64) $pass = str_pad($pass, 64, chr(0));
					$pad1 = substr($pass, 0, 64) ^ str_repeat(chr(0x36), 64);
					$pad2 = substr($pass, 0, 64) ^ str_repeat(chr(0x5C), 64);
					$chal = substr($resp[count($resp)-1], 4);
					$innr = pack('H32', md5($pad1.base64_decode($chal)));
					if (!fwrite($conn, base64_encode($user.' '.md5($pad2.$innr)).$_smtp->CRLF)) $_RESULT[202] = 'can not write';
					else if (!SMTP4::_cres($conn, $resp, 235, null, $debug)) $_RESULT[203] = $resp;
					else {
						$_RESULT[204] = $resp;
						$ret = true;
					}
				}
			}
			return $ret;
		}
	}

	function from($conn = null, $addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($addr)) $err[] = 'invalid from address type';
		else if (!($addr != '' && FUNC4::is_mail($addr))) $err[] = 'invalid from address value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'MAIL FROM:<'.$addr.'>'.$_smtp->CRLF)) $_RESULT[320] = 'can not write';
			else if (!SMTP4::_cres($conn, $resp, 250, null, $debug)) $_RESULT[321] = $resp;
			else {
				$_RESULT[322] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function to($conn = null, $addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!is_string($addr)) $err[] = 'invalid to address type';
		else if (!($addr != '' && FUNC4::is_mail($addr))) $err[] = 'invalid to address value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'RCPT TO:<'.$addr.'>'.$_smtp->CRLF)) $_RESULT[323] = 'can not write';
			else if (!SMTP4::_cres($conn, $resp, 250, 251, $debug)) $_RESULT[324] = $resp;
			else {
				$_RESULT[325] = $resp;
				$ret = true;
			}
			return $ret;
		}
	}

	function data($conn = null, $mess = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = $err = array();
		if (!is_resource($conn)) $err[] = 'invalid resource connection';
		if (!(is_string($mess) && $mess != '')) $err[] = 'invalid message value';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ret = false;
			$_smtp = new SMTP4;
			if (!fwrite($conn, 'DATA'.$_smtp->CRLF)) $_RESULT[326] = 'can not write';
			else if (!SMTP4::_cres($conn, $resp, 354, null, $debug)) $_RESULT[327] = $resp;
			else {
				$continue = true;
				foreach (explode($_smtp->CRLF, $mess) as $line) {
					if ($line != '' && $line[0] == '.') $line = '.'.$line;
					if (!fwrite($conn, $line.$_smtp->CRLF)) {
						$_RESULT[328] = 'can not write';
						$continue = false;
						break;
					}
				}
				if ($continue) {
					if (!fwrite($conn, '.'.$_smtp->CRLF)) $_RESULT[329] = 'can not write';
					else if (!SMTP4::_cres($conn, $resp, 250, null, $debug)) $_RESULT[330] = $resp;
					else {
						$_RESULT[331] = $resp;
						$ret = true;
					}
				}
			}
			return $ret;
		}
	}

	function rset($conn = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		$_smtp = new SMTP4;
		if (!is_resource($conn)) FUNC4::trace($debug, 'invalid resource connection');
		else if (!fwrite($conn, 'RSET'.$_smtp->CRLF)) $_RESULT[332] = 'can not write';
		else if (!SMTP4::_cres($conn, $resp, 250, null, $debug)) $_RESULT[333] = $resp;
		else {
			$_RESULT[334] = $resp;
			$ret = true;
		}
		return $ret;
	}

	function recv($conn = null, $code1 = null, $code2 = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		global $_RESULT;
		$_RESULT = array();
		$ret = false;
		if (!SMTP4::_cres($conn, $resp, $code1, $code2, $debug)) $_RESULT[335] = $resp;
		else {
			$_RESULT[336] = $resp;
			$ret = true;
		}
		return $ret;
	}

}

    }

    if (!class_exists('MAIL4')) {
        
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                                         *
 *  XPertMailer is a PHP Mail Class that can send and read messages in MIME format.        *
 *  This file is part of the XPertMailer package (http://xpertmailer.sourceforge.net/)     *
 *  Copyright (C) 2007 Tanase Laurentiu Iulian                                             *
 *                                                                                         *
 *  This library is free software; you can redistribute it and/or modify it under the      *
 *  terms of the GNU Lesser General Public License as published by the Free Software       *
 *  Foundation; either version 2.1 of the License, or (at your option) any later version.  *
 *                                                                                         *
 *  This library is distributed in the hope that it will be useful, but WITHOUT ANY        *
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A        *
 *  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.        *
 *                                                                                         *
 *  You should have received a copy of the GNU Lesser General Public License along with    *
 *  this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, *
 *  Fifth Floor, Boston, MA 02110-1301, USA                                                *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if (!class_exists('SMTP4')) require_once 'SMTP4.php';

class MAIL4 {

	var $From = null;
	var $To = array();
	var $Cc = array();
	var $Bcc = array();

	var $Subject = null;
	var $Text = null;
	var $Html = null;
	var $Header = array();
	var $Attach = array();

	var $Host = null;
	var $Port = null;
	var $User = null;
	var $Pass = null;
	var $Vssl = null;
	var $Tout = null;
	var $Auth = null;

	var $Name = null;
	var $Path = null;
	var $Priority = null;

	var $Context = null;

	var $SendMail = '/usr/sbin/sendmail';
	var $QMail = '/var/qmail/bin/sendmail';

	var $_conns = array();
	var $History = array();
	var $Result = null;

	var $_mime;
	var $_smtp;

	function MAIL4() {
		$this->_mime = new MIME4;
		$this->_smtp = new SMTP4;
		$this->_result(array(0 => 'initialize class'));
	}

	function _result($data = array(), $ret = null) {
		$this->History[][strval(FUNC4::microtime_float())] = $data;
		$this->Result = $data;
		return $ret;
	}

	function context($arr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_array($arr)) FUNC4::trace($debug, 'invalid context type');
		else if (!is_resource($res = stream_context_create($arr))) FUNC4::trace($debug, 'invalid context value');
		else {
			$this->Context = $res;
			return $this->_result(array(0 => 'set context connection'), true);
		}
	}

	function name($host = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($host)) FUNC4::trace($debug, 'invalid hostname type');
		else {
			$host = strtolower(trim($host));
			if (!($host != '' && ($host == 'localhost' || FUNC4::is_ipv4($host) || FUNC4::is_hostname($host, true, $debug)))) FUNC4::trace($debug, 'invalid hostname value');
			$this->Name = $host;
			return $this->_result(array(0 => 'set HELO/EHLO hostname'), true);
		}
	}

	function path($addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($addr)) FUNC4::trace($debug, 'invalid address type');
		else {
			if (!($addr != '' && FUNC4::is_mail($addr))) FUNC4::trace($debug, 'invalid address value');
			$this->Path = $addr;
			return $this->_result(array(0 => 'set Return-Path address'), true);
		}
	}

	function priority($level = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($level == null) {
			$this->Priority = null;
			return $this->_result(array(0 => 'unset priority'), true);
		} else if (is_int($level) || is_string($level)) {
			if (is_string($level)) $level = strtolower(trim(FUNC4::str_clear($level)));
			if ($level == 1 || $level == 3 || $level == 5 || $level == 'high' || $level == 'normal' || $level == 'low') {
				$this->Priority = $level;
				return $this->_result(array(0 => 'set priority'), true);
			} else FUNC4::trace($debug, 'invalid level value');
		} else FUNC4::trace($debug, 'invalid level type');
	}

	function from($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!FUNC4::is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim(FUNC4::str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$this->From = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set From address'), true);
		}
	}

	function addto($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!FUNC4::is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim(FUNC4::str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$find = false;
			if (count($this->To) > 0) {
				$ladr = strtolower($addr);
				foreach ($this->To as $to) {
					if ($ladr == strtolower($to['address'])) {
						FUNC4::trace($debug, 'duplicate To address "'.$addr.'"', 1);
						$find = true;
					}
				}
			}
			if ($find) return false;
			else {
				$this->To[] = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add To address'), true);
			}
		}
	}

	function delto($addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->To = array();
			return $this->_result(array(0 => 'delete all To addresses'), true);
		} else if (!(is_string($addr) && FUNC4::is_mail($addr))) {
			FUNC4::trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->To) > 0) {
				$addr = strtolower($addr);
				foreach ($this->To as $to) {
					if ($addr == strtolower($to['address'])) $ret = true;
					else $new[] = $to;
				}
			}
			if ($ret) {
				$this->To = $new;
				return $this->_result(array(0 => 'delete To address'), true);
			} else return FUNC4::trace($debug, 'To address "'.$addr.'" not found', 1);
		}
	}

	function addcc($addr = null, $name = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($addr)) $err[] = 'invalid address type';
		else if (!FUNC4::is_mail($addr)) $err[] = 'invalid address value';
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim(FUNC4::str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$find = false;
			if (count($this->Cc) > 0) {
				$ladr = strtolower($addr);
				foreach ($this->Cc as $cc) {
					if ($ladr == strtolower($cc['address'])) {
						FUNC4::trace($debug, 'duplicate Cc address "'.$addr.'"', 1);
						$find = true;
					}
				}
			}
			if ($find) return false;
			else {
				$this->Cc[] = array('address' => $addr, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add Cc address'), true);
			}
		}
	}

	function delcc($addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->Cc = array();
			return $this->_result(array(0 => 'delete all Cc addresses'), true);
		} else if (!(is_string($addr) && FUNC4::is_mail($addr))) {
			FUNC4::trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Cc) > 0) {
				$addr = strtolower($addr);
				foreach ($this->Cc as $cc) {
					if ($addr == strtolower($cc['address'])) $ret = true;
					else $new[] = $cc;
				}
			}
			if ($ret) {
				$this->Cc = $new;
				return $this->_result(array(0 => 'delete Cc address'), true);
			} else return FUNC4::trace($debug, 'Cc address "'.$addr.'" not found', 1);
		}
	}

	function addbcc($addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (!is_string($addr)) FUNC4::trace($debug, 'invalid address type');
		else if (!FUNC4::is_mail($addr)) FUNC4::trace($debug, 'invalid address value');
		$find = false;
		if (count($this->Bcc) > 0) {
			$ladr = strtolower($addr);
			foreach ($this->Bcc as $bcc) {
				if ($ladr == strtolower($bcc)) {
					FUNC4::trace($debug, 'duplicate Bcc address "'.$addr.'"', 1);
					$find = true;
				}
			}
		}
		if ($find) return false;
		else {
			$this->Bcc[] = $addr;
			return $this->_result(array(0 => 'add Bcc address'), true);
		}
	}

	function delbcc($addr = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($addr == null) {
			$this->Bcc = array();
			return $this->_result(array(0 => 'delete all Bcc addresses'), true);
		} else if (!(is_string($addr) && FUNC4::is_mail($addr))) {
			FUNC4::trace($debug, 'invalid address value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Bcc) > 0) {
				$addr = strtolower($addr);
				foreach ($this->Bcc as $bcc) {
					if ($addr == strtolower($bcc)) $ret = true;
					else $new[] = $bcc;
				}
			}
			if ($ret) {
				$this->Bcc = $new;
				return $this->_result(array(0 => 'delete Bcc address'), true);
			} else return FUNC4::trace($debug, 'Bcc address "'.$addr.'" not found', 1);
		}
	}

	function addheader($name = null, $value = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($name)) $err[] = 'invalid name type';
		else {
			$name = ucfirst(trim(FUNC4::str_clear($name)));
			if (!(strlen($name) >= 2 && FUNC4::is_alpha($name, true, '-'))) $err[] = 'invalid name value';
		}
		if (!is_string($value)) $err[] = 'invalid content type';
		else {
			$value = trim(FUNC4::str_clear($value));
			if ($value == '') $err[] = 'invalid content value';
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$ver = strtolower($name);
			$err = false;
			if ($ver == 'to') $err = 'can not set "To", for this, use function "AddTo()"';
			else if ($ver == 'cc') $err = 'can not set "Cc", for this, use function "AddCc()"';
			else if ($ver == 'bcc') $err = 'can not set "Bcc", for this, use function "AddBcc()"';
			else if ($ver == 'from') $err = 'can not set "From", for this, use function "From()"';
			else if ($ver == 'subject') $err = 'can not set "Subject", for this, use function "Subject()"';
			else if ($ver == 'x-priority') $err = 'can not set "X-Priority", for this, use function "Priority()"';
			else if ($ver == 'x-msmail-priority') $err = 'can not set "X-MSMail-Priority", for this, use function "Priority()"';
			else if ($ver == 'x-mimeole') $err = 'can not set "X-MimeOLE", for this, use function "Priority()"';
			else if ($ver == 'date') $err = 'can not set "Date", this value is automaticaly set';
			else if ($ver == 'content-type') $err = 'can not set "Content-Type", this value is automaticaly set';
			else if ($ver == 'content-transfer-encoding') $err = 'can not set "Content-Transfer-Encoding", this value is automaticaly set';
			else if ($ver == 'content-disposition') $err = 'can not set "Content-Disposition", this value is automaticaly set';
			else if ($ver == 'mime-version') $err = 'can not set "Mime-Version", this value is automaticaly set';
			else if ($ver == 'x-mailer') $err = 'can not set "X-Mailer", this value is automaticaly set';
			else if ($ver == 'message-id') $err = 'can not set "Message-ID", this value is automaticaly set';
			if ($err) FUNC4::trace($debug, $err);
			else {
				$this->Header[] = array('name' => $name, 'value' => $value, 'charset' => $charset, 'encoding' => $encoding);
				return $this->_result(array(0 => 'add header'), true);
			}
		}
	}

	function delheader($name = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($name == null) {
			$this->Header = array();
			return $this->_result(array(0 => 'delete all headers'), true);
		} else if (!(is_string($name) && strlen($name) >= 2 && FUNC4::is_alpha($name, true, '-'))) {
			FUNC4::trace($debug, 'invalid name value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Header) > 0) {
				$name = strtolower($name);
				foreach ($this->Header as $header) {
					if ($name == strtolower($header['name'])) $ret = true;
					else $new[] = $header;
				}
			}
			if ($ret) {
				$this->Header = $new;
				return $this->_result(array(0 => 'delete header'), true);
			} else return FUNC4::trace($debug, 'header not found', 1);
		}
	}

	function subject($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!is_string($content)) $err[] = 'invalid content type';
		else {
			$content = trim(FUNC4::str_clear($content));
			if ($content == '') $err[] = 'invalid content value';
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->hencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$this->Subject = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set subject'), true);
		}
	}

	function text($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$this->Text = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set text version'), true);
		}
	}

	function html($content = null, $charset = null, $encoding = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding != null) {
			if (!is_string($encoding)) $err[] = 'invalid encoding type';
			else {
				$encoding = strtolower($encoding);
				if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$this->Html = array('content' => $content, 'charset' => $charset, 'encoding' => $encoding);
			return $this->_result(array(0 => 'set html version'), true);
		}
	}

	function attach($content = null, $type = null, $name = null, $charset = null, $encoding = null, $disposition = null, $id = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		$err = array();
		if (!(is_string($content) && $content != '')) $err[] = 'invalid content type';
		if ($type != null) {
			if (!is_string($type)) $err[] = 'invalid type value';
			else {
				$type = trim(FUNC4::str_clear($type));
				if (strlen($type) < 4) $err[] = 'invalid type value';
			}
		}
		if ($name != null) {
			if (!is_string($name)) $err[] = 'invalid name type';
			else {
				$name = trim(FUNC4::str_clear($name));
				if ($name == '') $err[] = 'invalid name value';
			}
		}
		if ($charset != null) {
			if (!is_string($charset)) $err[] = 'invalid charset type';
			else if (!(strlen($charset) >= 2 && FUNC4::is_alpha($charset, true, '-'))) $err[] = 'invalid charset value';
		}
		if ($encoding == null) $encoding = 'base64';
		else if (is_string($encoding)) {
			$encoding = strtolower($encoding);
			if (!isset($this->_mime->mencarr[$encoding])) $err[] = 'invalid encoding value';
		} else $err[] = 'invalid encoding type';
		if ($disposition == null) $disposition = 'attachment';
		else if (is_string($disposition)) {
			$disposition = strtolower(FUNC4::str_clear($disposition));
			if (!($disposition == 'inline' || $disposition == 'attachment')) $err[] = 'invalid disposition value';
		} else $err[] = 'invalid disposition type';
		if ($id != null) {
			if (!is_string($id)) $err[] = 'invalid id type';
			else {
				$id = FUNC4::str_clear($id, array(' '));
				if ($id == '') $err[] = 'invalid id value';
			}
		}
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$this->Attach[] = array('content' => $content, 'type' => $type, 'name' => $name, 'charset' => $charset, 'encoding' => $encoding, 'disposition' => $disposition, 'id' => $id);
			return $this->_result(array(0 => 'add attachment'), true);
		}
	}

	function delattach($name = null, $debug = null) {
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($name == null) {
			$this->Attach = array();
			return $this->_result(array(0 => 'delete all attachments'), true);
		} else if (!(is_string($name) && strlen($name) > 1)) {
			FUNC4::trace($debug, 'invalid name value');
		} else {
			$ret = false;
			$new = array();
			if (count($this->Attach) > 0) {
				$name = strtolower($name);
				foreach ($this->Attach as $att) {
					if ($name == strtolower($att['name'])) $ret = true;
					else $new[] = $att;
				}
			}
			if ($ret) {
				$this->Attach = $new;
				return $this->_result(array(0 => 'delete attachment'), true);
			} else return FUNC4::trace($debug, 'attachment not found', 1);
		}
	}

	function connect($host = null, $port = null, $user = null, $pass = null, $vssl = null, $tout = null, $name = null, $context = null, $auth = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($host == null) $host = $this->Host;
		if ($port == null) $port = $this->Port;
		if ($user == null) $user = $this->User;
		if ($pass == null) $pass = $this->Pass;
		if ($vssl == null) $vssl = $this->Vssl;
		if ($tout == null) $tout = $this->Tout;
		if ($name == null) $name = $this->Name;
		if ($context == null) $context = $this->Context;
		if ($auth == null) $auth = $this->Auth;
		if ($ret = SMTP4::connect($host, $port, $user, $pass, $vssl, $tout, $name, $context, $auth, $debug)) $this->_conns[] = $ret;
		return $this->_result($_RESULT, $ret);
	}

	function disconnect($resc = null, $debug = null) {
		global $_RESULT;
		$_RESULT = array();
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if ($resc != null) {
			if (count($this->_conns) > 0) {
				$new = array();
				foreach ($this->_conns as $cres) {
					if ($cres != $resc) $new[] = $cres;
				}
				$this->_conns = $new;
			}
			$disc = SMTP4::disconnect($resc, $debug);
			return $this->_result($_RESULT, $disc);
		} else {
			$rarr = array();
			$disc = true;
			if (count($this->_conns) > 0) {
				foreach ($this->_conns as $cres) {
					if (!SMTP4::disconnect($cres, $debug)) $disc = false;
					$rarr[] = $_RESULT;
				}
			}
			return $this->_result($rarr, $disc);
		}
	}

	function send($resc = null, $debug = null) {
		global $_RESULT;
		$_RESULT = $err = array();
		if (!FUNC4::is_debug($debug)) $debug = debug_backtrace();
		if (is_resource($resc)) $delivery = 'relay';
		else {
			if ($resc == null) $resc = 'local';
			if (!is_string($resc)) $err[] = 'invalid connection type';
			else {
				$resc = strtolower(trim($resc));
				if ($resc == 'local' || $resc == 'client' || $resc == 'sendmail' || $resc == 'qmail') $delivery = $resc;
				else $err[] = 'invalid connection value';
			}
		}
		if (count($this->To) == 0) $err[] = 'to mail address is not set';
		if (!isset($this->Subject['content'])) $err[] = 'mail subject is not set';
		if (!(isset($this->Text['content']) || isset($this->Html['content']))) $err[] = 'mail message is not set';
		if (count($err) > 0) FUNC4::trace($debug, implode(', ', $err));
		else {
			$header['local'] = $header['client'] = array();
			$body = '';
			$from = null;
			if (isset($this->From['address']) && is_string($this->From['address'])) {
				$from = $this->From['address'];
				$hv = 'From: ';
				if (isset($this->From['name']) && trim($this->From['name']) != '') {
					$hn = MIME4::encode_header($this->From['name'], 
						isset($this->From['charset']) ? $this->From['charset'] : null, 
						isset($this->From['encoding']) ? $this->From['encoding'] : null, 
						null, null, $debug);
					if ($hn == $this->From['name']) $hn = '"'.str_replace('"', '\\"', $this->From['name']).'"';
					$hv .= $hn.' <'.$this->From['address'].'>';
				} else $hv .= $this->From['address'];
				$header['local'][] = $hv;
				$header['client'][] = $hv;
			}
			$addrs = $arr = array();
			foreach ($this->To as $to) {
				if (isset($to['address']) && FUNC4::is_mail($to['address'], false, $debug)) {
					$addrs[] = $to['address'];
					if (isset($to['name']) && trim($to['name']) != '') {
						$hn = MIME4::encode_header($to['name'], 
							isset($to['charset']) ? $to['charset'] : null, 
							isset($to['encoding']) ? $to['encoding'] : null, 
							null, null, $debug);
						if ($hn == $to['name']) $hn = '"'.str_replace('"', '\\"', $to['name']).'"';
						$arr[] = $hn.' <'.$to['address'].'>';
					} else $arr[] = $to['address'];
				}
			}
			if (count($arr) > 0) {
				$to = implode(', ', $arr);
				$header['client'][] = 'To: '.implode(', '.$this->_mime->LE."\t", $arr);
			} else FUNC4::trace($debug, 'to mail address is not set');
			if (count($this->Cc) > 0) {
				$arr = array();
				foreach ($this->Cc as $cc) {
					if (isset($cc['address']) && FUNC4::is_mail($cc['address'], false, $debug)) {
						$addrs[] = $cc['address'];
						if (isset($cc['name']) && trim($cc['name']) != '') {
							$hn = MIME4::encode_header($cc['name'], 
								isset($cc['charset']) ? $cc['charset'] : null, 
								isset($cc['encoding']) ? $cc['encoding'] : null, 
								null, null, $debug);
							if ($hn == $cc['name']) $hn = '"'.str_replace('"', '\\"', $cc['name']).'"';
							$arr[] = $hn.' <'.$cc['address'].'>';
						} else $arr[] = $cc['address'];
					}
				}
				if (count($arr) > 0) {
					$header['local'][] = 'Cc: '.implode(', ', $arr);
					$header['client'][] = 'Cc: '.implode(', '.$this->_mime->LE."\t", $arr);
				}
			}
			$hbcc = '';
			if (count($this->Bcc) > 0) {
				$arr = array();
				foreach ($this->Bcc as $bcc) {
					if (FUNC4::is_mail($bcc, false, $debug)) {
						$arr[] = $bcc;
						$addrs[] = $bcc;
					}
				}
				if (count($arr) > 0) {
					$header['local'][] = 'Bcc: '.implode(', ', $arr);
					$hbcc = $this->_mime->LE.'Bcc: '.implode(', ', $arr);
				}
			}
			$hn = MIME4::encode_header($this->Subject['content'], 
				isset($this->Subject['charset']) ? $this->Subject['charset'] : null, 
				isset($this->Subject['encoding']) ? $this->Subject['encoding'] : null, 
				null, null, $debug);
			$subject = $hn;
			$header['client'][] = 'Subject: '.$hn;
			if (is_int($this->Priority) || is_string($this->Priority)) {
				$arr = false;
				if ($this->Priority == 1 || $this->Priority == 'high') $arr = array(1, 'high');
				else if ($this->Priority == 3 || $this->Priority == 'normal') $arr = array(3, 'normal');
				else if ($this->Priority == 5 || $this->Priority == 'low') $arr = array(5, 'low');
				if ($arr) {
					$header['local'][] = 'X-Priority: '.$arr[0];
					$header['local'][] = 'X-MSMail-Priority: '.$arr[1];
                    // Added by SysCo/al
                    if (defined('XPM4_X-MIMEOLE_CUSTOMIZED'))
                    {
                        $xmimeoleinfo = 'X-MimeOLE: '.constant('XPM4_X-MIMEOLE_CUSTOMIZED');
                    }
                    else
                    {
                        $xmimeoleinfo = 'X-MimeOLE: Produced By XPertMailer v.4 MIME Class';
                    }
					$header['local'][] = $xmimeoleinfo; // << required by SpamAssassin in conjunction with "X-MSMail-Priority"
					$header['client'][] = 'X-Priority: '.$arr[0];
					$header['client'][] = 'X-MSMail-Priority: '.$arr[1];
					$header['client'][] = $xmimeoleinfo;
				}
			}
            // Added by SysCo/al
            if (defined('XPM4_MESSAGE_ID_CUSTOMIZED'))
            {
                $header['client'][] = 'Message-ID: <'.MIME5::unique().'@'.constant('XPM4_MESSAGE_ID_CUSTOMIZED').'>';
            }
            else
            {
                $header['client'][] = 'Message-ID: <'.MIME5::unique().'@xpertmailer.com>';
            }
			if (count($this->Header) > 0) {
				foreach ($this->Header as $harr) {
					if (isset($harr['name'], $harr['value']) && strlen($harr['name']) >= 2 && FUNC4::is_alpha($harr['name'], true, '-')) {
						$hn = MIME4::encode_header($harr['value'], 
							isset($harr['charset']) ? $harr['charset'] : null, 
							isset($harr['encoding']) ? $harr['encoding'] : null, 
							null, null, $debug);
						$header['local'][] = ucfirst($harr['name']).': '.$hn;
						$header['client'][] = ucfirst($harr['name']).': '.$hn;
					}
				}
			}
			$text = $html = $att = null;
			if (isset($this->Text['content'])) {
				$text = MIME4::message($this->Text['content'], 'text/plain', null, 
					isset($this->Text['charset']) ? $this->Text['charset'] : null, 
					isset($this->Text['encoding']) ? $this->Text['encoding'] : null, 
					null, null, null, null, $debug);
			}
			if (isset($this->Html['content'])) {
				$html = MIME4::message($this->Html['content'], 'text/html', null, 
					isset($this->Html['charset']) ? $this->Html['charset'] : null, 
					isset($this->Html['encoding']) ? $this->Html['encoding'] : null, 
					null, null, null, null, $debug);
			}
			if (count($this->Attach) > 0) {
				$att = array();
				foreach ($this->Attach as $attach) {
					if (isset($attach['content'])) {
						$att[] = MIME4::message($attach['content'], 
							isset($attach['type']) ? $attach['type'] : null, 
							isset($attach['name']) ? $attach['name'] : null, 
							isset($attach['charset']) ? $attach['charset'] : null, 
							isset($attach['encoding']) ? $attach['encoding'] : null, 
							isset($attach['disposition']) ? $attach['disposition'] : null, 
							isset($attach['id']) ? $attach['id'] : null, 
							null, null, $debug);
					}
				}
				if (count($att) == 0) $att = null;
			}
			$arr = MIME4::compose($text, $html, $att);
			if ($delivery == 'relay') {
				$res = SMTP4::send($resc, $addrs, implode($this->_mime->LE, $header['client']).$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'], (($this->Path != null) ? $this->Path : $from), $debug);
				return $this->_result($_RESULT, $res);
			} else if ($delivery == 'local') {
				$rpath = (!FUNC4::is_win() && $this->Path != null) ? '-f '.$this->Path : null;
				$spath = ($this->Path != null) ? @ini_set('sendmail_from', $this->Path) : false;
				if (!FUNC4::is_win()) $arr['content'] = str_replace("\r\n", "\n", $arr['content']);
				$res = mail($to, $subject, $arr['content'], implode($this->_mime->LE, $header['local']).$this->_mime->LE.$arr['header'], $rpath);
				if ($spath) @ini_restore('sendmail_from');
				return $this->_result(array(0 => 'send mail local'), $res);
			} else if ($delivery == 'client') {
				$group = array();
				foreach ($addrs as $addr) {
					$exp = explode('@', $addr);
					$group[strtolower($exp[1])][] = $addr;
				}
				$ret = true;
				$reg = (count($group) == 1);
				foreach ($group as $domain => $arrs) {
					$con = SMTP4::mxconnect($domain, $this->Port, $this->Tout, $this->Name, $this->Context, $debug);
					if ($reg) $this->_result(array($domain => $_RESULT));
					if ($con) {
						if (!SMTP4::send($con, $arrs, implode($this->_mime->LE, $header['client']).$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'], (($this->Path != null) ? $this->Path : $from), $debug)) $ret = false;
						if ($reg) $this->_result(array($domain => $_RESULT));
						SMTP4::disconnect($con, $debug);
					} else $ret = false;
				}
				if (!$reg) $this->_result(array(0 => 'send mail client'));
				return $ret;
			} else if ($delivery == 'sendmail' || $delivery == 'qmail') {
				$ret = false;
				$comm = (($delivery == 'sendmail') ? $this->SendMail : $this->QMail).' -oi'.(($this->Path != null) ? ' -f '.$this->Path : '').' -t';
				if ($con = popen($comm, 'w')) {
					if (fputs($con, implode($this->_mime->LE, $header['client']).$hbcc.$this->_mime->LE.$arr['header'].$this->_mime->LE.$this->_mime->LE.$arr['content'])) {
						$res = pclose($con) >> 8 & 0xFF;
						if ($res == 0) {
							$ret = true;
							$this->_result(array(0 => 'send mail using "'.ucfirst($delivery).'" program'));
						} else $this->_result(array(0 => $res));
					} else $this->_result(array(0 => 'can not write'));
				} else $this->_result(array(0 => 'can not write line command'));
				return $ret;
			}
		}
	}

}

    }
    class MAIL extends MAIL4 { }
}

